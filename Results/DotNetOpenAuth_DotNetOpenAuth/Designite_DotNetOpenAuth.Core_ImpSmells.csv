Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.Messaging,StandardMessageFactory,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,Cyclomatic complexity of the method is 10
Complex Method,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessIncomingMessageAsync,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AreEquivalent,Cyclomatic complexity of the method is 8
Long Parameter List,DotNetOpenAuth.Messaging,BinaryDataBagFormatter<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\BinaryDataBagFormatter.cs,BinaryDataBagFormatter,The method has 5 parameters. Parameters: signingKey' encryptingKey' compressed' maximumAge' decodeOnceOnly
Long Parameter List,DotNetOpenAuth.Messaging,BinaryDataBagFormatter<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\BinaryDataBagFormatter.cs,BinaryDataBagFormatter,The method has 8 parameters. Parameters: cryptoKeyStore' bucket' signed' encrypted' compressed' minimumAge' maximumAge' decodeOnceOnly
Long Parameter List,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,DataBagFormatterBase,The method has 5 parameters. Parameters: signingKey' encryptingKey' compressed' maximumAge' decodeOnceOnly
Long Parameter List,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,DataBagFormatterBase,The method has 8 parameters. Parameters: cryptoKeyStore' bucket' signed' encrypted' compressed' minimumAge' maximumAge' decodeOnceOnly
Long Parameter List,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,DataBagFormatterBase,The method has 5 parameters. Parameters: signed' encrypted' compressed' maximumAge' decodeOnceOnly
Long Parameter List,DotNetOpenAuth.Messaging,ProtocolFaultResponseException,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\ProtocolFaultResponseException.cs,ProtocolFaultResponseException,The method has 5 parameters. Parameters: channel' errorResponse' faultedMessage' innerException' message
Long Parameter List,DotNetOpenAuth.Messaging,UriStyleMessageFormatter<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\UriStyleMessageFormatter.cs,UriStyleMessageFormatter,The method has 5 parameters. Parameters: signingKey' encryptingKey' compressed' maximumAge' decodeOnceOnly
Long Parameter List,DotNetOpenAuth.Messaging,UriStyleMessageFormatter<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\UriStyleMessageFormatter.cs,UriStyleMessageFormatter,The method has 8 parameters. Parameters: cryptoKeyStore' bucket' signed' encrypted' compressed' minimumAge' maximumAge' decodeOnceOnly
Long Parameter List,DotNetOpenAuth.Messaging,HttpRequestInfo,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\HttpRequestInfo.cs,HttpRequestInfo,The method has 5 parameters. Parameters: httpMethod' requestUri' form' headers' cookies
Long Identifier,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,,The length of the parameter DefaultUntrustedXmlDictionaryReaderQuotas is 41.
Long Identifier,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,,The length of the parameter maximumIndirectMessageUrlLength is 31.
Long Identifier,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,,The length of the parameter javascriptStaticStringEscaping is 30.
Long Identifier,DotNetOpenAuth.Configuration,MessagingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\MessagingElement.cs,,The length of the parameter UntrustedWebRequestElementName is 30.
Long Identifier,DotNetOpenAuth.Configuration,MessagingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\MessagingElement.cs,,The length of the parameter MaximumMessageLifetimeConfigName is 32.
Long Identifier,DotNetOpenAuth.Configuration,MessagingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\MessagingElement.cs,,The length of the parameter RelaxSslRequirementsConfigName is 30.
Long Identifier,DotNetOpenAuth.Configuration,MessagingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\MessagingElement.cs,,The length of the parameter DefaultMaximumIndirectMessageUrlLength is 38.
Long Identifier,DotNetOpenAuth.Configuration,MessagingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\MessagingElement.cs,,The length of the parameter MaximumIndirectMessageUrlLengthConfigName is 41.
Long Identifier,DotNetOpenAuth.Configuration,MessagingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\MessagingElement.cs,,The length of the parameter PrivateSecretMaximumAgeConfigName is 33.
Long Identifier,DotNetOpenAuth.Configuration,ReportingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\ReportingElement.cs,,The length of the parameter MinimumReportingIntervalAttributeName is 37.
Long Identifier,DotNetOpenAuth.Configuration,ReportingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\ReportingElement.cs,,The length of the parameter MinimumFlushIntervalAttributeName is 33.
Long Identifier,DotNetOpenAuth.Configuration,ReportingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\ReportingElement.cs,,The length of the parameter IncludeFeatureUsageAttributeName is 32.
Long Identifier,DotNetOpenAuth.Configuration,ReportingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\ReportingElement.cs,,The length of the parameter IncludeEventStatisticsAttributeName is 35.
Long Identifier,DotNetOpenAuth.Configuration,ReportingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\ReportingElement.cs,,The length of the parameter IncludeLocalRequestUrisAttributeName is 36.
Long Identifier,DotNetOpenAuth.Configuration,TrustedProviderConfigurationCollection,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\TrustedProviderConfigurationCollection.cs,,The length of the parameter RejectAssertionsFromUntrustedProvidersConfigName is 48.
Long Statement,DotNetOpenAuth.Logging,EntLibLogProvider,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,GetShouldLogEntry,The length of the statement  "            MemberInitExpression memberInit = GetWriteLogExpression(Expression.Constant("***dummy***")' severityParameter' logNameParameter); " is 129.
Long Statement,DotNetOpenAuth.Logging.LogProviders,EntLibLogProvider,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,GetShouldLogEntry,The length of the statement  "            MemberInitExpression memberInit = GetWriteLogExpression(Expression.Constant("***dummy***")' severityParameter' logNameParameter); " is 129.
Long Statement,DotNetOpenAuth,MachineKeyUtil,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The length of the statement  "			Version targetFramework = (targetFrameworkProperty != null) ? targetFrameworkProperty.GetValue(null' null) as Version : null; " is 125.
Long Statement,DotNetOpenAuth,MachineKeyUtil,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The length of the statement  "				ProtectUnprotect protectThunk = (ProtectUnprotect)Delegate.CreateDelegate(typeof(ProtectUnprotect)' typeof(MachineKey)' "Protect"' ignoreCase: false' throwOnBindFailure: false); " is 177.
Long Statement,DotNetOpenAuth,MachineKeyUtil,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The length of the statement  "				ProtectUnprotect unprotectThunk = (ProtectUnprotect)Delegate.CreateDelegate(typeof(ProtectUnprotect)' typeof(MachineKey)' "Unprotect"' ignoreCase: false' throwOnBindFailure: false); " is 181.
Long Statement,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetReport,The length of the statement  "						using (var fileStream = new IsolatedStorageFileStream(observation.FileName' FileMode.Open' FileAccess.Read' FileShare.ReadWrite' file)) { " is 137.
Long Statement,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetReport,The length of the statement  "					using (var fileStream = new IsolatedStorageFileStream(eventFile' FileMode.Open' FileAccess.Read' FileShare.ReadWrite' file)) { " is 126.
Long Statement,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetOrCreateOriginIdentity,The length of the statement  "			using (var identityFileStream = new IsolatedStorageFileStream("identity.txt"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.Read' file)) { " is 147.
Long Statement,DotNetOpenAuth,RequiresEx,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\RequiresEx.cs,NotNullSubtype,The length of the statement  "			Requires.That(typeof(T).IsAssignableFrom(type)' parameterName' MessagingStrings.UnexpectedType' typeof(T).FullName' type.FullName); " is 131.
Long Statement,DotNetOpenAuth,Util,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The length of the statement  "						if (messageDictionary != null && messageDictionary.Description.Mapping.ContainsKey(key) && messageDictionary.Description.Mapping[key].IsSecuritySensitive) { " is 156.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The length of the statement  "				MessagingUtilities.ExtractKeyHandleAndPayload(messagePartName' value' out symmetricSecretHandle' out valueWithoutHandle); " is 121.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The length of the statement  "				ErrorUtilities.VerifyProtocol(this.IsSignatureValid(data' signature' symmetricSecretHandle)' MessagingStrings.SignatureInvalid); " is 128.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The length of the statement  "				ErrorUtilities.VerifyInternal(this.maximumAge.HasValue' "Oops!  How can we validate a nonce without a maximum message age?"); " is 125.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The length of the statement  "					Logger.OpenId.ErrorFormat("Replayed nonce detected ({0} {1}).  Rejecting message."' message.Nonce' message.UtcCreationDate); " is 124.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,IsSignatureValid,The length of the statement  "				return MessagingUtilities.AreEquivalentConstantTime(signature' this.CalculateSignature(signedData' symmetricSecretHandle)); " is 123.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,CalculateSignature,The length of the statement  "				ErrorUtilities.VerifyProtocol(key != null' MessagingStrings.MissingDecryptionKeyForHandle' this.cryptoKeyBucket' symmetricSecretHandle); " is 136.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Decrypt,The length of the statement  "				ErrorUtilities.VerifyProtocol(key != null' MessagingStrings.MissingDecryptionKeyForHandle' this.cryptoKeyBucket' symmetricSecretHandle); " is 136.
Long Statement,DotNetOpenAuth.Messaging,ErrorUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\ErrorUtilities.cs,VerifyHttpContext,The length of the statement  "			ErrorUtilities.VerifyOperation(HttpContext.Current != null && HttpContext.Current.Request != null' MessagingStrings.HttpContextRequired); " is 137.
Long Statement,DotNetOpenAuth.Messaging,ErrorUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\ErrorUtilities.cs,GetValueOrThrow,The length of the statement  "			VerifyProtocol(dictionary.TryGetValue(key' out value)' MessagingStrings.ExpectedParameterWasMissing' key' message.GetType().Name); " is 130.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,The length of the statement  "						if (parameters.Length == 2 && parameters[0].ParameterType == typeof(Uri) && parameters[1].ParameterType == typeof(Version)) { " is 125.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,InstantiateAsResponse,The length of the statement  "					ErrorUtilities.ThrowInternal("More than one matching constructor for request type " + requestType.Name + " and response type " + messageDescription.MessageType.Name); " is 166.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,InstantiateAsResponse,The length of the statement  "					ErrorUtilities.ThrowInternal("Unexpected request message type " + requestType.FullName + " for response type " + messageDescription.MessageType.Name); " is 150.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,FindMatchingResponseConstructors,The length of the statement  "			return this.responseMessageTypes[messageDescription].Where(pair => pair.Key.IsAssignableFrom(requestType)).Select(pair => pair.Value); " is 134.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,TryReadFromRequestAsync,The length of the statement  "			ErrorUtilities.VerifyProtocol(request != null' MessagingStrings.UnexpectedMessageReceived' typeof(TRequest)' untypedRequest.GetType()); " is 135.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,RequestAsync,The length of the statement  "			ErrorUtilities.VerifyProtocol(expectedResponse != null' MessagingStrings.UnexpectedMessageReceived' typeof(TResponse)' response.GetType()); " is 139.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,RequestAsync,The length of the statement  "			ErrorUtilities.VerifyProtocol(responseMessage != null' MessagingStrings.ExpectedMessageNotReceived' typeof(IProtocolMessage).Name); " is 131.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,GetRequestFromContext,The length of the statement  "			RequiresEx.ValidState(HttpContext.Current != null && HttpContext.Current.Request != null' MessagingStrings.HttpContextRequired); " is 128.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,Receive,The length of the statement  "			ErrorUtilities.VerifyProtocol(recipient == null || (directedMessage != null && (recipient.AllowedMethods & directedMessage.HttpMethods) != 0)' MessagingStrings.UnsupportedHttpVerbForMessageType' message.GetType().Name' recipient.AllowedMethods); " is 245.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,PrepareIndirectResponse,The length of the statement  "			Requires.That((message.HttpMethods & (HttpDeliveryMethods.GetRequest | HttpDeliveryMethods.PostRequest)) != 0' "message"' "GET or POST expected."); " is 147.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,Create301RedirectResponse,The length of the statement  "				Content = new StringContent(string.Format(CultureInfo.InvariantCulture' RedirectResponseBodyFormat' builder.Uri.AbsoluteUri))' " is 126.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,DeserializeFromJson,The length of the statement  "			using (var jsonReader = JsonReaderWriterFactory.CreateJsonReader(Encoding.UTF8.GetBytes(json)' this.XmlDictionaryReaderQuotas)) { " is 129.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessOutgoingMessageAsync,The length of the statement  "					ErrorUtilities.VerifyProtocol((appliedProtection & elementProtection.Value) == 0' MessagingStrings.TooManyBindingsOfferingSameProtection' elementProtection.Value); " is 163.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessOutgoingMessageAsync,The length of the statement  "				string recipient = (directedMessage != null && directedMessage.Recipient != null) ? directedMessage.Recipient.AbsoluteUri : "<response>"; " is 137.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,InitializeRequestAsPost,The length of the statement  "				ErrorUtilities.VerifyProtocol(requestMessageWithBinaryData == null || requestMessageWithBinaryData.BinaryData.Count == 0' MessagingStrings.BinaryDataRequiresMultipart); " is 168.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessIncomingMessageAsync,The length of the statement  "				Assumes.True(bindingElement.Channel != null); // CC bug: this.IncomingBindingElements ensures this... why must we assume it here? " is 129.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,CustomizeBindingElementOrder,The length of the statement  "			ErrorUtilities.VerifyArgument(this.IsBindingElementOrderValid(outgoingOrder)' MessagingStrings.InvalidCustomBindingElementOrder); " is 129.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,CustomizeBindingElementOrder,The length of the statement  "			ErrorUtilities.VerifyArgument(this.IsBindingElementOrderValid(incomingOrder)' MessagingStrings.InvalidCustomBindingElementOrder); " is 129.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ValidateAndPrepareBindingElements,The length of the statement  "				int countProtectionsOfThisKind = protectionElements.Count(element => (element.Protection & protectionKind) == protectionKind); " is 126.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ValidateAndPrepareBindingElements,The length of the statement  "				ErrorUtilities.VerifyProtocol(!(countProtectionsOfThisKind > 0 && !wasLastProtectionPresent)' MessagingStrings.RequiredProtectionMissing' protectionKind); " is 154.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ValidateAndPrepareBindingElements,The length of the statement  "			orderedList.AddRange(protectionElements.OrderBy(element => element.Protection' BindingElementOutgoingMessageApplicationOrder)); " is 127.
Long Statement,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,BindingElementOutgoingMessageApplicationOrder,The length of the statement  "			ErrorUtilities.VerifyInternal(protection1 != MessageProtections.None || protection2 != MessageProtections.None' "This comparison function should only be used to compare protection binding elements.  Otherwise we change the order of user-defined message transformations."); " is 272.
Long Statement,DotNetOpenAuth.Messaging,HttpRequestInfo,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\HttpRequestInfo.cs,ParseFormData,The length of the statement  "			ContentType contentType = string.IsNullOrEmpty(headers[HttpRequestHeaders.ContentType]) ? null : new ContentType(headers[HttpRequestHeaders.ContentType]); " is 154.
Long Statement,DotNetOpenAuth.Messaging,HttpRequestInfo,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\HttpRequestInfo.cs,ParseFormData,The length of the statement  "			if (httpMethod == "POST" && contentType != null && string.Equals(contentType.MediaType' Channel.HttpFormUrlEncoded' StringComparison.Ordinal) && inputStreamFunc != null) { " is 171.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetRequestUrlFromContext,The length of the statement  "			RequiresEx.ValidState(HttpContext.Current != null && HttpContext.Current.Request != null' MessagingStrings.HttpContextRequired); " is 128.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,StripQueryArgumentsWithPrefix,The length of the statement  "			var matchingKeys = queryArgs.Keys.OfType<string>().Where(key => key.StartsWith(prefix' StringComparison.OrdinalIgnoreCase)).ToList(); " is 133.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,EqualsConstantTime,The length of the statement  "			// and is more resistant to compiler optimizations than simply setting a boolean flag and returning the boolean after the loop. " is 127.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetPublicFacingUrl,The length of the statement  "				ErrorUtilities.VerifySupported(request.Url.Scheme == Uri.UriSchemeHttps || request.Url.Scheme == Uri.UriSchemeHttp' "Only HTTP and HTTPS are supported protocols."); " is 164.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetPublicFacingUrl,The length of the statement  "					(string.Equals(serverVariables["HTTP_FRONT_END_HTTPS"]' "on"' StringComparison.OrdinalIgnoreCase) ? Uri.UriSchemeHttps : request.Url.Scheme); " is 141.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ParseAuthorizationHeader,The length of the statement  "			if (authorizationHeader != null && authorizationHeader.Scheme.Equals(scheme' StringComparison.OrdinalIgnoreCase)) { // RFC 2617 says this is case INsensitive " is 157.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ExtractKeyHandleAndPayload,The length of the statement  "			ErrorUtilities.VerifyProtocol(privateHandleIndex > 0' MessagingStrings.UnexpectedMessagePartValue' messagePart ?? "<unknown>"' keyHandleAndBlob); " is 145.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetRandomString,The length of the statement  "			Requires.That(allowableCharacters != null && allowableCharacters.Length >= 2' "allowableCharacters"' "At least two allowable characters required."); " is 148.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,DecryptWithRandomSymmetricKey,The length of the statement  "					using (var cryptoStream = new CryptoStream(encryptedStream' symmetricCrypto.CreateDecryptor()' CryptoStreamMode.Read)) { " is 120.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The length of the statement  "					Logger.Messaging.InfoFormat("{0}.GetKeys returned no keys for bucket \"{1}\" with the required key length of {2} bits.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize); " is 190.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The length of the statement  "					Logger.Messaging.InfoFormat("The first key returned by {0}.GetKeys for bucket \"{1}\" with the required key length of {2} bits was too near expiry to use.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize); " is 226.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The length of the statement  "				ErrorUtilities.VerifyHost(minimumRemainingLife <= SymmetricSecretKeyLifespan' "Unable to create a new symmetric key with the required lifespan of {0} because it is beyond the limit of {1}."' minimumRemainingLife' SymmetricSecretKeyLifespan); " is 241.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The length of the statement  "					Logger.Messaging.Warn("A randomly generated crypto key handle collided with an existing handle.  Another randomly generated handle will be attempted till the retry count is met."); " is 180.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The length of the statement  "					throw new ProtocolException(MessagingStrings.DataCorruptionDetected' new ArgumentException("No more than two padding characters should be present for base64.")); " is 161.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ToDictionary,The length of the statement  "							Logger.OpenId.WarnFormat("Null key with value {0} encountered while translating NameValueCollection to Dictionary."' nvc[key]); " is 127.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,DeserializeFromJson,The length of the statement  "			using (var jsonReader = JsonReaderWriterFactory.CreateJsonReader(jsonBytes' 0' jsonBytes.Length' encoding' Channel.DefaultUntrustedXmlDictionaryReaderQuotas' null)) { " is 166.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetQueryStringBeforeRewriting,The length of the statement  "				ErrorUtilities.VerifyInternal(beforeRewriting != null' "UrlBeforeRewriting is null' so the query string cannot be determined."); " is 128.
Long Statement,DotNetOpenAuth.Messaging.Bindings,MemoryNonceStore,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\MemoryNonceStore.cs,ClearExpiredNonces,The length of the statement  "				var oldNonceLists = this.usedNonces.Keys.Where(time => time.ToUniversalTimeSafe() + this.maximumMessageAge < DateTime.UtcNow).ToList(); " is 135.
Long Statement,DotNetOpenAuth.Messaging.Bindings,StandardReplayProtectionBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\StandardReplayProtectionBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "				ErrorUtilities.VerifyProtocol(nonceMessage.Nonce.Length > 0 || this.AllowZeroLengthNonce' MessagingStrings.InvalidNonceReceived); " is 129.
Long Statement,DotNetOpenAuth.Messaging.Bindings,StandardReplayProtectionBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\StandardReplayProtectionBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "					Logger.OpenId.ErrorFormat("Replayed nonce detected ({0} {1}).  Rejecting message."' nonceMessage.Nonce' nonceMessage.UtcCreationDate); " is 134.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,ReflectMessageType,The length of the statement  "				foreach (MemberInfo member in currentType.GetMembers(BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)) { " is 175.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDictionary,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDictionary.cs,ContainsKey,The length of the statement  "				(this.description.Mapping.ContainsKey(key) && this.description.Mapping[key].GetValue(this.message' this.getOriginalValues) != null); " is 132.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessagePart,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessagePart.cs,SetValue,The length of the statement  "					var caseSensitivity = DotNetOpenAuthSection.Messaging.Strict ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase; " is 125.
Long Statement,DotNetOpenAuth.Configuration,TypeConfigurationCollection<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\TypeConfigurationCollection.cs,GetElementKey,The length of the statement  "			return (!string.IsNullOrEmpty(typedElement.TypeName) ? typedElement.TypeName : typedElement.XamlSource) ?? string.Empty; " is 120.
Long Statement,DotNetOpenAuth.Configuration,TypeConfigurationElement<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\TypeConfigurationElement.cs,CreateInstance,The length of the statement  "					ErrorUtilities.VerifyArgument((this.CustomType.Attributes & TypeAttributes.Public) != 0' Strings.ConfigurationTypeMustBePublic' this.CustomType.FullName); " is 154.
Long Statement,DotNetOpenAuth.Configuration,TypeConfigurationElement<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\TypeConfigurationElement.cs,CreateInstance,The length of the statement  "					ErrorUtilities.VerifyHost(HttpContext.Current != null' Strings.ConfigurationXamlReferenceRequiresHttpContext' this.XamlSource); " is 127.
Complex Conditional,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The conditional expression  "dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))"  is complex.
Complex Conditional,DotNetOpenAuth,UriUtil,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\UriUtil.cs,ToStringWithImpliedPorts,The conditional expression  "(builder.Port == 80 && string.Equals(builder.Scheme' "http"' StringComparison.OrdinalIgnoreCase)) ||  				(builder.Port == 443 && string.Equals(builder.Scheme' "https"' StringComparison.OrdinalIgnoreCase))"  is complex.
Complex Conditional,DotNetOpenAuth.Messaging,EnumerableCacheExtensions,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\EnumerableCacheExtensions.cs,CacheGeneratedResults,The conditional expression  "sequence is IList<T> ||  			  sequence is ICollection<T> ||  			  sequence is Array ||  			  sequence is EnumerableCache<T>"  is complex.
Complex Conditional,DotNetOpenAuth.Messaging,Channel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,HttpMethodHasEntity,The conditional expression  "httpMethod == HttpMethod.Get ||  				httpMethod == HttpMethod.Head ||  				httpMethod == HttpMethod.Delete ||  				httpMethod == HttpMethod.Options"  is complex.
Complex Conditional,DotNetOpenAuth.Messaging,HttpRequestInfo,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\HttpRequestInfo.cs,ParseFormData,The conditional expression  "httpMethod == "POST" && contentType != null && string.Equals(contentType.MediaType' Channel.HttpFormUrlEncoded' StringComparison.Ordinal) && inputStreamFunc != null"  is complex.
Virtual Method Call from Constructor,DotNetOpenAuth.Messaging,StandardMessageFactoryChannel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactoryChannel.cs,StandardMessageFactoryChannel,The constructor "StandardMessageFactoryChannel" calls a virtual method "AddMessageTypes".
Empty Catch Block,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The method has an empty catch block.
Empty Catch Block,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetSHA256Factory,The method has an empty catch block.
Empty Catch Block,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetIsolatedStorage,The method has an empty catch block.
Empty Catch Block,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetIsolatedStorage,The method has an empty catch block.
Magic Number,DotNetOpenAuth.Logging,ColouredConsoleLogProvider,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,DefaultMessageFormatter,The following statement contains a magic number: stringBuilder.Append(("[" + level.ToString().ToUpper() + "]").PadRight(8));
Magic Number,DotNetOpenAuth.Logging.LogProviders,ColouredConsoleLogProvider,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,DefaultMessageFormatter,The following statement contains a magic number: stringBuilder.Append(("[" + level.ToString().ToUpper() + "]").PadRight(8));
Magic Number,DotNetOpenAuth,MachineKeyUtil,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The following statement contains a magic number: if (targetFramework != null && targetFramework >= new Version(4' 5)) {  				ProtectUnprotect protectThunk = (ProtectUnprotect)Delegate.CreateDelegate(typeof(ProtectUnprotect)' typeof(MachineKey)' "Protect"' ignoreCase: false' throwOnBindFailure: false);  				ProtectUnprotect unprotectThunk = (ProtectUnprotect)Delegate.CreateDelegate(typeof(ProtectUnprotect)' typeof(MachineKey)' "Unprotect"' ignoreCase: false' throwOnBindFailure: false);  				if (protectThunk != null && unprotectThunk != null) {  					return new MachineKey45(protectThunk' unprotectThunk); // ASP.NET 4.5  				}  			}
Magic Number,DotNetOpenAuth,MachineKeyUtil,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The following statement contains a magic number: if (targetFramework != null && targetFramework >= new Version(4' 5)) {  				ProtectUnprotect protectThunk = (ProtectUnprotect)Delegate.CreateDelegate(typeof(ProtectUnprotect)' typeof(MachineKey)' "Protect"' ignoreCase: false' throwOnBindFailure: false);  				ProtectUnprotect unprotectThunk = (ProtectUnprotect)Delegate.CreateDelegate(typeof(ProtectUnprotect)' typeof(MachineKey)' "Unprotect"' ignoreCase: false' throwOnBindFailure: false);  				if (protectThunk != null && unprotectThunk != null) {  					return new MachineKey45(protectThunk' unprotectThunk); // ASP.NET 4.5  				}  			}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: byte[] dataWithHeader = new byte[checked(4 /* magic header */ + (256 / 8) /* purposes */ + userData.Length)];
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: byte[] dataWithHeader = new byte[checked(4 /* magic header */ + (256 / 8) /* purposes */ + userData.Length)];
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: byte[] dataWithHeader = new byte[checked(4 /* magic header */ + (256 / 8) /* purposes */ + userData.Length)];
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: unchecked {  					dataWithHeader[0] = (byte)(MagicHeader >> 24);  					dataWithHeader[1] = (byte)(MagicHeader >> 16);  					dataWithHeader[2] = (byte)(MagicHeader >> 8);  					dataWithHeader[3] = (byte)MagicHeader;  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: unchecked {  					dataWithHeader[0] = (byte)(MagicHeader >> 24);  					dataWithHeader[1] = (byte)(MagicHeader >> 16);  					dataWithHeader[2] = (byte)(MagicHeader >> 8);  					dataWithHeader[3] = (byte)MagicHeader;  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: unchecked {  					dataWithHeader[0] = (byte)(MagicHeader >> 24);  					dataWithHeader[1] = (byte)(MagicHeader >> 16);  					dataWithHeader[2] = (byte)(MagicHeader >> 8);  					dataWithHeader[3] = (byte)MagicHeader;  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: unchecked {  					dataWithHeader[0] = (byte)(MagicHeader >> 24);  					dataWithHeader[1] = (byte)(MagicHeader >> 16);  					dataWithHeader[2] = (byte)(MagicHeader >> 8);  					dataWithHeader[3] = (byte)MagicHeader;  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: unchecked {  					dataWithHeader[0] = (byte)(MagicHeader >> 24);  					dataWithHeader[1] = (byte)(MagicHeader >> 16);  					dataWithHeader[2] = (byte)(MagicHeader >> 8);  					dataWithHeader[3] = (byte)MagicHeader;  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: Buffer.BlockCopy(purposeHash' 0' dataWithHeader' 4' purposeHash.Length);
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: Buffer.BlockCopy(userData' 0' dataWithHeader' 4 + (256 / 8)' userData.Length);
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: Buffer.BlockCopy(userData' 0' dataWithHeader' 4 + (256 / 8)' userData.Length);
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Protect,The following statement contains a magic number: Buffer.BlockCopy(userData' 0' dataWithHeader' 4 + (256 / 8)' userData.Length);
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,Unprotect,The following statement contains a magic number: try {  					// decrypt / verify signature  					byte[] dataWithHeader = MachineKey.Decode(hexEncodedData' MachineKeyProtection.All);    					// validate magic header and purpose string  					if (dataWithHeader != null  						&& dataWithHeader.Length >= (4 + (256 / 8))  						&& (uint)IPAddress.NetworkToHostOrder(BitConverter.ToInt32(dataWithHeader' 0)) == MagicHeader  						&& AreByteArraysEqual(new ArraySegment<byte>(purposeHash)' new ArraySegment<byte>(dataWithHeader' 4' 256 / 8))) {  						// validation succeeded  						byte[] userData = new byte[dataWithHeader.Length - 4 - (256 / 8)];  						Buffer.BlockCopy(dataWithHeader' 4 + (256 / 8)' userData' 0' userData.Length);  						return userData;  					}  				}  				catch {  					// swallow since will be rethrown immediately below  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,BinaryToHex,The following statement contains a magic number: StringBuilder builder = new StringBuilder(checked(binary.Length * 2));
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,BinaryToHex,The following statement contains a magic number: for (int i = 0; i < binary.Length; i++) {  					byte b = binary[i];  					builder.Append(HexDigit(b >> 4));  					builder.Append(HexDigit(b & 0x0F));  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,HexDigit,The following statement contains a magic number: return (char)(value > 9 ? value + '7' : value + '0');
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,HexToBinary,The following statement contains a magic number: int size = hex.Length / 2;
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,HexToBinary,The following statement contains a magic number: for (int idx = 0; idx < size; idx++) {  					bytes[idx] = (byte)((HexValue(hex[idx * 2]) << 4) + HexValue(hex[(idx * 2) + 1]));  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,HexToBinary,The following statement contains a magic number: for (int idx = 0; idx < size; idx++) {  					bytes[idx] = (byte)((HexValue(hex[idx * 2]) << 4) + HexValue(hex[(idx * 2) + 1]));  				}
Magic Number,DotNetOpenAuth,MachineKey40,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,HexToBinary,The following statement contains a magic number: for (int idx = 0; idx < size; idx++) {  					bytes[idx] = (byte)((HexValue(hex[idx * 2]) << 4) + HexValue(hex[(idx * 2) + 1]));  				}
Magic Number,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: lock (initializationSync) {  				if (!broken && !initialized) {  					try {  						file = GetIsolatedStorage();  						reportOriginIdentity = GetOrCreateOriginIdentity();    						observations.Add(observedRequests = new PersistentHashSet(file' "requests.txt"' 3));  						observations.Add(observedCultures = new PersistentHashSet(file' "cultures.txt"' 20));  						observations.Add(observedFeatures = new PersistentHashSet(file' "features.txt"' int.MaxValue));    						// Record site-wide features in use.  						if (HttpContext.Current != null && HttpContext.Current.ApplicationInstance != null) {  							// MVC or web forms?  							// front-end or back end web farm?  							// url rewriting?  							////RecordFeatureUse(IsMVC ? "ASP.NET MVC" : "ASP.NET Web Forms");  						}    						initialized = true;  					} catch (Exception e) {  						// This is supposed to be as low-risk as possible' so if it fails' just disable reporting  						// and avoid rethrowing.  						broken = true;  						Logger.Library.ErrorException("Error while trying to initialize reporting."' e);  					}  				}  			}
Magic Number,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: lock (initializationSync) {  				if (!broken && !initialized) {  					try {  						file = GetIsolatedStorage();  						reportOriginIdentity = GetOrCreateOriginIdentity();    						observations.Add(observedRequests = new PersistentHashSet(file' "requests.txt"' 3));  						observations.Add(observedCultures = new PersistentHashSet(file' "cultures.txt"' 20));  						observations.Add(observedFeatures = new PersistentHashSet(file' "features.txt"' int.MaxValue));    						// Record site-wide features in use.  						if (HttpContext.Current != null && HttpContext.Current.ApplicationInstance != null) {  							// MVC or web forms?  							// front-end or back end web farm?  							// url rewriting?  							////RecordFeatureUse(IsMVC ? "ASP.NET MVC" : "ASP.NET Web Forms");  						}    						initialized = true;  					} catch (Exception e) {  						// This is supposed to be as low-risk as possible' so if it fails' just disable reporting  						// and avoid rethrowing.  						broken = true;  						Logger.Library.ErrorException("Error while trying to initialize reporting."' e);  					}  				}  			}
Magic Number,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,DemuxLogMessage,The following statement contains a magic number: if (line != null) {  				string[] parts = line.Split(new char[] { ' ' }' 2);  				if (parts.Length == 2) {  					string level = parts[0];  					string message = parts[1];  					switch (level) {  						case "INFO":  							Logger.Library.Info(message);  							break;  						case "WARN":  							Logger.Library.Warn(message);  							break;  						case "ERROR":  							Logger.Library.Error(message);  							break;  						case "FATAL":  							Logger.Library.Fatal(message);  							break;  					}  				}  			}
Magic Number,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,DemuxLogMessage,The following statement contains a magic number: if (line != null) {  				string[] parts = line.Split(new char[] { ' ' }' 2);  				if (parts.Length == 2) {  					string level = parts[0];  					string message = parts[1];  					switch (level) {  						case "INFO":  							Logger.Library.Info(message);  							break;  						case "WARN":  							Logger.Library.Warn(message);  							break;  						case "ERROR":  							Logger.Library.Error(message);  							break;  						case "FATAL":  							Logger.Library.Fatal(message);  							break;  					}  				}  			}
Magic Number,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetOrCreateOriginIdentity,The following statement contains a magic number: const int GuidLength = 16;
Magic Number,DotNetOpenAuth,PersistentCounter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,PersistentCounter,The following statement contains a magic number: while (!this.reader.EndOfStream) {  					string line = this.reader.ReadLine();  					string[] parts = line.Split(separator' 2);  					int counter;  					if (int.TryParse(parts[0]' out counter)) {  						string category = string.Empty;  						if (parts.Length > 1) {  							category = parts[1];  						}  						this.counters[category] = counter;  					}  				}
Magic Number,DotNetOpenAuth,UriUtil,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\UriUtil.cs,ToStringWithImpliedPorts,The following statement contains a magic number: if ((builder.Port == 80 && string.Equals(builder.Scheme' "http"' StringComparison.OrdinalIgnoreCase)) ||  				(builder.Port == 443 && string.Equals(builder.Scheme' "https"' StringComparison.OrdinalIgnoreCase))) {  				// An implied port may be removed.  				string url = builder.ToString();    				// Be really careful to only remove the first :80 or :443 so we are guaranteed  				// we're removing only the port (and not something in the query string that   				// looks like a port.  				string result = Regex.Replace(url' @"^(https?://[^:]+):\d+"' m => m.Groups[1].Value' RegexOptions.IgnoreCase);  				Assumes.True(result != null); // Regex.Replace never returns null  				return result;  			} else {  				// The port must be explicitly given anyway.  				return builder.ToString();  			}
Magic Number,DotNetOpenAuth,UriUtil,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\UriUtil.cs,ToStringWithImpliedPorts,The following statement contains a magic number: if ((builder.Port == 80 && string.Equals(builder.Scheme' "http"' StringComparison.OrdinalIgnoreCase)) ||  				(builder.Port == 443 && string.Equals(builder.Scheme' "https"' StringComparison.OrdinalIgnoreCase))) {  				// An implied port may be removed.  				string url = builder.ToString();    				// Be really careful to only remove the first :80 or :443 so we are guaranteed  				// we're removing only the port (and not something in the query string that   				// looks like a port.  				string result = Regex.Replace(url' @"^(https?://[^:]+):\d+"' m => m.Groups[1].Value' RegexOptions.IgnoreCase);  				Assumes.True(result != null); // Regex.Replace never returns null  				return result;  			} else {  				// The port must be explicitly given anyway.  				return builder.ToString();  			}
Magic Number,DotNetOpenAuth,Util,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: return new DelayedToString<IEnumerable<KeyValuePair<K' V>>>(  				pairs'  				p => {  					Requires.NotNull(pairs' "pairs");  					var dictionary = pairs as IDictionary<K' V>;  					var messageDictionary = pairs as MessageDictionary;  					StringBuilder sb = new StringBuilder(dictionary != null ? dictionary.Count * 40 : 200);  					foreach (var pair in pairs) {  						var key = pair.Key.ToString();  						string value = pair.Value.ToString();  						if (messageDictionary != null && messageDictionary.Description.Mapping.ContainsKey(key) && messageDictionary.Description.Mapping[key].IsSecuritySensitive) {  							value = "********";  						}    						sb.AppendFormat("\t{0}: {1}{2}"' key' value' Environment.NewLine);  					}  					return sb.ToString();  				});
Magic Number,DotNetOpenAuth,Util,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: return new DelayedToString<IEnumerable<KeyValuePair<K' V>>>(  				pairs'  				p => {  					Requires.NotNull(pairs' "pairs");  					var dictionary = pairs as IDictionary<K' V>;  					var messageDictionary = pairs as MessageDictionary;  					StringBuilder sb = new StringBuilder(dictionary != null ? dictionary.Count * 40 : 200);  					foreach (var pair in pairs) {  						var key = pair.Key.ToString();  						string value = pair.Value.ToString();  						if (messageDictionary != null && messageDictionary.Description.Mapping.ContainsKey(key) && messageDictionary.Description.Mapping[key].IsSecuritySensitive) {  							value = "********";  						}    						sb.AppendFormat("\t{0}: {1}{2}"' key' value' Environment.NewLine);  					}  					return sb.ToString();  				});
Magic Number,DotNetOpenAuth,Util,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: return new DelayedToString<IEnumerable<T>>(  				list'  				l => {  					// Code contracts not allowed in generator methods.  					ErrorUtilities.VerifyArgumentNotNull(l' "l");    					string newLine = Environment.NewLine;  					////Assumes.True(newLine != null && newLine.Length > 0);  					StringBuilder sb = new StringBuilder();  					if (multiLineElements) {  						sb.AppendLine("[{");  						foreach (T obj in l) {  							// Prepare the string repersentation of the object  							string objString = obj != null ? obj.ToString() : "<NULL>";    							// Indent every line printed  							objString = objString.Replace(newLine' Environment.NewLine + "\t");  							sb.Append("\t");  							sb.Append(objString);    							if (!objString.EndsWith(Environment.NewLine' StringComparison.Ordinal)) {  								sb.AppendLine();  							}  							sb.AppendLine("}' {");  						}  						if (sb.Length > 2 + Environment.NewLine.Length) { // if anything was in the enumeration  							sb.Length -= 2 + Environment.NewLine.Length; // trim off the last "' {\r\n"  						} else {  							sb.Length -= 1 + Environment.NewLine.Length; // trim off the opening {  						}  						sb.Append("]");  						return sb.ToString();  					} else {  						sb.Append("{");  						foreach (T obj in l) {  							sb.Append(obj != null ? obj.ToString() : "<NULL>");  							sb.AppendLine("'");  						}  						if (sb.Length > 1) {  							sb.Length -= 1;  						}  						sb.Append("}");  						return sb.ToString();  					}  				});
Magic Number,DotNetOpenAuth,Util,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: return new DelayedToString<IEnumerable<T>>(  				list'  				l => {  					// Code contracts not allowed in generator methods.  					ErrorUtilities.VerifyArgumentNotNull(l' "l");    					string newLine = Environment.NewLine;  					////Assumes.True(newLine != null && newLine.Length > 0);  					StringBuilder sb = new StringBuilder();  					if (multiLineElements) {  						sb.AppendLine("[{");  						foreach (T obj in l) {  							// Prepare the string repersentation of the object  							string objString = obj != null ? obj.ToString() : "<NULL>";    							// Indent every line printed  							objString = objString.Replace(newLine' Environment.NewLine + "\t");  							sb.Append("\t");  							sb.Append(objString);    							if (!objString.EndsWith(Environment.NewLine' StringComparison.Ordinal)) {  								sb.AppendLine();  							}  							sb.AppendLine("}' {");  						}  						if (sb.Length > 2 + Environment.NewLine.Length) { // if anything was in the enumeration  							sb.Length -= 2 + Environment.NewLine.Length; // trim off the last "' {\r\n"  						} else {  							sb.Length -= 1 + Environment.NewLine.Length; // trim off the opening {  						}  						sb.Append("]");  						return sb.ToString();  					} else {  						sb.Append("{");  						foreach (T obj in l) {  							sb.Append(obj != null ? obj.ToString() : "<NULL>");  							sb.AppendLine("'");  						}  						if (sb.Length > 1) {  							sb.Length -= 1;  						}  						sb.Append("}");  						return sb.ToString();  					}  				});
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Serialize,The following statement contains a magic number: int capacity = this.signed ? 4 + message.Signature.Length + 4 + encoded.Length : encoded.Length;
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Serialize,The following statement contains a magic number: int capacity = this.signed ? 4 + message.Signature.Length + 4 + encoded.Length : encoded.Length;
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: if (this.signed) {  				using (var dataStream = new MemoryStream(data)) {  					var dataReader = new BinaryReader(dataStream);  					signature = dataReader.ReadBuffer(1024);  					data = dataReader.ReadBuffer(8 * 1024);  				}    				// Verify that the verification code was issued by message authorization server.  				ErrorUtilities.VerifyProtocol(this.IsSignatureValid(data' signature' symmetricSecretHandle)' MessagingStrings.SignatureInvalid);  			}
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: if (this.signed) {  				using (var dataStream = new MemoryStream(data)) {  					var dataReader = new BinaryReader(dataStream);  					signature = dataReader.ReadBuffer(1024);  					data = dataReader.ReadBuffer(8 * 1024);  				}    				// Verify that the verification code was issued by message authorization server.  				ErrorUtilities.VerifyProtocol(this.IsSignatureValid(data' signature' symmetricSecretHandle)' MessagingStrings.SignatureInvalid);  			}
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase<T>,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: if (this.signed) {  				using (var dataStream = new MemoryStream(data)) {  					var dataReader = new BinaryReader(dataStream);  					signature = dataReader.ReadBuffer(1024);  					data = dataReader.ReadBuffer(8 * 1024);  				}    				// Verify that the verification code was issued by message authorization server.  				ErrorUtilities.VerifyProtocol(this.IsSignatureValid(data' signature' symmetricSecretHandle)' MessagingStrings.SignatureInvalid);  			}
Magic Number,DotNetOpenAuth.Messaging,StandardMessageFactory,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,The following statement contains a magic number: foreach (MessageDescription messageDescription in messageTypes) {  				bool supportedMessageType = false;    				// First see whether this message fits the recognized pattern for request messages.  				if (typeof(IDirectedProtocolMessage).IsAssignableFrom(messageDescription.MessageType)) {  					foreach (ConstructorInfo ctor in messageDescription.Constructors) {  						ParameterInfo[] parameters = ctor.GetParameters();  						if (parameters.Length == 2 && parameters[0].ParameterType == typeof(Uri) && parameters[1].ParameterType == typeof(Version)) {  							supportedMessageType = true;  							this.requestMessageTypes.Add(messageDescription' ctor);  							break;  						}  					}  				}    				// Also see if this message fits the recognized pattern for response messages.  				if (typeof(IDirectResponseProtocolMessage).IsAssignableFrom(messageDescription.MessageType)) {  					var responseCtors = new Dictionary<Type' ConstructorInfo>(messageDescription.Constructors.Length);  					foreach (ConstructorInfo ctor in messageDescription.Constructors) {  						ParameterInfo[] parameters = ctor.GetParameters();  						if (parameters.Length == 1 && typeof(IDirectedProtocolMessage).IsAssignableFrom(parameters[0].ParameterType)) {  							responseCtors.Add(parameters[0].ParameterType' ctor);  						}  					}    					if (responseCtors.Count > 0) {  						supportedMessageType = true;  						this.responseMessageTypes.Add(messageDescription' responseCtors);  					}  				}    				if (!supportedMessageType) {  					unsupportedMessageTypes.Add(messageDescription);  				}  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,CreateUntrustedXmlReaderSettings,The following statement contains a magic number: return new XmlReaderSettings {  				MaxCharactersFromEntities = 1024'  				XmlResolver = null'  				DtdProcessing = DtdProcessing.Prohibit'  			};
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ParseAuthorizationHeader,The following statement contains a magic number: if (authorizationHeader != null && authorizationHeader.Scheme.Equals(scheme' StringComparison.OrdinalIgnoreCase)) { // RFC 2617 says this is case INsensitive  				return from element in authorizationHeader.Parameter.Split(CommaArray)  					   let parts = element.Trim().Split(EqualsArray' 2)  					   let key = Uri.UnescapeDataString(parts[0])  					   let value = Uri.UnescapeDataString(parts[1].Trim(QuoteArray))  					   select new KeyValuePair<string' string>(key' value);  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetRandomString,The following statement contains a magic number: Requires.That(allowableCharacters != null && allowableCharacters.Length >= 2' "allowableCharacters"' "At least two allowable characters required.");
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,DecryptWithRandomSymmetricKey,The following statement contains a magic number: using (var encryptedStream = new MemoryStream(buffer)) {  				var encryptedStreamReader = new BinaryReader(encryptedStream);    				byte[] encryptedPrequel = encryptedStreamReader.ReadBuffer(4096);  				byte[] prequel = crypto.Decrypt(encryptedPrequel' false);    				using (var symmetricCrypto = SymmetricAlgorithm.Create()) {  					symmetricCrypto.Mode = CipherMode.CBC;    					byte[] symmetricKey = new byte[symmetricCrypto.Key.Length];  					byte[] symmetricIV = new byte[symmetricCrypto.IV.Length];  					Array.Copy(prequel' symmetricKey' symmetricKey.Length);  					Array.Copy(prequel' symmetricKey.Length' symmetricIV' 0' symmetricIV.Length);  					symmetricCrypto.Key = symmetricKey;  					symmetricCrypto.IV = symmetricIV;    					// Allocate space for the decrypted buffer.  We don't know how long it will be yet'  					// but it will never be larger than the encrypted buffer.  					var decryptedBuffer = new byte[encryptedStream.Length - encryptedStream.Position];  					int actualDecryptedLength;    					using (var cryptoStream = new CryptoStream(encryptedStream' symmetricCrypto.CreateDecryptor()' CryptoStreamMode.Read)) {  						actualDecryptedLength = cryptoStream.Read(decryptedBuffer' 0' decryptedBuffer.Length);  					}    					// Create a new buffer with only the decrypted data.  					var finalDecryptedBuffer = new byte[actualDecryptedLength];  					Array.Copy(decryptedBuffer' finalDecryptedBuffer' actualDecryptedLength);  					return finalDecryptedBuffer;  				}  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: Requires.That(keySize % 8 == 0' "keySize"' "Key size must be a multiple of 8.");
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: var cryptoKeyPair = cryptoKeyStore.GetKeys(bucket).FirstOrDefault(pair => pair.Value.Key.Length == keySize / 8);
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: if (cryptoKeyPair.Value == null || cryptoKeyPair.Value.ExpiresUtc < DateTime.UtcNow + minimumRemainingLife) {  				// No key exists with enough remaining life for the required purpose.  Create a new key.  				if (cryptoKeyPair.Value == null) {  					Logger.Messaging.InfoFormat("{0}.GetKeys returned no keys for bucket \"{1}\" with the required key length of {2} bits.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize);  				} else {  					Logger.Messaging.InfoFormat("The first key returned by {0}.GetKeys for bucket \"{1}\" with the required key length of {2} bits was too near expiry to use.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize);  				}    				ErrorUtilities.VerifyHost(minimumRemainingLife <= SymmetricSecretKeyLifespan' "Unable to create a new symmetric key with the required lifespan of {0} because it is beyond the limit of {1}."' minimumRemainingLife' SymmetricSecretKeyLifespan);  				byte[] secret = GetCryptoRandomData(keySize / 8);  				DateTime expires = DateTime.UtcNow + SymmetricSecretKeyLifespan;  				var cryptoKey = new CryptoKey(secret' expires);    				// Store this key so we can find and use it later.  				int failedAttempts = 0;  			tryAgain:  				try {  					string handle = GetRandomString(SymmetricSecretHandleLength' Base64WebSafeCharacters);  					cryptoKeyPair = new KeyValuePair<string' CryptoKey>(handle' cryptoKey);  					cryptoKeyStore.StoreKey(bucket' handle' cryptoKey);  				} catch (CryptoKeyCollisionException) {  					ErrorUtilities.VerifyInternal(++failedAttempts < 3' "Unable to derive a unique handle to a private symmetric key.");  					Logger.Messaging.Warn("A randomly generated crypto key handle collided with an existing handle.  Another randomly generated handle will be attempted till the retry count is met.");  					goto tryAgain;  				}  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: if (cryptoKeyPair.Value == null || cryptoKeyPair.Value.ExpiresUtc < DateTime.UtcNow + minimumRemainingLife) {  				// No key exists with enough remaining life for the required purpose.  Create a new key.  				if (cryptoKeyPair.Value == null) {  					Logger.Messaging.InfoFormat("{0}.GetKeys returned no keys for bucket \"{1}\" with the required key length of {2} bits.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize);  				} else {  					Logger.Messaging.InfoFormat("The first key returned by {0}.GetKeys for bucket \"{1}\" with the required key length of {2} bits was too near expiry to use.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize);  				}    				ErrorUtilities.VerifyHost(minimumRemainingLife <= SymmetricSecretKeyLifespan' "Unable to create a new symmetric key with the required lifespan of {0} because it is beyond the limit of {1}."' minimumRemainingLife' SymmetricSecretKeyLifespan);  				byte[] secret = GetCryptoRandomData(keySize / 8);  				DateTime expires = DateTime.UtcNow + SymmetricSecretKeyLifespan;  				var cryptoKey = new CryptoKey(secret' expires);    				// Store this key so we can find and use it later.  				int failedAttempts = 0;  			tryAgain:  				try {  					string handle = GetRandomString(SymmetricSecretHandleLength' Base64WebSafeCharacters);  					cryptoKeyPair = new KeyValuePair<string' CryptoKey>(handle' cryptoKey);  					cryptoKeyStore.StoreKey(bucket' handle' cryptoKey);  				} catch (CryptoKeyCollisionException) {  					ErrorUtilities.VerifyInternal(++failedAttempts < 3' "Unable to derive a unique handle to a private symmetric key.");  					Logger.Messaging.Warn("A randomly generated crypto key handle collided with an existing handle.  Another randomly generated handle will be attempted till the retry count is met.");  					goto tryAgain;  				}  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: switch (base64WebSafe.Length % 4) {  				case 3:  					missingPaddingCharacters = 1;  					break;  				case 2:  					missingPaddingCharacters = 2;  					break;  				case 0:  					missingPaddingCharacters = 0;  					break;  				default:  					throw new ProtocolException(MessagingStrings.DataCorruptionDetected' new ArgumentException("No more than two padding characters should be present for base64."));  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: switch (base64WebSafe.Length % 4) {  				case 3:  					missingPaddingCharacters = 1;  					break;  				case 2:  					missingPaddingCharacters = 2;  					break;  				case 0:  					missingPaddingCharacters = 0;  					break;  				default:  					throw new ProtocolException(MessagingStrings.DataCorruptionDetected' new ArgumentException("No more than two padding characters should be present for base64."));  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: switch (base64WebSafe.Length % 4) {  				case 3:  					missingPaddingCharacters = 1;  					break;  				case 2:  					missingPaddingCharacters = 2;  					break;  				case 0:  					missingPaddingCharacters = 0;  					break;  				default:  					throw new ProtocolException(MessagingStrings.DataCorruptionDetected' new ArgumentException("No more than two padding characters should be present for base64."));  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: switch (base64WebSafe.Length % 4) {  				case 3:  					missingPaddingCharacters = 1;  					break;  				case 2:  					missingPaddingCharacters = 2;  					break;  				case 0:  					missingPaddingCharacters = 0;  					break;  				default:  					throw new ProtocolException(MessagingStrings.DataCorruptionDetected' new ArgumentException("No more than two padding characters should be present for base64."));  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,CopyUpTo,The following statement contains a magic number: byte[] buffer = new byte[1024];
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,CopyUpTo,The following statement contains a magic number: while ((readBytes = copyFrom.Read(buffer' 0' Math.Min(1024' maximumBytesToCopy))) > 0) {  				int writeBytes = Math.Min(maximumBytesToCopy' readBytes);  				copyTo.Write(buffer' 0' writeBytes);  				totalCopiedBytes += writeBytes;  				maximumBytesToCopy -= writeBytes;  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,CreateSnapshot,The following statement contains a magic number: MemoryStream copyTo = new MemoryStream(copyFrom.CanSeek ? (int)copyFrom.Length : 4 * 1024);
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,CreateSnapshot,The following statement contains a magic number: MemoryStream copyTo = new MemoryStream(copyFrom.CanSeek ? (int)copyFrom.Length : 4 * 1024);
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,CreateQueryString,The following statement contains a magic number: StringBuilder sb = new StringBuilder(args.Count() * 10);
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AppendQueryArgs,The following statement contains a magic number: if (args != null && args.Count() > 0) {  				StringBuilder sb = new StringBuilder(50 + (args.Count() * 10));  				if (!string.IsNullOrEmpty(builder.Query)) {  					sb.Append(builder.Query.Substring(1));  					sb.Append('&');  				}  				sb.Append(CreateQueryString(args));    				builder.Query = sb.ToString();  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AppendQueryArgs,The following statement contains a magic number: if (args != null && args.Count() > 0) {  				StringBuilder sb = new StringBuilder(50 + (args.Count() * 10));  				if (!string.IsNullOrEmpty(builder.Query)) {  					sb.Append(builder.Query.Substring(1));  					sb.Append('&');  				}  				sb.Append(CreateQueryString(args));    				builder.Query = sb.ToString();  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AppendFragmentArgs,The following statement contains a magic number: if (args != null && args.Count() > 0) {  				StringBuilder sb = new StringBuilder(50 + (args.Count() * 10));  				if (!string.IsNullOrEmpty(builder.Fragment)) {  					sb.Append(builder.Fragment);  					sb.Append('&');  				}  				sb.Append(CreateQueryString(args));    				builder.Fragment = sb.ToString();  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AppendFragmentArgs,The following statement contains a magic number: if (args != null && args.Count() > 0) {  				StringBuilder sb = new StringBuilder(50 + (args.Count() * 10));  				if (!string.IsNullOrEmpty(builder.Fragment)) {  					sb.Append(builder.Fragment);  					sb.Append('&');  				}  				sb.Append(CreateQueryString(args));    				builder.Fragment = sb.ToString();  			}
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ReadBuffer,The following statement contains a magic number: Requires.Range(maxBufferSize > 0 && maxBufferSize < 1024 * 1024' "maxBufferSize");
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ReadBuffer,The following statement contains a magic number: Requires.Range(maxBufferSize > 0 && maxBufferSize < 1024 * 1024' "maxBufferSize");
Magic Number,DotNetOpenAuth.Messaging.Bindings,HardCodedKeyCryptoKeyStore,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\HardCodedKeyCryptoKeyStore.cs,HardCodedKeyCryptoKeyStore,The following statement contains a magic number: this.OneCryptoKey = new CryptoKey(secret' DateTime.MaxValue.AddDays(-2).ToUniversalTime());
Magic Number,DotNetOpenAuth.Messaging.Bindings,MemoryNonceStore,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\MemoryNonceStore.cs,StoreNonce,The following statement contains a magic number: lock (this.nonceLock) {  				List<string> nonces;  				if (!this.usedNonces.TryGetValue(timestamp' out nonces)) {  					this.usedNonces[timestamp] = nonces = new List<string>(4);  				}    				if (nonces.Contains(completeNonce)) {  					return false;  				}    				nonces.Add(completeNonce);    				// Clear expired nonces if it's time to take a moment to do that.  				// Unchecked so that this can int overflow without an exception.  				unchecked {  					this.nonceClearingCounter++;  				}  				if (this.nonceClearingCounter % AutoCleaningFrequency == 0) {  					this.ClearExpiredNonces();  				}    				return true;  			}
Magic Number,DotNetOpenAuth.Messaging.Reflection,MessagePart,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessagePart.cs,GetDefaultEncoder,The following statement contains a magic number: ErrorUtilities.VerifyInternal(converterAttributes.Length < 2' "Too many attributes applied.");
Missing Default,DotNetOpenAuth,Reporting,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,DemuxLogMessage,The following switch statement is missing a default case: switch (level) {  						case "INFO":  							Logger.Library.Info(message);  							break;  						case "WARN":  							Logger.Library.Warn(message);  							break;  						case "ERROR":  							Logger.Library.Error(message);  							break;  						case "FATAL":  							Logger.Library.Fatal(message);  							break;  					}
