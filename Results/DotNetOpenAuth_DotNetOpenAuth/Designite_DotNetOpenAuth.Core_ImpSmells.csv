Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetReport,Cyclomatic complexity of the method is 10
Complex Method,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,SendStatsAsync,Cyclomatic complexity of the method is 10
Complex Method,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,DemuxLogMessage,Cyclomatic complexity of the method is 14
Complex Method,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Serialize,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,Cyclomatic complexity of the method is 11
Complex Method,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,Cyclomatic complexity of the method is 10
Complex Method,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,PrepareResponseAsync,Cyclomatic complexity of the method is 11
Complex Method,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,RequestCoreAsync,Cyclomatic complexity of the method is 13
Complex Method,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessIncomingMessageAsync,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,Compress,Cyclomatic complexity of the method is 11
Complex Method,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,Decompress,Cyclomatic complexity of the method is 13
Complex Method,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,Cyclomatic complexity of the method is 11
Complex Method,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AreEquivalent,Cyclomatic complexity of the method is 8
Complex Method,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetHttpDeliveryMethod,Cyclomatic complexity of the method is 8
Complex Method,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetHttpVerb,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.Configuration,TypeConfigurationElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\TypeConfigurationElement.cs,CreateInstance,Cyclomatic complexity of the method is 8
Long Parameter List,DotNetOpenAuth.Messaging,BinaryDataBagFormatter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\BinaryDataBagFormatter.cs,BinaryDataBagFormatter,The method has 5 parameters.
Long Parameter List,DotNetOpenAuth.Messaging,BinaryDataBagFormatter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\BinaryDataBagFormatter.cs,BinaryDataBagFormatter,The method has 8 parameters.
Long Parameter List,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,DataBagFormatterBase,The method has 5 parameters.
Long Parameter List,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,DataBagFormatterBase,The method has 8 parameters.
Long Parameter List,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,DataBagFormatterBase,The method has 5 parameters.
Long Parameter List,DotNetOpenAuth.Messaging,ProtocolFaultResponseException,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\ProtocolFaultResponseException.cs,ProtocolFaultResponseException,The method has 5 parameters.
Long Parameter List,DotNetOpenAuth.Messaging,UriStyleMessageFormatter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\UriStyleMessageFormatter.cs,UriStyleMessageFormatter,The method has 5 parameters.
Long Parameter List,DotNetOpenAuth.Messaging,UriStyleMessageFormatter,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\UriStyleMessageFormatter.cs,UriStyleMessageFormatter,The method has 8 parameters.
Long Parameter List,DotNetOpenAuth.Messaging,HttpRequestInfo,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\HttpRequestInfo.cs,HttpRequestInfo,The method has 5 parameters.
Long Statement,DotNetOpenAuth.Logging,LogProvider,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,ResolveLogProvider,The length of the statement  "		Console.WriteLine ("Exception occured resolving a log provider. Logging for this assembly {0} is disabled. {1}"' typeof(LogProvider).Assembly.FullName' ex); " is 156.
Long Statement,DotNetOpenAuth.Logging.LogProviders,EntLibLogProvider,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,GetWriteLogEntry,The length of the statement  "	return Expression.Lambda<Action<string' string' TraceEventType>> (writeLogEntryExpression' logNameParameter' messageParameter' severityParameter).Compile (); " is 157.
Long Statement,DotNetOpenAuth.Logging.LogProviders,EntLibLogProvider,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,GetShouldLogEntry,The length of the statement  "	MemberInitExpression memberInit = GetWriteLogExpression (Expression.Constant ("***dummy***")' severityParameter' logNameParameter); " is 131.
Long Statement,DotNetOpenAuth.Logging.LogProviders,EntLibLogProvider,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,GetShouldLogEntry,The length of the statement  "	return Expression.Lambda<Func<string' TraceEventType' bool>> (writeLogEntryExpression' logNameParameter' severityParameter).Compile (); " is 135.
Long Statement,DotNetOpenAuth.Logging.LogProviders,EntLibLogProvider,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,GetWriteLogExpression,The length of the statement  "		Expression.Bind (entryType.GetProperty ("TimeStamp")' Expression.Property (null' typeof(DateTime).GetProperty ("UtcNow")))' " is 123.
Long Statement,DotNetOpenAuth.Logging.LogProviders,EntLibLogProvider,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,GetWriteLogExpression,The length of the statement  "		Expression.Bind (entryType.GetProperty ("Categories")' Expression.ListInit (Expression.New (typeof(List<string>))' typeof(List<string>).GetMethod ("Add"' new[] { " is 161.
Long Statement,DotNetOpenAuth,MachineKeyUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The length of the statement  "	Version targetFramework = (targetFrameworkProperty != null) ? targetFrameworkProperty.GetValue (null' null) as Version : null; " is 126.
Long Statement,DotNetOpenAuth,MachineKeyUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The length of the statement  "		ProtectUnprotect protectThunk = (ProtectUnprotect)Delegate.CreateDelegate (typeof(ProtectUnprotect)' typeof(MachineKey)' "Protect"' ignoreCase: false' throwOnBindFailure: false); " is 178.
Long Statement,DotNetOpenAuth,MachineKeyUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The length of the statement  "		ProtectUnprotect unprotectThunk = (ProtectUnprotect)Delegate.CreateDelegate (typeof(ProtectUnprotect)' typeof(MachineKey)' "Unprotect"' ignoreCase: false' throwOnBindFailure: false); " is 182.
Long Statement,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetReport,The length of the statement  "				using (var fileStream = new IsolatedStorageFileStream (observation.FileName' FileMode.Open' FileAccess.Read' FileShare.ReadWrite' file)) { " is 138.
Long Statement,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetReport,The length of the statement  "			using (var fileStream = new IsolatedStorageFileStream (eventFile' FileMode.Open' FileAccess.Read' FileShare.ReadWrite' file)) { " is 127.
Long Statement,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetOrCreateOriginIdentity,The length of the statement  "	using (var identityFileStream = new IsolatedStorageFileStream ("identity.txt"' FileMode.OpenOrCreate' FileAccess.ReadWrite' FileShare.Read' file)) { " is 148.
Long Statement,DotNetOpenAuth,RequiresEx,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\RequiresEx.cs,NotNullSubtype,The length of the statement  "	Requires.That (typeof(T).IsAssignableFrom (type)' parameterName' MessagingStrings.UnexpectedType' typeof(T).FullName' type.FullName); " is 133.
Long Statement,DotNetOpenAuth,UriUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\UriUtil.cs,ToStringWithImpliedPorts,The length of the statement  "	if ((builder.Port == 80 && string.Equals (builder.Scheme' "http"' StringComparison.OrdinalIgnoreCase)) || (builder.Port == 443 && string.Equals (builder.Scheme' "https"' StringComparison.OrdinalIgnoreCase))) { " is 209.
Long Statement,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The length of the statement  "			if (messageDictionary != null && messageDictionary.Description.Mapping.ContainsKey (key) && messageDictionary.Description.Mapping [key].IsSecuritySensitive) { " is 158.
Long Statement,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,GetWebResourceUrl,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' Strings.EmbeddedResourceUrlProviderRequired' string.Join ("' "' new string[] { " is 158.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The length of the statement  "		MessagingUtilities.ExtractKeyHandleAndPayload (messagePartName' value' out symmetricSecretHandle' out valueWithoutHandle); " is 122.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The length of the statement  "		ErrorUtilities.VerifyProtocol (this.IsSignatureValid (data' signature' symmetricSecretHandle)' MessagingStrings.SignatureInvalid); " is 130.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The length of the statement  "		ErrorUtilities.VerifyInternal (this.maximumAge.HasValue' "Oops!  How can we validate a nonce without a maximum message age?"); " is 126.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The length of the statement  "			Logger.OpenId.ErrorFormat ("Replayed nonce detected ({0} {1}).  Rejecting message."' message.Nonce' message.UtcCreationDate); " is 125.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,IsSignatureValid,The length of the statement  "		return MessagingUtilities.AreEquivalentConstantTime (signature' this.CalculateSignature (signedData' symmetricSecretHandle)); " is 125.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,CalculateSignature,The length of the statement  "		ErrorUtilities.VerifyProtocol (key != null' MessagingStrings.MissingDecryptionKeyForHandle' this.cryptoKeyBucket' symmetricSecretHandle); " is 137.
Long Statement,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Decrypt,The length of the statement  "		ErrorUtilities.VerifyProtocol (key != null' MessagingStrings.MissingDecryptionKeyForHandle' this.cryptoKeyBucket' symmetricSecretHandle); " is 137.
Long Statement,DotNetOpenAuth.Messaging,ErrorUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\ErrorUtilities.cs,VerifyProtocol,The length of the statement  "			Logger.Messaging.Error (string.Format (CultureInfo.CurrentCulture' "Protocol error: {0}{1}{2}"' exception.Message' Environment.NewLine' new StackTrace ())); " is 156.
Long Statement,DotNetOpenAuth.Messaging,ErrorUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\ErrorUtilities.cs,VerifyHttpContext,The length of the statement  "	ErrorUtilities.VerifyOperation (HttpContext.Current != null && HttpContext.Current.Request != null' MessagingStrings.HttpContextRequired); " is 138.
Long Statement,DotNetOpenAuth.Messaging,ErrorUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\ErrorUtilities.cs,GetValueOrThrow,The length of the statement  "	VerifyProtocol (dictionary.TryGetValue (key' out value)' MessagingStrings.ExpectedParameterWasMissing' key' message.GetType ().Name); " is 133.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,The length of the statement  "				if (parameters.Length == 2 && parameters [0].ParameterType == typeof(Uri) && parameters [1].ParameterType == typeof(Version)) { " is 127.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,The length of the statement  "	ErrorUtilities.VerifySupported (!unsupportedMessageTypes.Any ()' MessagingStrings.StandardMessageFactoryUnsupportedMessageType' unsupportedMessageTypes.ToStringDeferred ()); " is 173.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,GetMessageDescription,The length of the statement  "	var matches = this.requestMessageTypes.Keys.Where (message => message.CheckMessagePartsPassBasicValidation (fields)).OrderByDescending (message => CountInCommon (message.Mapping.Keys' fields.Keys)).ThenByDescending (message => message.Mapping.Count).CacheGeneratedResults (); " is 275.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,GetMessageDescription,The length of the statement  "			Logger.Messaging.WarnFormat ("Multiple message types seemed to fit the incoming data: {0}"' matches.ToStringDeferred ()); " is 121.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,GetMessageDescription,The length of the statement  "	orderby GetDerivationDistance (ctors.First ().GetParameters () [0].ParameterType' request.GetType ())' CountInCommon (message.Mapping.Keys' fields.Keys) descending' message.Mapping.Count descending " is 197.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,GetMessageDescription,The length of the statement  "			Logger.Messaging.WarnFormat ("Multiple message types seemed to fit the incoming data: {0}"' matches.ToStringDeferred ()); " is 121.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,InstantiateAsResponse,The length of the statement  "			ErrorUtilities.ThrowInternal ("More than one matching constructor for request type " + requestType.Name + " and response type " + messageDescription.MessageType.Name); " is 167.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,InstantiateAsResponse,The length of the statement  "			ErrorUtilities.ThrowInternal ("Unexpected request message type " + requestType.FullName + " for response type " + messageDescription.MessageType.Name); " is 151.
Long Statement,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,FindMatchingResponseConstructors,The length of the statement  "	return this.responseMessageTypes [messageDescription].Where (pair => pair.Key.IsAssignableFrom (requestType)).Select (pair => pair.Value); " is 138.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,PrepareResponseAsync,The length of the statement  "		ErrorUtilities.VerifyArgumentNamed (directedMessage != null' "message"' MessagingStrings.IndirectMessagesMustImplementIDirectedProtocolMessage' typeof(IDirectedProtocolMessage).FullName); " is 187.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,PrepareResponseAsync,The length of the statement  "		ErrorUtilities.VerifyArgumentNamed (directedMessage.Recipient != null' "message"' MessagingStrings.DirectedMessageMissingRecipient); " is 132.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,PrepareResponseAsync,The length of the statement  "		throw ErrorUtilities.ThrowArgumentNamed ("message"' MessagingStrings.UnrecognizedEnumValue' "Transport"' message.Transport); " is 124.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,TryReadFromRequestAsync,The length of the statement  "	ErrorUtilities.VerifyProtocol (request != null' MessagingStrings.UnexpectedMessageReceived' typeof(TRequest)' untypedRequest.GetType ()); " is 137.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,RequestAsync,The length of the statement  "	ErrorUtilities.VerifyProtocol (expectedResponse != null' MessagingStrings.UnexpectedMessageReceived' typeof(TResponse)' response.GetType ()); " is 141.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,RequestAsync,The length of the statement  "	ErrorUtilities.VerifyProtocol (responseMessage != null' MessagingStrings.ExpectedMessageNotReceived' typeof(IProtocolMessage).Name); " is 132.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ParseUrlEncodedFormContentAsync,The length of the statement  "	if (request.Content != null && request.Content.Headers.ContentType != null && request.Content.Headers.ContentType.MediaType.Equals (HttpFormUrlEncoded)) { " is 154.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,GetRequestFromContext,The length of the statement  "	RequiresEx.ValidState (HttpContext.Current != null && HttpContext.Current.Request != null' MessagingStrings.HttpContextRequired); " is 129.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,HttpMethodHasEntity,The length of the statement  "	if (httpMethod == HttpMethod.Get || httpMethod == HttpMethod.Head || httpMethod == HttpMethod.Delete || httpMethod == HttpMethod.Options) { " is 139.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,HttpMethodHasEntity,The length of the statement  "	} else if (httpMethod == HttpMethod.Post || httpMethod == HttpMethod.Put || string.Equals (httpMethod.Method' "PATCH"' StringComparison.Ordinal)) { " is 147.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,RequestCoreAsync,The length of the statement  "					Logger.Http.ErrorFormat ("Error received in HTTP response: {0} {1}\n{2}"' (int)response.StatusCode' response.ReasonPhrase' errorContent); " is 137.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,Receive,The length of the statement  "	ErrorUtilities.VerifyProtocol (recipient == null || (directedMessage != null && (recipient.AllowedMethods & directedMessage.HttpMethods) != 0)' MessagingStrings.UnsupportedHttpVerbForMessageType' message.GetType ().Name' recipient.AllowedMethods); " is 247.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,PrepareIndirectResponse,The length of the statement  "	Requires.That ((message.HttpMethods & (HttpDeliveryMethods.GetRequest | HttpDeliveryMethods.PostRequest)) != 0' "message"' "GET or POST expected."); " is 148.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,PrepareIndirectResponse,The length of the statement  "		ErrorUtilities.VerifyProtocol ((message.HttpMethods & HttpDeliveryMethods.PostRequest) == HttpDeliveryMethods.PostRequest' MessagingStrings.MessageExceedsGetSizePostNotAllowed); " is 177.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,Create301RedirectResponse,The length of the statement  "		Content = new StringContent (string.Format (CultureInfo.InvariantCulture' RedirectResponseBodyFormat' builder.Uri.AbsoluteUri))' " is 128.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,CreateFormPostResponse,The length of the statement  "			hiddenFields.AppendFormat ("\t<input type=\"hidden\" name=\"{0}\" value=\"{1}\" />\r\n"' HttpUtility.HtmlEncode (field.Key)' HttpUtility.HtmlEncode (field.Value)); " is 163.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,CreateFormPostResponse,The length of the statement  "		bodyWriter.WriteLine (IndirectMessageFormPostFormat' HttpUtility.HtmlEncode (message.Recipient.AbsoluteUri)' hiddenFields); " is 123.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,DeserializeFromJson,The length of the statement  "	using (var jsonReader = JsonReaderWriterFactory.CreateJsonReader (Encoding.UTF8.GetBytes (json)' this.XmlDictionaryReaderQuotas)) { " is 131.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessOutgoingMessageAsync,The length of the statement  "			ErrorUtilities.VerifyProtocol ((appliedProtection & elementProtection.Value) == 0' MessagingStrings.TooManyBindingsOfferingSameProtection' elementProtection.Value); " is 164.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessOutgoingMessageAsync,The length of the statement  "		string recipient = (directedMessage != null && directedMessage.Recipient != null) ? directedMessage.Recipient.AbsoluteUri : "<response>"; " is 137.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessOutgoingMessageAsync,The length of the statement  "		Logger.Channel.InfoFormat ("Prepared outgoing {0} ({1}) message for {2}: {3}{4}"' message.GetType ().Name' message.Version' recipient' Environment.NewLine' messageAccessor.ToStringDeferred ()); " is 193.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,InitializeRequestAsPost,The length of the statement  "		ErrorUtilities.VerifyProtocol (requestMessageWithBinaryData == null || requestMessageWithBinaryData.BinaryData.Count == 0' MessagingStrings.BinaryDataRequiresMultipart); " is 169.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessIncomingMessageAsync,The length of the statement  "		Logger.Channel.InfoFormat ("Processing incoming {0} ({1}) message:{2}{3}"' message.GetType ().Name' message.Version' Environment.NewLine' messageAccessor.ToStringDeferred ()); " is 175.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ProcessIncomingMessageAsync,The length of the statement  "		Logger.Channel.DebugFormat ("After binding element processing' the received {0} ({1}) message is: {2}{3}"' message.GetType ().Name' message.Version' Environment.NewLine' messageAccessor.ToStringDeferred ()); " is 207.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,CustomizeBindingElementOrder,The length of the statement  "	ErrorUtilities.VerifyArgument (this.IsBindingElementOrderValid (outgoingOrder)' MessagingStrings.InvalidCustomBindingElementOrder); " is 131.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,CustomizeBindingElementOrder,The length of the statement  "	ErrorUtilities.VerifyArgument (this.IsBindingElementOrderValid (incomingOrder)' MessagingStrings.InvalidCustomBindingElementOrder); " is 131.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ValidateAndPrepareBindingElements,The length of the statement  "	var transformationElements = new List<IChannelBindingElement> (elements.Where (element => element.Protection == MessageProtections.None)); " is 138.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ValidateAndPrepareBindingElements,The length of the statement  "	var protectionElements = new List<IChannelBindingElement> (elements.Where (element => element.Protection != MessageProtections.None)); " is 134.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ValidateAndPrepareBindingElements,The length of the statement  "		int countProtectionsOfThisKind = protectionElements.Count (element => (element.Protection & protectionKind) == protectionKind); " is 127.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ValidateAndPrepareBindingElements,The length of the statement  "		ErrorUtilities.VerifyProtocol (!(countProtectionsOfThisKind > 0 && !wasLastProtectionPresent)' MessagingStrings.RequiredProtectionMissing' protectionKind); " is 155.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,ValidateAndPrepareBindingElements,The length of the statement  "	orderedList.AddRange (protectionElements.OrderBy (element => element.Protection' BindingElementOutgoingMessageApplicationOrder)); " is 129.
Long Statement,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,BindingElementOutgoingMessageApplicationOrder,The length of the statement  "	ErrorUtilities.VerifyInternal (protection1 != MessageProtections.None || protection2 != MessageProtections.None' "This comparison function should only be used to compare protection binding elements.  Otherwise we change the order of user-defined message transformations."); " is 273.
Long Statement,DotNetOpenAuth.Messaging,HttpRequestInfo,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\HttpRequestInfo.cs,ParseFormData,The length of the statement  "	ContentType contentType = string.IsNullOrEmpty (headers [HttpRequestHeaders.ContentType]) ? null : new ContentType (headers [HttpRequestHeaders.ContentType]); " is 158.
Long Statement,DotNetOpenAuth.Messaging,HttpRequestInfo,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\HttpRequestInfo.cs,ParseFormData,The length of the statement  "	if (httpMethod == "POST" && contentType != null && string.Equals (contentType.MediaType' Channel.HttpFormUrlEncoded' StringComparison.Ordinal) && inputStreamFunc != null) { " is 172.
Long Statement,DotNetOpenAuth.Messaging,MessageSerializer,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessageSerializer.cs,IsNumeric,The length of the statement  "	return type.IsAssignableFrom (typeof(double)) || type.IsAssignableFrom (typeof(float)) || type.IsAssignableFrom (typeof(short)) || type.IsAssignableFrom (typeof(int)) || type.IsAssignableFrom (typeof(long)) || type.IsAssignableFrom (typeof(ushort)) || type.IsAssignableFrom (typeof(uint)) || type.IsAssignableFrom (typeof(ulong)); " is 330.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetRequestUrlFromContext,The length of the statement  "	RequiresEx.ValidState (HttpContext.Current != null && HttpContext.Current.Request != null' MessagingStrings.HttpContextRequired); " is 129.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,StripQueryArgumentsWithPrefix,The length of the statement  "	var matchingKeys = queryArgs.Keys.OfType<string> ().Where (key => key.StartsWith (prefix' StringComparison.OrdinalIgnoreCase)).ToList (); " is 137.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,EqualsConstantTime,The length of the statement  "	// and is more resistant to compiler optimizations than simply setting a boolean flag and returning the boolean after the loop. " is 127.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetPublicFacingUrl,The length of the statement  "		ErrorUtilities.VerifySupported (request.Url.Scheme == Uri.UriSchemeHttps || request.Url.Scheme == Uri.UriSchemeHttp' "Only HTTP and HTTPS are supported protocols."); " is 165.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetPublicFacingUrl,The length of the statement  "		string scheme = serverVariables ["HTTP_X_FORWARDED_PROTO"] ?? (string.Equals (serverVariables ["HTTP_FRONT_END_HTTPS"]' "on"' StringComparison.OrdinalIgnoreCase) ? Uri.UriSchemeHttps : request.Url.Scheme); " is 205.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,StripMessagePartsFromQueryString,The length of the statement  "	var matchingKeys = queryArgs.Keys.OfType<string> ().Where (key => messageDescription.Mapping.ContainsKey (key)).ToList (); " is 122.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ExtractKeyHandleAndPayload,The length of the statement  "	ErrorUtilities.VerifyProtocol (privateHandleIndex > 0' MessagingStrings.UnexpectedMessagePartValue' messagePart ?? "<unknown>"' keyHandleAndBlob); " is 146.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetRandomString,The length of the statement  "	Requires.That (allowableCharacters != null && allowableCharacters.Length >= 2' "allowableCharacters"' "At least two allowable characters required."); " is 149.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,DecryptWithRandomSymmetricKey,The length of the statement  "			using (var cryptoStream = new CryptoStream (encryptedStream' symmetricCrypto.CreateDecryptor ()' CryptoStreamMode.Read)) { " is 122.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The length of the statement  "			Logger.Messaging.InfoFormat ("{0}.GetKeys returned no keys for bucket \"{1}\" with the required key length of {2} bits.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize); " is 191.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The length of the statement  "			Logger.Messaging.InfoFormat ("The first key returned by {0}.GetKeys for bucket \"{1}\" with the required key length of {2} bits was too near expiry to use.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize); " is 227.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The length of the statement  "		ErrorUtilities.VerifyHost (minimumRemainingLife <= SymmetricSecretKeyLifespan' "Unable to create a new symmetric key with the required lifespan of {0} because it is beyond the limit of {1}."' minimumRemainingLife' SymmetricSecretKeyLifespan); " is 242.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The length of the statement  "			Logger.Messaging.Warn ("A randomly generated crypto key handle collided with an existing handle.  Another randomly generated handle will be attempted till the retry count is met."); " is 181.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The length of the statement  "		throw new ProtocolException (MessagingStrings.DataCorruptionDetected' new ArgumentException ("No more than two padding characters should be present for base64.")); " is 163.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetDirectUriRequest,The length of the statement  "	Requires.Argument (response.StatusCode == HttpStatusCode.Redirect || response.StatusCode == HttpStatusCode.RedirectKeepVerb || response.StatusCode == HttpStatusCode.RedirectMethod || response.StatusCode == HttpStatusCode.TemporaryRedirect' "response"' "Redirecting response expected."); " is 286.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ToDictionary,The length of the statement  "					Logger.OpenId.WarnFormat ("Null key with value {0} encountered while translating NameValueCollection to Dictionary."' nvc [key]); " is 129.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,DeserializeFromJson,The length of the statement  "	using (var jsonReader = JsonReaderWriterFactory.CreateJsonReader (jsonBytes' 0' jsonBytes.Length' encoding' Channel.DefaultUntrustedXmlDictionaryReaderQuotas' null)) { " is 167.
Long Statement,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetQueryStringBeforeRewriting,The length of the statement  "		ErrorUtilities.VerifyInternal (beforeRewriting != null' "UrlBeforeRewriting is null' so the query string cannot be determined."); " is 129.
Long Statement,DotNetOpenAuth.Messaging.Bindings,AsymmetricCryptoKeyStoreWrapper,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\AsymmetricCryptoKeyStoreWrapper.cs,GetKeys,The length of the statement  "	return this.dataStore.GetKeys (bucket).Select (pair => new KeyValuePair<string' CryptoKey> (pair.Key' this.Decrypt (bucket' pair.Key' pair.Value))); " is 148.
Long Statement,DotNetOpenAuth.Messaging.Bindings,MemoryNonceStore,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\MemoryNonceStore.cs,ClearExpiredNonces,The length of the statement  "		var oldNonceLists = this.usedNonces.Keys.Where (time => time.ToUniversalTimeSafe () + this.maximumMessageAge < DateTime.UtcNow).ToList (); " is 138.
Long Statement,DotNetOpenAuth.Messaging.Bindings,StandardReplayProtectionBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\StandardReplayProtectionBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "		ErrorUtilities.VerifyProtocol (nonceMessage.Nonce.Length > 0 || this.AllowZeroLengthNonce' MessagingStrings.InvalidNonceReceived); " is 130.
Long Statement,DotNetOpenAuth.Messaging.Bindings,StandardReplayProtectionBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\StandardReplayProtectionBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "			Logger.OpenId.ErrorFormat ("Replayed nonce detected ({0} {1}).  Rejecting message."' nonceMessage.Nonce' nonceMessage.UtcCreationDate); " is 135.
Long Statement,DotNetOpenAuth.Messaging.Bindings,StandardExpirationBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\StandardExpirationBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "		ErrorUtilities.VerifyProtocol (creationDate <= DateTime.UtcNow + DotNetOpenAuthSection.Messaging.MaximumClockSkew' MessagingStrings.MessageTimestampInFuture' creationDate); " is 172.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,EnsureMessagePartsPassBasicValidation,The length of the statement  "		Logger.Messaging.ErrorFormat ("Error while performing basic validation of {0} ({3}) with these message parts:{1}{2}"' this.MessageType.Name' Environment.NewLine' parts.ToStringDeferred ()' this.MessageVersion); " is 210.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,CheckMessagePartsPassBasicValidation,The length of the statement  "	return this.CheckRequiredMessagePartsArePresent (parts.Keys' false) && this.CheckRequiredProtocolMessagePartsAreNotEmpty (parts' false) && this.CheckMessagePartsConstantValues (parts' false); " is 191.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,CheckRequiredMessagePartsArePresent,The length of the statement  "			ErrorUtilities.ThrowProtocol (MessagingStrings.RequiredParametersMissing' this.MessageType.FullName' string.Join ("' "' missingKeys)); " is 134.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,CheckRequiredMessagePartsArePresent,The length of the statement  "			Logger.Messaging.DebugFormat (MessagingStrings.RequiredParametersMissing' this.MessageType.FullName' missingKeys.ToStringDeferred ()); " is 134.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,CheckRequiredProtocolMessagePartsAreNotEmpty,The length of the statement  "			ErrorUtilities.ThrowProtocol (MessagingStrings.RequiredNonEmptyParameterWasEmpty' this.MessageType.FullName' string.Join ("' "' emptyValuedKeys)); " is 146.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,CheckRequiredProtocolMessagePartsAreNotEmpty,The length of the statement  "			Logger.Messaging.DebugFormat (MessagingStrings.RequiredNonEmptyParameterWasEmpty' this.MessageType.FullName' emptyValuedKeys.ToStringDeferred ()); " is 146.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,CheckMessagePartsConstantValues,The length of the statement  "			ErrorUtilities.ThrowProtocol (MessagingStrings.RequiredMessagePartConstantIncorrect' this.MessageType.FullName' string.Join ("' "' badConstantValues)); " is 151.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,CheckMessagePartsConstantValues,The length of the statement  "			Logger.Messaging.DebugFormat (MessagingStrings.RequiredMessagePartConstantIncorrect' this.MessageType.FullName' badConstantValues.ToStringDeferred ()); " is 151.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,ReflectMessageType,The length of the statement  "		foreach (MemberInfo member in currentType.GetMembers (BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.DeclaredOnly)) { " is 176.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,ReflectMessageType,The length of the statement  "				MessagePartAttribute partAttribute = (from a in member.GetCustomAttributes (typeof(MessagePartAttribute)' true).OfType<MessagePartAttribute> () " is 143.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDescription.cs,ReflectMessageType,The length of the statement  "						Logger.Messaging.WarnFormat ("Message type {0} has more than one message part named {1}.  Inherited members will be hidden."' this.MessageType.Name' part.Name); " is 160.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessageDictionary,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessageDictionary.cs,ContainsKey,The length of the statement  "	return this.message.ExtraData.ContainsKey (key) || (this.description.Mapping.ContainsKey (key) && this.description.Mapping [key].GetValue (this.message' this.getOriginalValues) != null); " is 186.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessagePart,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessagePart.cs,SetValue,The length of the statement  "			var caseSensitivity = DotNetOpenAuthSection.Messaging.Strict ? StringComparison.Ordinal : StringComparison.OrdinalIgnoreCase; " is 125.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessagePart,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessagePart.cs,SetValue,The length of the statement  "				throw new ArgumentException (string.Format (CultureInfo.CurrentCulture' MessagingStrings.UnexpectedMessagePartValueForConstant' message.GetType ().Name' this.Name' constantValue' value)); " is 187.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessagePart,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessagePart.cs,CreateFallbackMapping,The length of the statement  "	return new ValueMapping (obj => obj != null ? obj.ToString () : null' null' str => str != null ? Convert.ChangeType (str' type' CultureInfo.InvariantCulture) : null); " is 166.
Long Statement,DotNetOpenAuth.Messaging.Reflection,MessagePart,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessagePart.cs,ValidateSettings,The length of the statement  "		throw new ArgumentException (string.Format (CultureInfo.CurrentCulture' "Invalid combination: {0} on message type {1} is a non-nullable value type but is marked as optional."' member.Name' member.DeclaringType)); " is 212.
Long Statement,DotNetOpenAuth.Configuration,TypeConfigurationCollection,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\TypeConfigurationCollection.cs,GetElementKey,The length of the statement  "	return (!string.IsNullOrEmpty (typedElement.TypeName) ? typedElement.TypeName : typedElement.XamlSource) ?? string.Empty; " is 121.
Long Statement,DotNetOpenAuth.Configuration,TypeConfigurationElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\TypeConfigurationElement.cs,CreateInstance,The length of the statement  "			ErrorUtilities.VerifyArgument ((this.CustomType.Attributes & TypeAttributes.Public) != 0' Strings.ConfigurationTypeMustBePublic' this.CustomType.FullName); " is 155.
Long Statement,DotNetOpenAuth.Configuration,TypeConfigurationElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Configuration\TypeConfigurationElement.cs,CreateInstance,The length of the statement  "			ErrorUtilities.VerifyHost (HttpContext.Current != null' Strings.ConfigurationXamlReferenceRequiresHttpContext' this.XamlSource); " is 128.
Complex Conditional,DotNetOpenAuth,UriUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\UriUtil.cs,ToStringWithImpliedPorts,The conditional expression  "(builder.Port == 80 && string.Equals (builder.Scheme' "http"' StringComparison.OrdinalIgnoreCase)) || (builder.Port == 443 && string.Equals (builder.Scheme' "https"' StringComparison.OrdinalIgnoreCase))"  is complex.
Complex Conditional,DotNetOpenAuth.Messaging,EnumerableCacheExtensions,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\EnumerableCacheExtensions.cs,CacheGeneratedResults,The conditional expression  "sequence is IList<T> || sequence is ICollection<T> || sequence is Array || sequence is EnumerableCache<T>"  is complex.
Complex Conditional,DotNetOpenAuth.Messaging,Channel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Channel.cs,HttpMethodHasEntity,The conditional expression  "httpMethod == HttpMethod.Get || httpMethod == HttpMethod.Head || httpMethod == HttpMethod.Delete || httpMethod == HttpMethod.Options"  is complex.
Complex Conditional,DotNetOpenAuth.Messaging,HttpRequestInfo,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\HttpRequestInfo.cs,ParseFormData,The conditional expression  "httpMethod == "POST" && contentType != null && string.Equals (contentType.MediaType' Channel.HttpFormUrlEncoded' StringComparison.Ordinal) && inputStreamFunc != null"  is complex.
Virtual Method Call from Constructor,DotNetOpenAuth.Messaging,StandardMessageFactoryChannel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactoryChannel.cs,StandardMessageFactoryChannel,The constructor "StandardMessageFactoryChannel" calls a virtual method "AddMessageTypes".
Empty Catch Block,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetIsolatedStorage,The method has an empty catch block.
Empty Catch Block,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,GetIsolatedStorage,The method has an empty catch block.
Magic Number,DotNetOpenAuth.Logging.LogProviders,ColouredConsoleLogProvider,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\App_Packages\LibLog.2.0\LibLog.cs,DefaultMessageFormatter,The following statement contains a magic number: stringBuilder.Append (("[" + level.ToString ().ToUpper () + "]").PadRight (8));  
Magic Number,DotNetOpenAuth,MachineKeyUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The following statement contains a magic number: if (targetFramework != null && targetFramework >= new Version (4' 5)) {  	ProtectUnprotect protectThunk = (ProtectUnprotect)Delegate.CreateDelegate (typeof(ProtectUnprotect)' typeof(MachineKey)' "Protect"' ignoreCase: false' throwOnBindFailure: false);  	ProtectUnprotect unprotectThunk = (ProtectUnprotect)Delegate.CreateDelegate (typeof(ProtectUnprotect)' typeof(MachineKey)' "Unprotect"' ignoreCase: false' throwOnBindFailure: false);  	if (protectThunk != null && unprotectThunk != null) {  		return new MachineKey45 (protectThunk' unprotectThunk);  		// ASP.NET 4.5  	}  }  
Magic Number,DotNetOpenAuth,MachineKeyUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\MachineKeyUtil.cs,GetMachineKeyImpl,The following statement contains a magic number: if (targetFramework != null && targetFramework >= new Version (4' 5)) {  	ProtectUnprotect protectThunk = (ProtectUnprotect)Delegate.CreateDelegate (typeof(ProtectUnprotect)' typeof(MachineKey)' "Protect"' ignoreCase: false' throwOnBindFailure: false);  	ProtectUnprotect unprotectThunk = (ProtectUnprotect)Delegate.CreateDelegate (typeof(ProtectUnprotect)' typeof(MachineKey)' "Unprotect"' ignoreCase: false' throwOnBindFailure: false);  	if (protectThunk != null && unprotectThunk != null) {  		return new MachineKey45 (protectThunk' unprotectThunk);  		// ASP.NET 4.5  	}  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: lock (initializationSync) {  	if (!broken && !initialized) {  		try {  			file = GetIsolatedStorage ();  			reportOriginIdentity = GetOrCreateOriginIdentity ();  			observations.Add (observedRequests = new PersistentHashSet (file' "requests.txt"' 3));  			observations.Add (observedCultures = new PersistentHashSet (file' "cultures.txt"' 20));  			observations.Add (observedFeatures = new PersistentHashSet (file' "features.txt"' int.MaxValue));  			// Record site-wide features in use.  			if (HttpContext.Current != null && HttpContext.Current.ApplicationInstance != null) {  				// MVC or web forms?  				// front-end or back end web farm?  				// url rewriting?  				////RecordFeatureUse(IsMVC ? "ASP.NET MVC" : "ASP.NET Web Forms");  			}  			initialized = true;  		} catch (Exception e) {  			// This is supposed to be as low-risk as possible' so if it fails' just disable reporting  			// and avoid rethrowing.  			broken = true;  			Logger.Library.ErrorException ("Error while trying to initialize reporting."' e);  		}  	}  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: lock (initializationSync) {  	if (!broken && !initialized) {  		try {  			file = GetIsolatedStorage ();  			reportOriginIdentity = GetOrCreateOriginIdentity ();  			observations.Add (observedRequests = new PersistentHashSet (file' "requests.txt"' 3));  			observations.Add (observedCultures = new PersistentHashSet (file' "cultures.txt"' 20));  			observations.Add (observedFeatures = new PersistentHashSet (file' "features.txt"' int.MaxValue));  			// Record site-wide features in use.  			if (HttpContext.Current != null && HttpContext.Current.ApplicationInstance != null) {  				// MVC or web forms?  				// front-end or back end web farm?  				// url rewriting?  				////RecordFeatureUse(IsMVC ? "ASP.NET MVC" : "ASP.NET Web Forms");  			}  			initialized = true;  		} catch (Exception e) {  			// This is supposed to be as low-risk as possible' so if it fails' just disable reporting  			// and avoid rethrowing.  			broken = true;  			Logger.Library.ErrorException ("Error while trying to initialize reporting."' e);  		}  	}  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: if (!broken && !initialized) {  	try {  		file = GetIsolatedStorage ();  		reportOriginIdentity = GetOrCreateOriginIdentity ();  		observations.Add (observedRequests = new PersistentHashSet (file' "requests.txt"' 3));  		observations.Add (observedCultures = new PersistentHashSet (file' "cultures.txt"' 20));  		observations.Add (observedFeatures = new PersistentHashSet (file' "features.txt"' int.MaxValue));  		// Record site-wide features in use.  		if (HttpContext.Current != null && HttpContext.Current.ApplicationInstance != null) {  			// MVC or web forms?  			// front-end or back end web farm?  			// url rewriting?  			////RecordFeatureUse(IsMVC ? "ASP.NET MVC" : "ASP.NET Web Forms");  		}  		initialized = true;  	} catch (Exception e) {  		// This is supposed to be as low-risk as possible' so if it fails' just disable reporting  		// and avoid rethrowing.  		broken = true;  		Logger.Library.ErrorException ("Error while trying to initialize reporting."' e);  	}  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: if (!broken && !initialized) {  	try {  		file = GetIsolatedStorage ();  		reportOriginIdentity = GetOrCreateOriginIdentity ();  		observations.Add (observedRequests = new PersistentHashSet (file' "requests.txt"' 3));  		observations.Add (observedCultures = new PersistentHashSet (file' "cultures.txt"' 20));  		observations.Add (observedFeatures = new PersistentHashSet (file' "features.txt"' int.MaxValue));  		// Record site-wide features in use.  		if (HttpContext.Current != null && HttpContext.Current.ApplicationInstance != null) {  			// MVC or web forms?  			// front-end or back end web farm?  			// url rewriting?  			////RecordFeatureUse(IsMVC ? "ASP.NET MVC" : "ASP.NET Web Forms");  		}  		initialized = true;  	} catch (Exception e) {  		// This is supposed to be as low-risk as possible' so if it fails' just disable reporting  		// and avoid rethrowing.  		broken = true;  		Logger.Library.ErrorException ("Error while trying to initialize reporting."' e);  	}  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: try {  	file = GetIsolatedStorage ();  	reportOriginIdentity = GetOrCreateOriginIdentity ();  	observations.Add (observedRequests = new PersistentHashSet (file' "requests.txt"' 3));  	observations.Add (observedCultures = new PersistentHashSet (file' "cultures.txt"' 20));  	observations.Add (observedFeatures = new PersistentHashSet (file' "features.txt"' int.MaxValue));  	// Record site-wide features in use.  	if (HttpContext.Current != null && HttpContext.Current.ApplicationInstance != null) {  		// MVC or web forms?  		// front-end or back end web farm?  		// url rewriting?  		////RecordFeatureUse(IsMVC ? "ASP.NET MVC" : "ASP.NET Web Forms");  	}  	initialized = true;  } catch (Exception e) {  	// This is supposed to be as low-risk as possible' so if it fails' just disable reporting  	// and avoid rethrowing.  	broken = true;  	Logger.Library.ErrorException ("Error while trying to initialize reporting."' e);  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: try {  	file = GetIsolatedStorage ();  	reportOriginIdentity = GetOrCreateOriginIdentity ();  	observations.Add (observedRequests = new PersistentHashSet (file' "requests.txt"' 3));  	observations.Add (observedCultures = new PersistentHashSet (file' "cultures.txt"' 20));  	observations.Add (observedFeatures = new PersistentHashSet (file' "features.txt"' int.MaxValue));  	// Record site-wide features in use.  	if (HttpContext.Current != null && HttpContext.Current.ApplicationInstance != null) {  		// MVC or web forms?  		// front-end or back end web farm?  		// url rewriting?  		////RecordFeatureUse(IsMVC ? "ASP.NET MVC" : "ASP.NET Web Forms");  	}  	initialized = true;  } catch (Exception e) {  	// This is supposed to be as low-risk as possible' so if it fails' just disable reporting  	// and avoid rethrowing.  	broken = true;  	Logger.Library.ErrorException ("Error while trying to initialize reporting."' e);  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: observations.Add (observedRequests = new PersistentHashSet (file' "requests.txt"' 3));  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,Initialize,The following statement contains a magic number: observations.Add (observedCultures = new PersistentHashSet (file' "cultures.txt"' 20));  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,DemuxLogMessage,The following statement contains a magic number: if (line != null) {  	string[] parts = line.Split (new char[] {  		' '  	}' 2);  	if (parts.Length == 2) {  		string level = parts [0];  		string message = parts [1];  		switch (level) {  		case "INFO":  			Logger.Library.Info (message);  			break;  		case "WARN":  			Logger.Library.Warn (message);  			break;  		case "ERROR":  			Logger.Library.Error (message);  			break;  		case "FATAL":  			Logger.Library.Fatal (message);  			break;  		}  	}  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,DemuxLogMessage,The following statement contains a magic number: if (line != null) {  	string[] parts = line.Split (new char[] {  		' '  	}' 2);  	if (parts.Length == 2) {  		string level = parts [0];  		string message = parts [1];  		switch (level) {  		case "INFO":  			Logger.Library.Info (message);  			break;  		case "WARN":  			Logger.Library.Warn (message);  			break;  		case "ERROR":  			Logger.Library.Error (message);  			break;  		case "FATAL":  			Logger.Library.Fatal (message);  			break;  		}  	}  }  
Magic Number,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,DemuxLogMessage,The following statement contains a magic number: if (parts.Length == 2) {  	string level = parts [0];  	string message = parts [1];  	switch (level) {  	case "INFO":  		Logger.Library.Info (message);  		break;  	case "WARN":  		Logger.Library.Warn (message);  		break;  	case "ERROR":  		Logger.Library.Error (message);  		break;  	case "FATAL":  		Logger.Library.Fatal (message);  		break;  	}  }  
Magic Number,DotNetOpenAuth,UriUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\UriUtil.cs,ToStringWithImpliedPorts,The following statement contains a magic number: if ((builder.Port == 80 && string.Equals (builder.Scheme' "http"' StringComparison.OrdinalIgnoreCase)) || (builder.Port == 443 && string.Equals (builder.Scheme' "https"' StringComparison.OrdinalIgnoreCase))) {  	// An implied port may be removed.  	string url = builder.ToString ();  	// Be really careful to only remove the first :80 or :443 so we are guaranteed  	// we're removing only the port (and not something in the query string that   	// looks like a port.  	string result = Regex.Replace (url' @"^(https?://[^:]+):\d+"' m => m.Groups [1].Value' RegexOptions.IgnoreCase);  	Assumes.True (result != null);  	// Regex.Replace never returns null  	return result;  } else {  	// The port must be explicitly given anyway.  	return builder.ToString ();  }  
Magic Number,DotNetOpenAuth,UriUtil,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\UriUtil.cs,ToStringWithImpliedPorts,The following statement contains a magic number: if ((builder.Port == 80 && string.Equals (builder.Scheme' "http"' StringComparison.OrdinalIgnoreCase)) || (builder.Port == 443 && string.Equals (builder.Scheme' "https"' StringComparison.OrdinalIgnoreCase))) {  	// An implied port may be removed.  	string url = builder.ToString ();  	// Be really careful to only remove the first :80 or :443 so we are guaranteed  	// we're removing only the port (and not something in the query string that   	// looks like a port.  	string result = Regex.Replace (url' @"^(https?://[^:]+):\d+"' m => m.Groups [1].Value' RegexOptions.IgnoreCase);  	Assumes.True (result != null);  	// Regex.Replace never returns null  	return result;  } else {  	// The port must be explicitly given anyway.  	return builder.ToString ();  }  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: return new DelayedToString<IEnumerable<KeyValuePair<K' V>>> (pairs' p => {  	Requires.NotNull (pairs' "pairs");  	var dictionary = pairs as IDictionary<K' V>;  	var messageDictionary = pairs as MessageDictionary;  	StringBuilder sb = new StringBuilder (dictionary != null ? dictionary.Count * 40 : 200);  	foreach (var pair in pairs) {  		var key = pair.Key.ToString ();  		string value = pair.Value.ToString ();  		if (messageDictionary != null && messageDictionary.Description.Mapping.ContainsKey (key) && messageDictionary.Description.Mapping [key].IsSecuritySensitive) {  			value = "********";  		}  		sb.AppendFormat ("\t{0}: {1}{2}"' key' value' Environment.NewLine);  	}  	return sb.ToString ();  });  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: return new DelayedToString<IEnumerable<KeyValuePair<K' V>>> (pairs' p => {  	Requires.NotNull (pairs' "pairs");  	var dictionary = pairs as IDictionary<K' V>;  	var messageDictionary = pairs as MessageDictionary;  	StringBuilder sb = new StringBuilder (dictionary != null ? dictionary.Count * 40 : 200);  	foreach (var pair in pairs) {  		var key = pair.Key.ToString ();  		string value = pair.Value.ToString ();  		if (messageDictionary != null && messageDictionary.Description.Mapping.ContainsKey (key) && messageDictionary.Description.Mapping [key].IsSecuritySensitive) {  			value = "********";  		}  		sb.AppendFormat ("\t{0}: {1}{2}"' key' value' Environment.NewLine);  	}  	return sb.ToString ();  });  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: return new DelayedToString<IEnumerable<T>> (list' l => {  	// Code contracts not allowed in generator methods.  	ErrorUtilities.VerifyArgumentNotNull (l' "l");  	string newLine = Environment.NewLine;  	////Assumes.True(newLine != null && newLine.Length > 0);  	StringBuilder sb = new StringBuilder ();  	if (multiLineElements) {  		sb.AppendLine ("[{");  		foreach (T obj in l) {  			// Prepare the string repersentation of the object  			string objString = obj != null ? obj.ToString () : "<NULL>";  			// Indent every line printed  			objString = objString.Replace (newLine' Environment.NewLine + "\t");  			sb.Append ("\t");  			sb.Append (objString);  			if (!objString.EndsWith (Environment.NewLine' StringComparison.Ordinal)) {  				sb.AppendLine ();  			}  			sb.AppendLine ("}' {");  		}  		if (sb.Length > 2 + Environment.NewLine.Length) {  			// if anything was in the enumeration  			sb.Length -= 2 + Environment.NewLine.Length;  			// trim off the last "' {\r\n"  		} else {  			sb.Length -= 1 + Environment.NewLine.Length;  			// trim off the opening {  		}  		sb.Append ("]");  		return sb.ToString ();  	} else {  		sb.Append ("{");  		foreach (T obj in l) {  			sb.Append (obj != null ? obj.ToString () : "<NULL>");  			sb.AppendLine ("'");  		}  		if (sb.Length > 1) {  			sb.Length -= 1;  		}  		sb.Append ("}");  		return sb.ToString ();  	}  });  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: return new DelayedToString<IEnumerable<T>> (list' l => {  	// Code contracts not allowed in generator methods.  	ErrorUtilities.VerifyArgumentNotNull (l' "l");  	string newLine = Environment.NewLine;  	////Assumes.True(newLine != null && newLine.Length > 0);  	StringBuilder sb = new StringBuilder ();  	if (multiLineElements) {  		sb.AppendLine ("[{");  		foreach (T obj in l) {  			// Prepare the string repersentation of the object  			string objString = obj != null ? obj.ToString () : "<NULL>";  			// Indent every line printed  			objString = objString.Replace (newLine' Environment.NewLine + "\t");  			sb.Append ("\t");  			sb.Append (objString);  			if (!objString.EndsWith (Environment.NewLine' StringComparison.Ordinal)) {  				sb.AppendLine ();  			}  			sb.AppendLine ("}' {");  		}  		if (sb.Length > 2 + Environment.NewLine.Length) {  			// if anything was in the enumeration  			sb.Length -= 2 + Environment.NewLine.Length;  			// trim off the last "' {\r\n"  		} else {  			sb.Length -= 1 + Environment.NewLine.Length;  			// trim off the opening {  		}  		sb.Append ("]");  		return sb.ToString ();  	} else {  		sb.Append ("{");  		foreach (T obj in l) {  			sb.Append (obj != null ? obj.ToString () : "<NULL>");  			sb.AppendLine ("'");  		}  		if (sb.Length > 1) {  			sb.Length -= 1;  		}  		sb.Append ("}");  		return sb.ToString ();  	}  });  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: if (multiLineElements) {  	sb.AppendLine ("[{");  	foreach (T obj in l) {  		// Prepare the string repersentation of the object  		string objString = obj != null ? obj.ToString () : "<NULL>";  		// Indent every line printed  		objString = objString.Replace (newLine' Environment.NewLine + "\t");  		sb.Append ("\t");  		sb.Append (objString);  		if (!objString.EndsWith (Environment.NewLine' StringComparison.Ordinal)) {  			sb.AppendLine ();  		}  		sb.AppendLine ("}' {");  	}  	if (sb.Length > 2 + Environment.NewLine.Length) {  		// if anything was in the enumeration  		sb.Length -= 2 + Environment.NewLine.Length;  		// trim off the last "' {\r\n"  	} else {  		sb.Length -= 1 + Environment.NewLine.Length;  		// trim off the opening {  	}  	sb.Append ("]");  	return sb.ToString ();  } else {  	sb.Append ("{");  	foreach (T obj in l) {  		sb.Append (obj != null ? obj.ToString () : "<NULL>");  		sb.AppendLine ("'");  	}  	if (sb.Length > 1) {  		sb.Length -= 1;  	}  	sb.Append ("}");  	return sb.ToString ();  }  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: if (multiLineElements) {  	sb.AppendLine ("[{");  	foreach (T obj in l) {  		// Prepare the string repersentation of the object  		string objString = obj != null ? obj.ToString () : "<NULL>";  		// Indent every line printed  		objString = objString.Replace (newLine' Environment.NewLine + "\t");  		sb.Append ("\t");  		sb.Append (objString);  		if (!objString.EndsWith (Environment.NewLine' StringComparison.Ordinal)) {  			sb.AppendLine ();  		}  		sb.AppendLine ("}' {");  	}  	if (sb.Length > 2 + Environment.NewLine.Length) {  		// if anything was in the enumeration  		sb.Length -= 2 + Environment.NewLine.Length;  		// trim off the last "' {\r\n"  	} else {  		sb.Length -= 1 + Environment.NewLine.Length;  		// trim off the opening {  	}  	sb.Append ("]");  	return sb.ToString ();  } else {  	sb.Append ("{");  	foreach (T obj in l) {  		sb.Append (obj != null ? obj.ToString () : "<NULL>");  		sb.AppendLine ("'");  	}  	if (sb.Length > 1) {  		sb.Length -= 1;  	}  	sb.Append ("}");  	return sb.ToString ();  }  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: if (sb.Length > 2 + Environment.NewLine.Length) {  	// if anything was in the enumeration  	sb.Length -= 2 + Environment.NewLine.Length;  	// trim off the last "' {\r\n"  } else {  	sb.Length -= 1 + Environment.NewLine.Length;  	// trim off the opening {  }  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: if (sb.Length > 2 + Environment.NewLine.Length) {  	// if anything was in the enumeration  	sb.Length -= 2 + Environment.NewLine.Length;  	// trim off the last "' {\r\n"  } else {  	sb.Length -= 1 + Environment.NewLine.Length;  	// trim off the opening {  }  
Magic Number,DotNetOpenAuth,Util,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Util.cs,ToStringDeferred,The following statement contains a magic number: sb.Length -= 2 + Environment.NewLine.Length;  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: if (this.signed) {  	using (var dataStream = new MemoryStream (data)) {  		var dataReader = new BinaryReader (dataStream);  		signature = dataReader.ReadBuffer (1024);  		data = dataReader.ReadBuffer (8 * 1024);  	}  	// Verify that the verification code was issued by message authorization server.  	ErrorUtilities.VerifyProtocol (this.IsSignatureValid (data' signature' symmetricSecretHandle)' MessagingStrings.SignatureInvalid);  }  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: if (this.signed) {  	using (var dataStream = new MemoryStream (data)) {  		var dataReader = new BinaryReader (dataStream);  		signature = dataReader.ReadBuffer (1024);  		data = dataReader.ReadBuffer (8 * 1024);  	}  	// Verify that the verification code was issued by message authorization server.  	ErrorUtilities.VerifyProtocol (this.IsSignatureValid (data' signature' symmetricSecretHandle)' MessagingStrings.SignatureInvalid);  }  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: if (this.signed) {  	using (var dataStream = new MemoryStream (data)) {  		var dataReader = new BinaryReader (dataStream);  		signature = dataReader.ReadBuffer (1024);  		data = dataReader.ReadBuffer (8 * 1024);  	}  	// Verify that the verification code was issued by message authorization server.  	ErrorUtilities.VerifyProtocol (this.IsSignatureValid (data' signature' symmetricSecretHandle)' MessagingStrings.SignatureInvalid);  }  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: using (var dataStream = new MemoryStream (data)) {  	var dataReader = new BinaryReader (dataStream);  	signature = dataReader.ReadBuffer (1024);  	data = dataReader.ReadBuffer (8 * 1024);  }  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: using (var dataStream = new MemoryStream (data)) {  	var dataReader = new BinaryReader (dataStream);  	signature = dataReader.ReadBuffer (1024);  	data = dataReader.ReadBuffer (8 * 1024);  }  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: using (var dataStream = new MemoryStream (data)) {  	var dataReader = new BinaryReader (dataStream);  	signature = dataReader.ReadBuffer (1024);  	data = dataReader.ReadBuffer (8 * 1024);  }  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: signature = dataReader.ReadBuffer (1024);  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: data = dataReader.ReadBuffer (8 * 1024);  
Magic Number,DotNetOpenAuth.Messaging,DataBagFormatterBase,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\DataBagFormatterBase.cs,Deserialize,The following statement contains a magic number: data = dataReader.ReadBuffer (8 * 1024);  
Magic Number,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,The following statement contains a magic number: foreach (MessageDescription messageDescription in messageTypes) {  	bool supportedMessageType = false;  	// First see whether this message fits the recognized pattern for request messages.  	if (typeof(IDirectedProtocolMessage).IsAssignableFrom (messageDescription.MessageType)) {  		foreach (ConstructorInfo ctor in messageDescription.Constructors) {  			ParameterInfo[] parameters = ctor.GetParameters ();  			if (parameters.Length == 2 && parameters [0].ParameterType == typeof(Uri) && parameters [1].ParameterType == typeof(Version)) {  				supportedMessageType = true;  				this.requestMessageTypes.Add (messageDescription' ctor);  				break;  			}  		}  	}  	// Also see if this message fits the recognized pattern for response messages.  	if (typeof(IDirectResponseProtocolMessage).IsAssignableFrom (messageDescription.MessageType)) {  		var responseCtors = new Dictionary<Type' ConstructorInfo> (messageDescription.Constructors.Length);  		foreach (ConstructorInfo ctor in messageDescription.Constructors) {  			ParameterInfo[] parameters = ctor.GetParameters ();  			if (parameters.Length == 1 && typeof(IDirectedProtocolMessage).IsAssignableFrom (parameters [0].ParameterType)) {  				responseCtors.Add (parameters [0].ParameterType' ctor);  			}  		}  		if (responseCtors.Count > 0) {  			supportedMessageType = true;  			this.responseMessageTypes.Add (messageDescription' responseCtors);  		}  	}  	if (!supportedMessageType) {  		unsupportedMessageTypes.Add (messageDescription);  	}  }  
Magic Number,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,The following statement contains a magic number: if (typeof(IDirectedProtocolMessage).IsAssignableFrom (messageDescription.MessageType)) {  	foreach (ConstructorInfo ctor in messageDescription.Constructors) {  		ParameterInfo[] parameters = ctor.GetParameters ();  		if (parameters.Length == 2 && parameters [0].ParameterType == typeof(Uri) && parameters [1].ParameterType == typeof(Version)) {  			supportedMessageType = true;  			this.requestMessageTypes.Add (messageDescription' ctor);  			break;  		}  	}  }  
Magic Number,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,The following statement contains a magic number: foreach (ConstructorInfo ctor in messageDescription.Constructors) {  	ParameterInfo[] parameters = ctor.GetParameters ();  	if (parameters.Length == 2 && parameters [0].ParameterType == typeof(Uri) && parameters [1].ParameterType == typeof(Version)) {  		supportedMessageType = true;  		this.requestMessageTypes.Add (messageDescription' ctor);  		break;  	}  }  
Magic Number,DotNetOpenAuth.Messaging,StandardMessageFactory,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\StandardMessageFactory.cs,AddMessageTypes,The following statement contains a magic number: if (parameters.Length == 2 && parameters [0].ParameterType == typeof(Uri) && parameters [1].ParameterType == typeof(Version)) {  	supportedMessageType = true;  	this.requestMessageTypes.Add (messageDescription' ctor);  	break;  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,CreateUntrustedXmlReaderSettings,The following statement contains a magic number: return new XmlReaderSettings {  	MaxCharactersFromEntities = 1024'  	XmlResolver = null'  	DtdProcessing = DtdProcessing.Prohibit'  };  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ParseAuthorizationHeader,The following statement contains a magic number: if (authorizationHeader != null && authorizationHeader.Scheme.Equals (scheme' StringComparison.OrdinalIgnoreCase)) {  	// RFC 2617 says this is case INsensitive  	return from element in authorizationHeader.Parameter.Split (CommaArray)  	let parts = element.Trim ().Split (EqualsArray' 2)  	let key = Uri.UnescapeDataString (parts [0])  	let value = Uri.UnescapeDataString (parts [1].Trim (QuoteArray))  	select new KeyValuePair<string' string> (key' value);  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ParseAuthorizationHeader,The following statement contains a magic number: return from element in authorizationHeader.Parameter.Split (CommaArray)  let parts = element.Trim ().Split (EqualsArray' 2)  let key = Uri.UnescapeDataString (parts [0])  let value = Uri.UnescapeDataString (parts [1].Trim (QuoteArray))  select new KeyValuePair<string' string> (key' value);  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetRandomString,The following statement contains a magic number: Requires.That (allowableCharacters != null && allowableCharacters.Length >= 2' "allowableCharacters"' "At least two allowable characters required.");  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,DecryptWithRandomSymmetricKey,The following statement contains a magic number: using (var encryptedStream = new MemoryStream (buffer)) {  	var encryptedStreamReader = new BinaryReader (encryptedStream);  	byte[] encryptedPrequel = encryptedStreamReader.ReadBuffer (4096);  	byte[] prequel = crypto.Decrypt (encryptedPrequel' false);  	using (var symmetricCrypto = SymmetricAlgorithm.Create ()) {  		symmetricCrypto.Mode = CipherMode.CBC;  		byte[] symmetricKey = new byte[symmetricCrypto.Key.Length];  		byte[] symmetricIV = new byte[symmetricCrypto.IV.Length];  		Array.Copy (prequel' symmetricKey' symmetricKey.Length);  		Array.Copy (prequel' symmetricKey.Length' symmetricIV' 0' symmetricIV.Length);  		symmetricCrypto.Key = symmetricKey;  		symmetricCrypto.IV = symmetricIV;  		// Allocate space for the decrypted buffer.  We don't know how long it will be yet'  		// but it will never be larger than the encrypted buffer.  		var decryptedBuffer = new byte[encryptedStream.Length - encryptedStream.Position];  		int actualDecryptedLength;  		using (var cryptoStream = new CryptoStream (encryptedStream' symmetricCrypto.CreateDecryptor ()' CryptoStreamMode.Read)) {  			actualDecryptedLength = cryptoStream.Read (decryptedBuffer' 0' decryptedBuffer.Length);  		}  		// Create a new buffer with only the decrypted data.  		var finalDecryptedBuffer = new byte[actualDecryptedLength];  		Array.Copy (decryptedBuffer' finalDecryptedBuffer' actualDecryptedLength);  		return finalDecryptedBuffer;  	}  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: Requires.That (keySize % 8 == 0' "keySize"' "Key size must be a multiple of 8.");  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: if (cryptoKeyPair.Value == null || cryptoKeyPair.Value.ExpiresUtc < DateTime.UtcNow + minimumRemainingLife) {  	// No key exists with enough remaining life for the required purpose.  Create a new key.  	if (cryptoKeyPair.Value == null) {  		Logger.Messaging.InfoFormat ("{0}.GetKeys returned no keys for bucket \"{1}\" with the required key length of {2} bits.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize);  	} else {  		Logger.Messaging.InfoFormat ("The first key returned by {0}.GetKeys for bucket \"{1}\" with the required key length of {2} bits was too near expiry to use.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize);  	}  	ErrorUtilities.VerifyHost (minimumRemainingLife <= SymmetricSecretKeyLifespan' "Unable to create a new symmetric key with the required lifespan of {0} because it is beyond the limit of {1}."' minimumRemainingLife' SymmetricSecretKeyLifespan);  	byte[] secret = GetCryptoRandomData (keySize / 8);  	DateTime expires = DateTime.UtcNow + SymmetricSecretKeyLifespan;  	var cryptoKey = new CryptoKey (secret' expires);  	// Store this key so we can find and use it later.  	int failedAttempts = 0;  	tryAgain:  	try {  		string handle = GetRandomString (SymmetricSecretHandleLength' Base64WebSafeCharacters);  		cryptoKeyPair = new KeyValuePair<string' CryptoKey> (handle' cryptoKey);  		cryptoKeyStore.StoreKey (bucket' handle' cryptoKey);  	} catch (CryptoKeyCollisionException) {  		ErrorUtilities.VerifyInternal (++failedAttempts < 3' "Unable to derive a unique handle to a private symmetric key.");  		Logger.Messaging.Warn ("A randomly generated crypto key handle collided with an existing handle.  Another randomly generated handle will be attempted till the retry count is met.");  		goto tryAgain;  	}  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: if (cryptoKeyPair.Value == null || cryptoKeyPair.Value.ExpiresUtc < DateTime.UtcNow + minimumRemainingLife) {  	// No key exists with enough remaining life for the required purpose.  Create a new key.  	if (cryptoKeyPair.Value == null) {  		Logger.Messaging.InfoFormat ("{0}.GetKeys returned no keys for bucket \"{1}\" with the required key length of {2} bits.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize);  	} else {  		Logger.Messaging.InfoFormat ("The first key returned by {0}.GetKeys for bucket \"{1}\" with the required key length of {2} bits was too near expiry to use.  A new key will be created"' typeof(ICryptoKeyStore)' bucket' keySize);  	}  	ErrorUtilities.VerifyHost (minimumRemainingLife <= SymmetricSecretKeyLifespan' "Unable to create a new symmetric key with the required lifespan of {0} because it is beyond the limit of {1}."' minimumRemainingLife' SymmetricSecretKeyLifespan);  	byte[] secret = GetCryptoRandomData (keySize / 8);  	DateTime expires = DateTime.UtcNow + SymmetricSecretKeyLifespan;  	var cryptoKey = new CryptoKey (secret' expires);  	// Store this key so we can find and use it later.  	int failedAttempts = 0;  	tryAgain:  	try {  		string handle = GetRandomString (SymmetricSecretHandleLength' Base64WebSafeCharacters);  		cryptoKeyPair = new KeyValuePair<string' CryptoKey> (handle' cryptoKey);  		cryptoKeyStore.StoreKey (bucket' handle' cryptoKey);  	} catch (CryptoKeyCollisionException) {  		ErrorUtilities.VerifyInternal (++failedAttempts < 3' "Unable to derive a unique handle to a private symmetric key.");  		Logger.Messaging.Warn ("A randomly generated crypto key handle collided with an existing handle.  Another randomly generated handle will be attempted till the retry count is met.");  		goto tryAgain;  	}  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: try {  	string handle = GetRandomString (SymmetricSecretHandleLength' Base64WebSafeCharacters);  	cryptoKeyPair = new KeyValuePair<string' CryptoKey> (handle' cryptoKey);  	cryptoKeyStore.StoreKey (bucket' handle' cryptoKey);  } catch (CryptoKeyCollisionException) {  	ErrorUtilities.VerifyInternal (++failedAttempts < 3' "Unable to derive a unique handle to a private symmetric key.");  	Logger.Messaging.Warn ("A randomly generated crypto key handle collided with an existing handle.  Another randomly generated handle will be attempted till the retry count is met.");  	goto tryAgain;  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,GetCurrentKey,The following statement contains a magic number: ErrorUtilities.VerifyInternal (++failedAttempts < 3' "Unable to derive a unique handle to a private symmetric key.");  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: switch (base64WebSafe.Length % 4) {  case 3:  	missingPaddingCharacters = 1;  	break;  case 2:  	missingPaddingCharacters = 2;  	break;  case 0:  	missingPaddingCharacters = 0;  	break;  default:  	throw new ProtocolException (MessagingStrings.DataCorruptionDetected' new ArgumentException ("No more than two padding characters should be present for base64."));  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: switch (base64WebSafe.Length % 4) {  case 3:  	missingPaddingCharacters = 1;  	break;  case 2:  	missingPaddingCharacters = 2;  	break;  case 0:  	missingPaddingCharacters = 0;  	break;  default:  	throw new ProtocolException (MessagingStrings.DataCorruptionDetected' new ArgumentException ("No more than two padding characters should be present for base64."));  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: switch (base64WebSafe.Length % 4) {  case 3:  	missingPaddingCharacters = 1;  	break;  case 2:  	missingPaddingCharacters = 2;  	break;  case 0:  	missingPaddingCharacters = 0;  	break;  default:  	throw new ProtocolException (MessagingStrings.DataCorruptionDetected' new ArgumentException ("No more than two padding characters should be present for base64."));  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: switch (base64WebSafe.Length % 4) {  case 3:  	missingPaddingCharacters = 1;  	break;  case 2:  	missingPaddingCharacters = 2;  	break;  case 0:  	missingPaddingCharacters = 0;  	break;  default:  	throw new ProtocolException (MessagingStrings.DataCorruptionDetected' new ArgumentException ("No more than two padding characters should be present for base64."));  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,FromBase64WebSafeString,The following statement contains a magic number: missingPaddingCharacters = 2;  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,CopyUpTo,The following statement contains a magic number: while ((readBytes = copyFrom.Read (buffer' 0' Math.Min (1024' maximumBytesToCopy))) > 0) {  	int writeBytes = Math.Min (maximumBytesToCopy' readBytes);  	copyTo.Write (buffer' 0' writeBytes);  	totalCopiedBytes += writeBytes;  	maximumBytesToCopy -= writeBytes;  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AppendQueryArgs,The following statement contains a magic number: if (args != null && args.Count () > 0) {  	StringBuilder sb = new StringBuilder (50 + (args.Count () * 10));  	if (!string.IsNullOrEmpty (builder.Query)) {  		sb.Append (builder.Query.Substring (1));  		sb.Append ('&');  	}  	sb.Append (CreateQueryString (args));  	builder.Query = sb.ToString ();  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AppendQueryArgs,The following statement contains a magic number: if (args != null && args.Count () > 0) {  	StringBuilder sb = new StringBuilder (50 + (args.Count () * 10));  	if (!string.IsNullOrEmpty (builder.Query)) {  		sb.Append (builder.Query.Substring (1));  		sb.Append ('&');  	}  	sb.Append (CreateQueryString (args));  	builder.Query = sb.ToString ();  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AppendFragmentArgs,The following statement contains a magic number: if (args != null && args.Count () > 0) {  	StringBuilder sb = new StringBuilder (50 + (args.Count () * 10));  	if (!string.IsNullOrEmpty (builder.Fragment)) {  		sb.Append (builder.Fragment);  		sb.Append ('&');  	}  	sb.Append (CreateQueryString (args));  	builder.Fragment = sb.ToString ();  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,AppendFragmentArgs,The following statement contains a magic number: if (args != null && args.Count () > 0) {  	StringBuilder sb = new StringBuilder (50 + (args.Count () * 10));  	if (!string.IsNullOrEmpty (builder.Fragment)) {  		sb.Append (builder.Fragment);  		sb.Append ('&');  	}  	sb.Append (CreateQueryString (args));  	builder.Fragment = sb.ToString ();  }  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ReadBuffer,The following statement contains a magic number: Requires.Range (maxBufferSize > 0 && maxBufferSize < 1024 * 1024' "maxBufferSize");  
Magic Number,DotNetOpenAuth.Messaging,MessagingUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\MessagingUtilities.cs,ReadBuffer,The following statement contains a magic number: Requires.Range (maxBufferSize > 0 && maxBufferSize < 1024 * 1024' "maxBufferSize");  
Magic Number,DotNetOpenAuth.Messaging.Bindings,HardCodedKeyCryptoKeyStore,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\HardCodedKeyCryptoKeyStore.cs,HardCodedKeyCryptoKeyStore,The following statement contains a magic number: this.OneCryptoKey = new CryptoKey (secret' DateTime.MaxValue.AddDays (-2).ToUniversalTime ());  
Magic Number,DotNetOpenAuth.Messaging.Bindings,MemoryNonceStore,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\MemoryNonceStore.cs,StoreNonce,The following statement contains a magic number: lock (this.nonceLock) {  	List<string> nonces;  	if (!this.usedNonces.TryGetValue (timestamp' out nonces)) {  		this.usedNonces [timestamp] = nonces = new List<string> (4);  	}  	if (nonces.Contains (completeNonce)) {  		return false;  	}  	nonces.Add (completeNonce);  	// Clear expired nonces if it's time to take a moment to do that.  	// Unchecked so that this can int overflow without an exception.  	unchecked {  		this.nonceClearingCounter++;  	}  	if (this.nonceClearingCounter % AutoCleaningFrequency == 0) {  		this.ClearExpiredNonces ();  	}  	return true;  }  
Magic Number,DotNetOpenAuth.Messaging.Bindings,MemoryNonceStore,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\MemoryNonceStore.cs,StoreNonce,The following statement contains a magic number: if (!this.usedNonces.TryGetValue (timestamp' out nonces)) {  	this.usedNonces [timestamp] = nonces = new List<string> (4);  }  
Magic Number,DotNetOpenAuth.Messaging.Bindings,MemoryNonceStore,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Bindings\MemoryNonceStore.cs,StoreNonce,The following statement contains a magic number: this.usedNonces [timestamp] = nonces = new List<string> (4);  
Magic Number,DotNetOpenAuth.Messaging.Reflection,MessagePart,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Messaging\Reflection\MessagePart.cs,GetDefaultEncoder,The following statement contains a magic number: ErrorUtilities.VerifyInternal (converterAttributes.Length < 2' "Too many attributes applied.");  
Missing Default,DotNetOpenAuth,Reporting,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.Core\Reporting.cs,DemuxLogMessage,The following switch statement is missing a default case: switch (level) {  case "INFO":  	Logger.Library.Info (message);  	break;  case "WARN":  	Logger.Library.Warn (message);  	break;  case "ERROR":  	Logger.Library.Error (message);  	break;  case "FATAL":  	Logger.Library.Fatal (message);  	break;  }  
