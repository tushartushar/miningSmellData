Implementation smell,Namespace,Class,File,Method,Description
Long Method,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The method has 248 lines of code.
Complex Method,Microsoft.Ddue.Tools,ExtensionMethodAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\ExtensionMethodAddIn.cs,AddExtensionMethods,Cyclomatic complexity of the method is 20
Complex Method,Microsoft.Ddue.Tools,ExtensionMethodAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\ExtensionMethodAddIn.cs,IsValidTemplateArgument,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,ExtensionMethodAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\ExtensionMethodAddIn.cs,RecordExtensionMethods,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Ddue.Tools,MemberDictionary,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MemberDictionary.cs,MemberDictionary,Cyclomatic complexity of the method is 18
Complex Method,Microsoft.Ddue.Tools,MemberDictionary,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MemberDictionary.cs,Contains,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,Cyclomatic complexity of the method is 22
Complex Method,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,GetExposedAttributes,Cyclomatic complexity of the method is 12
Complex Method,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteEventData,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteGenericParameter,Cyclomatic complexity of the method is 10
Complex Method,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WritePropertyData,Cyclomatic complexity of the method is 8
Complex Method,Microsoft.Ddue.Tools,XamlAttachedMembersAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\XamlAttachedMembersAddIn.cs,AddAttachedMembers,Cyclomatic complexity of the method is 24
Long Identifier,Microsoft.Ddue.Tools,ExtensionMethodAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\ExtensionMethodAddIn.cs,AddExtensionMethod,The length of the parameter extensionMethodTemplateReturnType is 33.
Long Identifier,Microsoft.Ddue.Tools,ExtensionMethodAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\ExtensionMethodAddIn.cs,AddExtensionMethod,The length of the parameter extensionMethodTemplateParameters is 33.
Long Statement,Microsoft.Ddue.Tools,ExtensionMethodAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\ExtensionMethodAddIn.cs,AddExtensionMethod,The length of the statement  "            Method extensionMethod = new Method(extensionMethodTemplate.DeclaringType' new AttributeList()' extensionMethodTemplate.Name' extensionMethodParameters' extensionMethodTemplate.ReturnType' null); " is 195.
Long Statement,Microsoft.Ddue.Tools,ExtensionMethodAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\ExtensionMethodAddIn.cs,AddExtensionMethods,The length of the statement  "                if (comparisonType.IsGeneric && (comparisonType.TemplateArguments != null) && (comparisonType.TemplateArguments.Count > 0)) " is 123.
Long Statement,Microsoft.Ddue.Tools,ExtensionMethodAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\ExtensionMethodAddIn.cs,RecordExtensionMethods,The length of the statement  "                        // Note: we are not interested in extended types that are specialized by a specific type rather than by the extension method's template param. " is 142.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "            options.Add(new StringOption("out"' "Specify an output file. If unspecified' output goes to the console."' "outputFilePath")); " is 126.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "            options.Add(new StringOption("config"' "Specify a configuration file. If unspecified' MRefBuilder.config is used"' "configFilePath")); " is 134.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while attempting to read the configuration file '{0}'. The error message is: {1}"' configFile' e.Message)); " is 187.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while attempting to read the configuration file '{0}'. The error message is: {1}"' configFile' e.Message)); " is 187.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The configuration file '{0}' is not well-formed. The error message is: {1}"' configFile' e.Message)); " is 164.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The specifed target platform directory '{0}' does not exist."' path)); " is 133.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' was not found in the component assembly '{1}'."' typeName' assemblyPath)); " is 152.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("A file access error occured while attempting to load the component assembly '{0}'. The error message is: {1}"' assemblyPath' e.Message)); " is 200.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("A file access error occured while attempting to load the component assembly '{0}'. The error message is: {1}"' assemblyPath' e.Message)); " is 200.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The component assembly '{0}' is not a valid managed assembly."' assemblyPath)); " is 142.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' was not found in the component assembly '{1}'."' typeName' assemblyPath)); " is 152.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("No appropriate constructor exists for the type'{0}' in the component assembly '{1}'."' typeName' assemblyPath)); " is 175.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while initializing the type '{0}' in the component assembly '{1}'. The error message and stack trace follows: {2}"' typeName' assemblyPath' e.InnerException.ToString())); " is 250.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' in the component assembly '{1}' is not a component type."' typeName' assemblyPath)); " is 162.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    resolver = (AssemblyResolver)assembly.CreateInstance(typeName' false' BindingFlags.Public | BindingFlags.Instance' null' new Object[1] { resolverNode }' null' null); " is 165.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' was not found in the component assembly '{1}'."' typeName' assemblyPath)); " is 152.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("A file access error occured while attempting to load the component assembly '{0}'. The error message is: {1}"' assemblyPath' e.Message)); " is 200.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("A file access error occured while attempting to load the component assembly '{0}'. The error message is: {1}"' assemblyPath' e.Message)); " is 200.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The component assembly '{0}' is not a valid managed assembly."' assemblyPath)); " is 142.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' was not found in the component assembly '{1}'."' typeName' assemblyPath)); " is 152.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("No appropriate constructor exists for the type'{0}' in the component assembly '{1}'."' typeName' assemblyPath)); " is 175.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while initializing the type '{0}' in the component assembly '{1}'. The error message and stack trace follows: {2}"' typeName' assemblyPath' e.InnerException.ToString())); " is 250.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' in the component assembly '{1}' is not a component type."' typeName' assemblyPath)); " is 162.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "            resolver.UnresolvedAssemblyReference += new EventHandler < AssemblyReferenceEventArgs >(UnresolvedAssemblyReferenceHandler); " is 124.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while attempting to create an output file. The error message is: {0}"' e.Message)); " is 163.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while attempting to create an output file. The error message is: {0}"' e.Message)); " is 163.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                // builder.ApiFilter = new ExternalDocumentedFilter(config.CreateNavigator().SelectSingleNode("/configuration/dduetools")); " is 123.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    builder.ApiFilter = new ExternalDocumentedFilter(config.CreateNavigator().SelectSingleNode("/configuration/dduetools")); " is 120.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        MRefBuilderAddIn addin = (MRefBuilderAddIn)assembly.CreateInstance(typeName' false' BindingFlags.Public | BindingFlags.Instance' null' new Object[2] { builder' addinNode }' null' null); " is 185.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                            ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' was not found in the addin assembly '{1}'."' typeName' assemblyPath)); " is 148.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("A file access error occured while attempting to load the addin assembly '{0}'. The error message is: {1}"' assemblyPath' e.Message)); " is 196.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The addin assembly '{0}' is not a valid managed assembly."' assemblyPath)); " is 138.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' was not found in the addin assembly '{1}'."' typeName' assemblyPath)); " is 148.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("No appropriate constructor exists for the type '{0}' in the addin assembly '{1}'."' typeName' assemblyPath)); " is 172.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while initializing the type '{0}' in the addin assembly '{1}'. The error message and stack trace follows: {2}"' typeName' assemblyPath' e.InnerException.ToString())); " is 246.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                        ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' in the addin assembly '{1}' is not an MRefBuilderAddIn type."' typeName' assemblyPath)); " is 166.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                            ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while loading dependency assemblies. The error message is: {0}"' e.Message)); " is 157.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                            ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while loading assemblies for reflection. The error message is: {0}"' e.Message)); " is 161.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Info' String.Format("Loaded {0} assemblies for reflection and {1} dependency assemblies."' builder.Assemblies.Length' builder.AccessoryAssemblies.Length)); " is 196.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The length of the statement  "                    ConsoleApplication.WriteMessage(LogLevel.Info' String.Format("Wrote information on {0} namespaces' {1} types' and {2} members"' builder.Namespaces.Length' builder.Types.Length' builder.Members.Length)); " is 202.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,AssemblyNotFound,The length of the statement  "            ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("Unresolved assembly reference: {0} ({1}) required by {2}"' reference.Name' reference.StrongName' module.Name)); " is 174.
Long Statement,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,UnresolvedAssemblyReferenceHandler,The length of the statement  "            ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("Unresolved assembly reference: {0} ({1}) required by {2}"' e.Reference.Name' e.Reference.StrongName' e.Referrer.Name)); " is 182.
Long Statement,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteTypeElements,The length of the statement  "                // if (Array.BinarySearch(assemblyNames' member.DeclaringType.DeclaringModule.ContainingAssembly.Name) < 0) write = true; " is 121.
Long Statement,Microsoft.Ddue.Tools,XamlAttachedMembersAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\XamlAttachedMembersAddIn.cs,AddAttachedMembers,The length of the statement  "                            if ((candidateGetter.NodeType == NodeType.Method) && candidateGetter.IsStatic && candidateGetter.IsVisibleOutsideAssembly) getter = (Method)candidateGetter; " is 156.
Long Statement,Microsoft.Ddue.Tools,XamlAttachedMembersAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\XamlAttachedMembersAddIn.cs,AddAttachedMembers,The length of the statement  "                            if ((candidateSetter.NodeType == NodeType.Method) && candidateSetter.IsStatic && candidateSetter.IsVisibleOutsideAssembly) setter = (Method)candidateSetter; " is 156.
Complex Conditional,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteGenericParameter,The conditional expression  "(parent != null) || (interfaces.Count > 0) || reference || value || constructor"  is complex.
Virtual Method Call from Constructor,Microsoft.Ddue.Tools,MemberDictionary,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MemberDictionary.cs,MemberDictionary,The constructor "MemberDictionary" calls a virtual method "IsExposedMember".
Virtual Method Call from Constructor,Microsoft.Ddue.Tools,MemberDictionary,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MemberDictionary.cs,MemberDictionary,The constructor "MemberDictionary" calls a virtual method "IsExposedType".
Virtual Method Call from Constructor,Microsoft.Ddue.Tools,MemberDictionary,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MemberDictionary.cs,MemberDictionary,The constructor "MemberDictionary" calls a virtual method "IsExposedMember".
Virtual Method Call from Constructor,Microsoft.Ddue.Tools,MemberDictionary,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MemberDictionary.cs,MemberDictionary,The constructor "MemberDictionary" calls a virtual method "IsExposedMember".
Magic Number,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The following statement contains a magic number: try {                  // create a builder                  ManagedReflectionWriter builder = new ManagedReflectionWriter(output' namer);                    // specify the resolver for the builder                  builder.Resolver = resolver;                    // builder.ApiFilter = new ExternalDocumentedFilter(config.CreateNavigator().SelectSingleNode("/configuration/dduetools"));                    // specify the filter for the builder                    if (results.Options["internal"].IsPresent && (bool)results.Options["internal"].Value) {                      builder.ApiFilter = new AllDocumentedFilter(config.CreateNavigator().SelectSingleNode("/configuration/dduetools"));                  } else {                      builder.ApiFilter = new ExternalDocumentedFilter(config.CreateNavigator().SelectSingleNode("/configuration/dduetools"));                  }                    // register add-ins to the builder                    XPathNodeIterator addinNodes = config.CreateNavigator().Select("/configuration/dduetools/addins/addin");                  foreach (XPathNavigator addinNode in addinNodes) {                      string assemblyPath = addinNode.GetAttribute("assembly"' String.Empty);                      string typeName = addinNode.GetAttribute("type"' String.Empty);                        assemblyPath = Environment.ExpandEnvironmentVariables(assemblyPath);                      if (!Path.IsPathRooted(assemblyPath)) assemblyPath = Path.Combine(configDirectory' assemblyPath);                        try {                            Assembly assembly = Assembly.LoadFrom(assemblyPath);                          MRefBuilderAddIn addin = (MRefBuilderAddIn)assembly.CreateInstance(typeName' false' BindingFlags.Public | BindingFlags.Instance' null' new Object[2] { builder' addinNode }' null' null);                            if (namer == null) {                              ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' was not found in the addin assembly '{1}'."' typeName' assemblyPath));                              return (1);                          }                        } catch (IOException e) {                          ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("A file access error occured while attempting to load the addin assembly '{0}'. The error message is: {1}"' assemblyPath' e.Message));                          return (1);                      } catch (BadImageFormatException) {                          ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The addin assembly '{0}' is not a valid managed assembly."' assemblyPath));                          return (1);                      } catch (TypeLoadException) {                          ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' was not found in the addin assembly '{1}'."' typeName' assemblyPath));                          return (1);                      } catch (MissingMethodException) {                          ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("No appropriate constructor exists for the type '{0}' in the addin assembly '{1}'."' typeName' assemblyPath));                          return (1);                      } catch (TargetInvocationException e) {                          ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while initializing the type '{0}' in the addin assembly '{1}'. The error message and stack trace follows: {2}"' typeName' assemblyPath' e.InnerException.ToString()));                          return (1);                      } catch (InvalidCastException) {                          ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("The type '{0}' in the addin assembly '{1}' is not an MRefBuilderAddIn type."' typeName' assemblyPath));                          return (1);                      }                    }                    try {                          // add a handler for unresolved assembly references                      //builder.UnresolvedModuleHandler = new System.Compiler.Module.AssemblyReferenceResolver(AssemblyNotFound);                        // load dependent bits                      foreach (string dependency in dependencies) {                          try {                              builder.LoadAccessoryAssemblies(dependency);                          } catch (IOException e) {                              ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while loading dependency assemblies. The error message is: {0}"' e.Message));                              return (1);                          }                      }                        // parse the bits                      foreach (string dllPath in results.UnusedArguments) {                          try {                              builder.LoadAssemblies(dllPath);                          } catch (IOException e) {                              ConsoleApplication.WriteMessage(LogLevel.Error' String.Format("An error occured while loading assemblies for reflection. The error message is: {0}"' e.Message));                              return (1);                          }                      }                        ConsoleApplication.WriteMessage(LogLevel.Info' String.Format("Loaded {0} assemblies for reflection and {1} dependency assemblies."' builder.Assemblies.Length' builder.AccessoryAssemblies.Length));                        // register callbacks                        //builder.RegisterStartTagCallback("apis"' new MRefBuilderCallback(startTestCallback));                        //MRefBuilderAddIn addin = new XamlAttachedMembersAddIn(builder' null);                        builder.VisitApis();                        ConsoleApplication.WriteMessage(LogLevel.Info' String.Format("Wrote information on {0} namespaces' {1} types' and {2} members"' builder.Namespaces.Length' builder.Types.Length' builder.Members.Length));                    } finally {                        builder.Dispose();                  }                } finally {                    // output.Close();                }
Magic Number,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteApiData,The following statement contains a magic number: if (api.NodeType == NodeType.Namespace) {                  group = "namespace";              } else if (api is TypeNode) {                  group = "type";                    TypeNode type = (TypeNode)api;                  name = type.GetUnmangledNameWithoutTypeParameters();                    switch (api.NodeType) {                      case NodeType.Class:                          subgroup = "class";                          break;                      case NodeType.Struct:                          subgroup = "structure";                          break;                      case NodeType.Interface:                          subgroup = "interface";                          break;                      case NodeType.EnumNode:                          subgroup = "enumeration";                          break;                      case NodeType.DelegateNode:                          subgroup = "delegate";                          break;                  }              } else {                  group = "member";                    switch (api.NodeType) {                      case NodeType.Field:                          subgroup = "field";                          break;                      case NodeType.Property:                          subgroup = "property";                          break;                      case NodeType.InstanceInitializer:                      case NodeType.StaticInitializer:                          subgroup = "constructor";                          // name = api.DeclaringType.GetUnmangledNameWithoutTypeParameters();                          break;                      case NodeType.Method:                          subgroup = "method";                          if ((api.IsSpecialName) && (name.StartsWith("op_"))) {                              subsubgroup = "operator";                              name = name.Substring(3);                          }                          break;                      case NodeType.Event:                          subgroup = "event";                          break;                  }                    // Name of EIIs is just interface member name                  int dotIndex = name.LastIndexOf(".");                  if (dotIndex > 0) name = name.Substring(dotIndex + 1);                }
Magic Number,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteEventData,The following statement contains a magic number: if (handler != null) {                  ParameterList parameters = handler.Parameters;                    if ((parameters != null) && (parameters.Count == 2) && (parameters[0].Type.FullName == "System.Object")) {                      writer.WriteStartElement("eventargs");                      WriteTypeReference(parameters[1].Type);                      writer.WriteEndElement();                  }              }
Magic Number,Microsoft.Ddue.Tools,XamlAttachedMembersAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\XamlAttachedMembersAddIn.cs,AddAttachedMembers,The following statement contains a magic number: foreach (Namespace space in spaces) {                  TypeNodeList types = space.Types;                  foreach (TypeNode type in types) {                        MemberList members = type.Members;                        // go through the members' looking for fields signaling attached properties                      foreach (Member member in members) {                            // we need a visible' static' field...                          if (!member.IsStatic || !member.IsVisibleOutsideAssembly || member.NodeType != NodeType.Field) continue;                          Field field = (Field)member;                            // of type dependency property....                          if (field.Type.FullName != "System.Windows.DependencyProperty") continue;                            // with a name ending in "Property"...                          string name = field.Name.Name;                          if (!name.EndsWith("Property")) continue;                          name = name.Substring(0' name.Length - 8);                            // look for a getter and/or a setter                            Method getter = null;                          MemberList candidateGetters = type.GetMembersNamed(new Identifier("Get" + name));                          for (int i = 0; i < candidateGetters.Count; i++) {                              Member candidateGetter = candidateGetters[i];                              if ((candidateGetter.NodeType == NodeType.Method) && candidateGetter.IsStatic && candidateGetter.IsVisibleOutsideAssembly) getter = (Method)candidateGetter;                          }                            Method setter = null;                          MemberList candidateSetters = type.GetMembersNamed(new Identifier("Set" + name));                          for (int i = 0; i < candidateSetters.Count; i++) {                              Member candidateSetter = candidateSetters[i];                              if ((candidateSetter.NodeType == NodeType.Method) && candidateSetter.IsStatic && candidateSetter.IsVisibleOutsideAssembly) setter = (Method)candidateSetter;                          }                            if ((getter == null) && (setter == null)) continue;                            // make sure there isn't already such a property                            Property existingProperty = type.GetProperty(new Identifier(name)' new TypeNode[0]);                          if (existingProperty != null && existingProperty.IsVisibleOutsideAssembly) continue;                            // okay' this really is an indication of an attached property' so create one                            Property attachedProperty = new Property(type' null' PropertyFlags.None' new Identifier(name)' getter' setter);                          // attached properties have no parameters                          attachedProperty.Parameters = ParameterList.Empty;                          // attached properties are instance properties                          // somehow mark as attached?                          type.Members.Add(attachedProperty);                          attachedMembers.Add(attachedProperty' field);                        }                        // go through the members' looking for fields signaling attached events                      foreach (Member member in members) {                            if (!member.IsStatic || !member.IsVisibleOutsideAssembly) continue;                            if (member.NodeType != NodeType.Field) continue;                          Field field = (Field)member;                            if (field.Type.FullName != "System.Windows.RoutedEvent") continue;                            string name = field.Name.Name;                          if (!name.EndsWith("Event")) continue;                          name = name.Substring(0' name.Length - 5);                            Method adder = null;                          MemberList candidateAdders = type.GetMembersNamed(new Identifier("Add" + name + "Handler"));                          for (int i = 0; i < candidateAdders.Count; i++) {                              Member candidateAdder = candidateAdders[i];                              if ((candidateAdder.NodeType == NodeType.Method) && candidateAdder.IsStatic) adder = (Method)candidateAdder;                          }                            Method remover = null;                          MemberList candidateRemovers = type.GetMembersNamed(new Identifier("Remove" + name + "Handler"));                          for (int i = 0; i < candidateRemovers.Count; i++) {                              Member candidateRemover = candidateRemovers[i];                              if ((candidateRemover.NodeType == NodeType.Method) && candidateRemover.IsStatic) remover = (Method)candidateRemover;                          }                            if ((adder == null) || (remover == null)) continue;                            // make sure there isn't already such an event                            Event existingEvent = type.GetEvent(new Identifier(name));                          if (existingEvent != null && existingEvent.IsVisibleOutsideAssembly) continue;                            // okay' this really is an indication of an attached event' so create one                            TypeNode handler = adder.Parameters[1].Type;                          Event attachedEvent = new Event(type' null' EventFlags.None' new Identifier(name)' adder' null' remover' handler);                          attachedEvent.HandlerFlags = adder.Flags;                          // attached events are instance events                          // mark as attached?                            type.Members.Add(attachedEvent);                          attachedMembers.Add(attachedEvent' field);                        }                    }              }
Magic Number,Microsoft.Ddue.Tools,XamlAttachedMembersAddIn,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\XamlAttachedMembersAddIn.cs,AddAttachedMembers,The following statement contains a magic number: foreach (Namespace space in spaces) {                  TypeNodeList types = space.Types;                  foreach (TypeNode type in types) {                        MemberList members = type.Members;                        // go through the members' looking for fields signaling attached properties                      foreach (Member member in members) {                            // we need a visible' static' field...                          if (!member.IsStatic || !member.IsVisibleOutsideAssembly || member.NodeType != NodeType.Field) continue;                          Field field = (Field)member;                            // of type dependency property....                          if (field.Type.FullName != "System.Windows.DependencyProperty") continue;                            // with a name ending in "Property"...                          string name = field.Name.Name;                          if (!name.EndsWith("Property")) continue;                          name = name.Substring(0' name.Length - 8);                            // look for a getter and/or a setter                            Method getter = null;                          MemberList candidateGetters = type.GetMembersNamed(new Identifier("Get" + name));                          for (int i = 0; i < candidateGetters.Count; i++) {                              Member candidateGetter = candidateGetters[i];                              if ((candidateGetter.NodeType == NodeType.Method) && candidateGetter.IsStatic && candidateGetter.IsVisibleOutsideAssembly) getter = (Method)candidateGetter;                          }                            Method setter = null;                          MemberList candidateSetters = type.GetMembersNamed(new Identifier("Set" + name));                          for (int i = 0; i < candidateSetters.Count; i++) {                              Member candidateSetter = candidateSetters[i];                              if ((candidateSetter.NodeType == NodeType.Method) && candidateSetter.IsStatic && candidateSetter.IsVisibleOutsideAssembly) setter = (Method)candidateSetter;                          }                            if ((getter == null) && (setter == null)) continue;                            // make sure there isn't already such a property                            Property existingProperty = type.GetProperty(new Identifier(name)' new TypeNode[0]);                          if (existingProperty != null && existingProperty.IsVisibleOutsideAssembly) continue;                            // okay' this really is an indication of an attached property' so create one                            Property attachedProperty = new Property(type' null' PropertyFlags.None' new Identifier(name)' getter' setter);                          // attached properties have no parameters                          attachedProperty.Parameters = ParameterList.Empty;                          // attached properties are instance properties                          // somehow mark as attached?                          type.Members.Add(attachedProperty);                          attachedMembers.Add(attachedProperty' field);                        }                        // go through the members' looking for fields signaling attached events                      foreach (Member member in members) {                            if (!member.IsStatic || !member.IsVisibleOutsideAssembly) continue;                            if (member.NodeType != NodeType.Field) continue;                          Field field = (Field)member;                            if (field.Type.FullName != "System.Windows.RoutedEvent") continue;                            string name = field.Name.Name;                          if (!name.EndsWith("Event")) continue;                          name = name.Substring(0' name.Length - 5);                            Method adder = null;                          MemberList candidateAdders = type.GetMembersNamed(new Identifier("Add" + name + "Handler"));                          for (int i = 0; i < candidateAdders.Count; i++) {                              Member candidateAdder = candidateAdders[i];                              if ((candidateAdder.NodeType == NodeType.Method) && candidateAdder.IsStatic) adder = (Method)candidateAdder;                          }                            Method remover = null;                          MemberList candidateRemovers = type.GetMembersNamed(new Identifier("Remove" + name + "Handler"));                          for (int i = 0; i < candidateRemovers.Count; i++) {                              Member candidateRemover = candidateRemovers[i];                              if ((candidateRemover.NodeType == NodeType.Method) && candidateRemover.IsStatic) remover = (Method)candidateRemover;                          }                            if ((adder == null) || (remover == null)) continue;                            // make sure there isn't already such an event                            Event existingEvent = type.GetEvent(new Identifier(name));                          if (existingEvent != null && existingEvent.IsVisibleOutsideAssembly) continue;                            // okay' this really is an indication of an attached event' so create one                            TypeNode handler = adder.Parameters[1].Type;                          Event attachedEvent = new Event(type' null' EventFlags.None' new Identifier(name)' adder' null' remover' handler);                          attachedEvent.HandlerFlags = adder.Flags;                          // attached events are instance events                          // mark as attached?                            type.Members.Add(attachedEvent);                          attachedMembers.Add(attachedEvent' field);                        }                    }              }
Duplicate Code,Microsoft.Ddue.Tools,MRefBuilder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefBuilder.cs,Main,The method contains a code clone-set at the following line numbers (starting from the method definition): ((95' 122)' (140' 167))
Missing Default,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteApiData,The following switch statement is missing a default case: switch (api.NodeType) {                      case NodeType.Class:                          subgroup = "class";                          break;                      case NodeType.Struct:                          subgroup = "structure";                          break;                      case NodeType.Interface:                          subgroup = "interface";                          break;                      case NodeType.EnumNode:                          subgroup = "enumeration";                          break;                      case NodeType.DelegateNode:                          subgroup = "delegate";                          break;                  }
Missing Default,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteApiData,The following switch statement is missing a default case: switch (api.NodeType) {                      case NodeType.Field:                          subgroup = "field";                          break;                      case NodeType.Property:                          subgroup = "property";                          break;                      case NodeType.InstanceInitializer:                      case NodeType.StaticInitializer:                          subgroup = "constructor";                          // name = api.DeclaringType.GetUnmangledNameWithoutTypeParameters();                          break;                      case NodeType.Method:                          subgroup = "method";                          if ((api.IsSpecialName) && (name.StartsWith("op_"))) {                              subsubgroup = "operator";                              name = name.Substring(3);                          }                          break;                      case NodeType.Event:                          subgroup = "event";                          break;                  }
Missing Default,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteMember,The following switch statement is missing a default case: switch (member.NodeType) {                  case NodeType.Field:                      Field field = (Field)member;                      WriteFieldData(field);                      WriteValue(field.Type);                      // write enumeration field values; expand later to all literal field values?                      if (field.DeclaringType.NodeType == NodeType.EnumNode) {                          WriteLiteral(new Literal(field.DefaultValue.Value' ((EnumNode)field.DeclaringType).UnderlyingType)' false);                      }                      break;                  case NodeType.Method:                      Method method = (Method)member;                      WriteMethodData(method);                        // write the templates node with either the generic template params or the specialized template arguments                      if (method.TemplateArguments != null)                          WriteSpecializedTemplateArguments(method.TemplateArguments);                      else                          WriteGenericParameters(method.TemplateParameters);                        WriteParameters(method.Parameters);                      WriteValue(method.ReturnType);                      WriteImplementedMembers(ReflectionUtilities.GetImplementedMethods(method));                        if (method.SecurityAttributes != null) securityAttributes = method.SecurityAttributes;                      break;                  case NodeType.Property:                      Property property = (Property)member;                      WritePropertyData(property);                      WriteParameters(property.Parameters);                      WriteValue(property.Type);                      WriteImplementedMembers(ReflectionUtilities.GetImplementedProperties(property));                      break;                  case NodeType.Event:                      Event trigger = (Event)member;                      WriteEventData(trigger);                      WriteImplementedMembers(ReflectionUtilities.GetImplementedEvents(trigger));                      break;                  case NodeType.InstanceInitializer:                  case NodeType.StaticInitializer:                      Method constructor = (Method)member;                      WriteParameters(constructor.Parameters);                      break;                }
Missing Default,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteType,The following switch statement is missing a default case: switch (type.NodeType) {                  case NodeType.Class:                  case NodeType.Struct:                      WriteGenericParameters(type.TemplateParameters);                      WriteInterfaces(type.Interfaces);                      WriteTypeElements(type);                      break;                  case NodeType.Interface:                      WriteGenericParameters(type.TemplateParameters);                      WriteInterfaces(type.Interfaces);                      WriteImplementors((Interface)type);                      WriteTypeElements(type);                      break;                  case NodeType.DelegateNode:                      DelegateNode handler = (DelegateNode)type;                      WriteGenericParameters(handler.TemplateParameters);                      WriteParameters(handler.Parameters);                      WriteValue(handler.ReturnType);                      break;                  case NodeType.EnumNode:                      WriteEnumerationData((EnumNode)type);                      WriteTypeElements(type);                      break;              }
Missing Default,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteTypeData,The following switch statement is missing a default case: switch (layout) {                  case TypeFlags.AutoLayout:                      WriteStringAttribute("layout"' "auto");                      break;                  case TypeFlags.SequentialLayout:                      WriteStringAttribute("layout"' "sequential");                      break;                  case TypeFlags.ExplicitLayout:                      WriteStringAttribute("layout"' "explicit");                      break;              }
Missing Default,Microsoft.Ddue.Tools,ManagedReflectionWriter,C:\repos\DotNetOpenAuth_DotNetOpenAuth\tools\Sandcastle\Source\MRefBuilder\MRefWriter.cs,WriteTypeData,The following switch statement is missing a default case: switch (format) {                  case TypeFlags.AnsiClass:                      WriteStringAttribute("format"' "ansi");                      break;                  case TypeFlags.UnicodeClass:                      WriteStringAttribute("format"' "unicode");                      break;                  case TypeFlags.AutoClass:                      WriteStringAttribute("format"' "auto");                      break;              }
