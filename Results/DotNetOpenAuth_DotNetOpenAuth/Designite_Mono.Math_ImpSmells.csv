Implementation smell,Namespace,Class,File,Method,Description
Complex Method,Mono.Math,Montgomery,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Reduce,Cyclomatic complexity of the method is 8
Complex Method,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,SquarePositive,Cyclomatic complexity of the method is 12
Complex Method,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,gcd,Cyclomatic complexity of the method is 8
Complex Method,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,RabinMillerTest,Cyclomatic complexity of the method is 9
Complex Method,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,Cyclomatic complexity of the method is 16
Long Parameter List,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Multiply,The method has 8 parameters. Parameters: x' xOffset' xLen' y' yOffset' yLen' d' dOffset
Long Parameter List,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,MultiplyMod2p32pmod,The method has 9 parameters. Parameters: x' xOffset' xLen' y' yOffest' yLen' d' dOffset' mod
Long Statement,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BarrettReduction,The length of the statement  "				Kernel.MultiplyMod2p32pmod (q3.data' (int)kPlusOne' (int)q3.length - (int)kPlusOne' n.data' 0' (int)n.length' r2.data' 0' (int)kPlusOne); " is 137.
Long Statement,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,OddPow,The length of the statement  "				BigInteger tempNum = new BigInteger (Montgomery.ToMont (b' mod)' mod.length << 1);  // ensures (tempNum * tempNum) < b^ (2k) " is 124.
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Parse,The following statement contains a magic number: for(; i < len; i++) {  				c = number[i];  				if (c == '\0') {  					i = len;  					continue;  				}  				if (c >= '0' && c <= '9'){  					val = val * 10 + (c - '0');  					digits_seen = true;  				} else {  					if (Char.IsWhiteSpace(c)){  						for (i++; i < len; i++){  							if (!Char.IsWhiteSpace (number[i]))  								throw new FormatException();  						}  						break;  					} else  						throw new FormatException();  				}  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: length = (uint)inData.Length >> 2;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: for (int i = inData.Length - 1' j = 0; i >= 3; i -= 4' j++) {  				data [j] = (uint)(  					(inData [i-3] << (3*8)) |  					(inData [i-2] << (2*8)) |  					(inData [i-1] << (1*8)) |  					(inData [i-0] << (0*8))  					);  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint [2] { (uint)ul' (uint)(ul >> 32)};
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: data = new uint [2] { (uint)ul' (uint)(ul >> 32)};
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following statement contains a magic number: length = 2;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,genRandom,The following statement contains a magic number: int dwords = bits >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,genRandom,The following statement contains a magic number: byte [] random = new byte [dwords << 2];
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,genRandom,The following statement contains a magic number: Buffer.BlockCopy (random' 0' ret.data' 0' (int)dwords << 2);
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,genRandom,The following statement contains a magic number: if (remBits != 0) {  				uint mask = (uint)(0x01 << (remBits-1));  				ret.data [dwords-1] |= mask;    				mask = (uint)(0xFFFFFFFF >> (32 - remBits));  				ret.data [dwords-1] &= mask;  			}  			else  				ret.data [dwords-1] |= 0x80000000;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,randomize,The following statement contains a magic number: int dwords = bits >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,randomize,The following statement contains a magic number: byte [] random = new byte [dwords << 2];
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,randomize,The following statement contains a magic number: Buffer.BlockCopy (random' 0' data' 0' (int)dwords << 2);
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,randomize,The following statement contains a magic number: if (remBits != 0) {  				uint mask = (uint)(0x01 << (remBits-1));  				data [dwords-1] |= mask;    				mask = (uint)(0xFFFFFFFF >> (32 - remBits));  				data [dwords-1] &= mask;  			}    			else  				data [dwords-1] |= 0x80000000;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,bitCount,The following statement contains a magic number: uint bits = 32;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,bitCount,The following statement contains a magic number: bits += ((length - 1) << 5);
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,testBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,testBit,The following statement contains a magic number: uint bytePos = (uint)bitNum >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,setBit,The following statement contains a magic number: uint bytePos = bitNum >> 5;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,getBytes,The following statement contains a magic number: int numBytes = numBits >> 3;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,getBytes,The following statement contains a magic number: if (numBytesInWord == 0) numBytesInWord = 4;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,getBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--) {  				uint val = data [i];  				for (int j = numBytesInWord - 1; j >= 0; j--) {  					result [pos+j] = (byte)(val & 0xFF);  					val >>= 8;  				}  				pos += numBytesInWord;  				numBytesInWord = 4;  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,getBytes,The following statement contains a magic number: for (int i = (int)length - 1; i >= 0; i--) {  				uint val = data [i];  				for (int j = numBytesInWord - 1; j >= 0; j--) {  					result [pos+j] = (byte)(val & 0xFF);  					val >>= 8;  				}  				pos += numBytesInWord;  				numBytesInWord = 4;  			}
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,ToString,The following statement contains a magic number: return ToString (10);
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Incr2,The following statement contains a magic number: data [0] += 2;
Magic Number,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Incr2,The following statement contains a magic number: if (data [0] < 2) {    				// Account for the first carry  				data [++i]++;    				// Keep adding until no carry  				while (data [i++] == 0x0)  					data [i]++;    				// See if we increased the data length  				if (length == (uint)i)  					length++;  			}
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Pow,The following statement contains a magic number: if (b != 2) {  					if ((mod.data [0] & 1) == 1) return OddPow (b' exp);  					else return EvenPow (b' exp);  				} else {  					if ((mod.data [0] & 1) == 1) return OddModTwoPow (exp);  					else return EvenModTwoPow (exp);  				}
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,OddPow,The following statement contains a magic number: uint pos = (uint)exp.bitCount () - 2;
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,OddPow,The following statement contains a magic number: do {  					//  					// r = r ^ 2 % m  					//  					Kernel.SquarePositive(resultNum' ref wkspace);  					resultNum = Montgomery.Reduce(resultNum' mod' mPrime);    					if (exp.testBit(pos)) {    						//  						// r = r * b % m  						//    						uint u = 0;    						uint i = 0;  						ulong mc = 0;    						do {  							mc += (ulong)resultNum.data[u + i] * (ulong)b;  							resultNum.data[u + i] = (uint)mc;  							mc >>= 32;  						} while (++i < resultNum.length);    						if (resultNum.length < mod.length) {  							if (mc != 0) {  								resultNum.data[u + i] = (uint)mc;  								resultNum.length++;  								while (resultNum >= mod)  									Kernel.MinusEq(resultNum' mod);  							}  						} else if (mc != 0) {    							//  							// First' we estimate the quotient by dividing  							// the first part of each of the numbers. Then  							// we correct this' if necessary' with a subtraction.  							//    							uint cc = (uint)mc;    							// We would rather have this estimate overshoot'  							// so we add one to the divisor  							uint divEstimate = (uint)((((ulong)cc << 32) | (ulong)resultNum.data[u + i - 1]) /  								(mod.data[mod.length - 1] + 1));    							uint t;    							i = 0;  							mc = 0;  							do {  								mc += (ulong)mod.data[i] * (ulong)divEstimate;  								t = resultNum.data[u + i];  								resultNum.data[u + i] -= (uint)mc;  								mc >>= 32;  								if (resultNum.data[u + i] > t) mc++;  								i++;  							} while (i < resultNum.length);  							cc -= (uint)mc;    							if (cc != 0) {    								uint sc = 0' j = 0;  								uint[] s = mod.data;  								do {  									uint a = s[j];  									if (((a += sc) < sc) | ((resultNum.data[u + j] -= a) > ~a)) sc = 1;  									else sc = 0;  									j++;  								} while (j < resultNum.length);  								cc -= sc;  							}  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						} else {  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						}  					}  				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,OddPow,The following statement contains a magic number: do {  					//  					// r = r ^ 2 % m  					//  					Kernel.SquarePositive(resultNum' ref wkspace);  					resultNum = Montgomery.Reduce(resultNum' mod' mPrime);    					if (exp.testBit(pos)) {    						//  						// r = r * b % m  						//    						uint u = 0;    						uint i = 0;  						ulong mc = 0;    						do {  							mc += (ulong)resultNum.data[u + i] * (ulong)b;  							resultNum.data[u + i] = (uint)mc;  							mc >>= 32;  						} while (++i < resultNum.length);    						if (resultNum.length < mod.length) {  							if (mc != 0) {  								resultNum.data[u + i] = (uint)mc;  								resultNum.length++;  								while (resultNum >= mod)  									Kernel.MinusEq(resultNum' mod);  							}  						} else if (mc != 0) {    							//  							// First' we estimate the quotient by dividing  							// the first part of each of the numbers. Then  							// we correct this' if necessary' with a subtraction.  							//    							uint cc = (uint)mc;    							// We would rather have this estimate overshoot'  							// so we add one to the divisor  							uint divEstimate = (uint)((((ulong)cc << 32) | (ulong)resultNum.data[u + i - 1]) /  								(mod.data[mod.length - 1] + 1));    							uint t;    							i = 0;  							mc = 0;  							do {  								mc += (ulong)mod.data[i] * (ulong)divEstimate;  								t = resultNum.data[u + i];  								resultNum.data[u + i] -= (uint)mc;  								mc >>= 32;  								if (resultNum.data[u + i] > t) mc++;  								i++;  							} while (i < resultNum.length);  							cc -= (uint)mc;    							if (cc != 0) {    								uint sc = 0' j = 0;  								uint[] s = mod.data;  								do {  									uint a = s[j];  									if (((a += sc) < sc) | ((resultNum.data[u + j] -= a) > ~a)) sc = 1;  									else sc = 0;  									j++;  								} while (j < resultNum.length);  								cc -= sc;  							}  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						} else {  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						}  					}  				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,OddPow,The following statement contains a magic number: do {  					//  					// r = r ^ 2 % m  					//  					Kernel.SquarePositive(resultNum' ref wkspace);  					resultNum = Montgomery.Reduce(resultNum' mod' mPrime);    					if (exp.testBit(pos)) {    						//  						// r = r * b % m  						//    						uint u = 0;    						uint i = 0;  						ulong mc = 0;    						do {  							mc += (ulong)resultNum.data[u + i] * (ulong)b;  							resultNum.data[u + i] = (uint)mc;  							mc >>= 32;  						} while (++i < resultNum.length);    						if (resultNum.length < mod.length) {  							if (mc != 0) {  								resultNum.data[u + i] = (uint)mc;  								resultNum.length++;  								while (resultNum >= mod)  									Kernel.MinusEq(resultNum' mod);  							}  						} else if (mc != 0) {    							//  							// First' we estimate the quotient by dividing  							// the first part of each of the numbers. Then  							// we correct this' if necessary' with a subtraction.  							//    							uint cc = (uint)mc;    							// We would rather have this estimate overshoot'  							// so we add one to the divisor  							uint divEstimate = (uint)((((ulong)cc << 32) | (ulong)resultNum.data[u + i - 1]) /  								(mod.data[mod.length - 1] + 1));    							uint t;    							i = 0;  							mc = 0;  							do {  								mc += (ulong)mod.data[i] * (ulong)divEstimate;  								t = resultNum.data[u + i];  								resultNum.data[u + i] -= (uint)mc;  								mc >>= 32;  								if (resultNum.data[u + i] > t) mc++;  								i++;  							} while (i < resultNum.length);  							cc -= (uint)mc;    							if (cc != 0) {    								uint sc = 0' j = 0;  								uint[] s = mod.data;  								do {  									uint a = s[j];  									if (((a += sc) < sc) | ((resultNum.data[u + j] -= a) > ~a)) sc = 1;  									else sc = 0;  									j++;  								} while (j < resultNum.length);  								cc -= sc;  							}  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						} else {  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						}  					}  				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,EvenPow,The following statement contains a magic number: uint pos = (uint)exp.bitCount() - 2;
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,EvenPow,The following statement contains a magic number: do {  					//  					// r = r ^ 2 % m  					//  					Kernel.SquarePositive(resultNum' ref wkspace);  					if (!(resultNum.length < mod.length))  						BarrettReduction(resultNum);    					if (exp.testBit(pos)) {    						//  						// r = r * b % m  						//    						uint u = 0;    						uint i = 0;  						ulong mc = 0;    						do {  							mc += (ulong)resultNum.data[u + i] * (ulong)b;  							resultNum.data[u + i] = (uint)mc;  							mc >>= 32;  						} while (++i < resultNum.length);    						if (resultNum.length < mod.length) {  							if (mc != 0) {  								resultNum.data[u + i] = (uint)mc;  								resultNum.length++;  								while (resultNum >= mod)  									Kernel.MinusEq(resultNum' mod);  							}  						} else if (mc != 0) {    							//  							// First' we estimate the quotient by dividing  							// the first part of each of the numbers. Then  							// we correct this' if necessary' with a subtraction.  							//    							uint cc = (uint)mc;    							// We would rather have this estimate overshoot'  							// so we add one to the divisor  							uint divEstimate = (uint)((((ulong)cc << 32) | (ulong)resultNum.data[u + i - 1]) /  								(mod.data[mod.length - 1] + 1));    							uint t;    							i = 0;  							mc = 0;  							do {  								mc += (ulong)mod.data[i] * (ulong)divEstimate;  								t = resultNum.data[u + i];  								resultNum.data[u + i] -= (uint)mc;  								mc >>= 32;  								if (resultNum.data[u + i] > t) mc++;  								i++;  							} while (i < resultNum.length);  							cc -= (uint)mc;    							if (cc != 0) {    								uint sc = 0' j = 0;  								uint[] s = mod.data;  								do {  									uint a = s[j];  									if (((a += sc) < sc) | ((resultNum.data[u + j] -= a) > ~a)) sc = 1;  									else sc = 0;  									j++;  								} while (j < resultNum.length);  								cc -= sc;  							}  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						} else {  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						}  					}  				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,EvenPow,The following statement contains a magic number: do {  					//  					// r = r ^ 2 % m  					//  					Kernel.SquarePositive(resultNum' ref wkspace);  					if (!(resultNum.length < mod.length))  						BarrettReduction(resultNum);    					if (exp.testBit(pos)) {    						//  						// r = r * b % m  						//    						uint u = 0;    						uint i = 0;  						ulong mc = 0;    						do {  							mc += (ulong)resultNum.data[u + i] * (ulong)b;  							resultNum.data[u + i] = (uint)mc;  							mc >>= 32;  						} while (++i < resultNum.length);    						if (resultNum.length < mod.length) {  							if (mc != 0) {  								resultNum.data[u + i] = (uint)mc;  								resultNum.length++;  								while (resultNum >= mod)  									Kernel.MinusEq(resultNum' mod);  							}  						} else if (mc != 0) {    							//  							// First' we estimate the quotient by dividing  							// the first part of each of the numbers. Then  							// we correct this' if necessary' with a subtraction.  							//    							uint cc = (uint)mc;    							// We would rather have this estimate overshoot'  							// so we add one to the divisor  							uint divEstimate = (uint)((((ulong)cc << 32) | (ulong)resultNum.data[u + i - 1]) /  								(mod.data[mod.length - 1] + 1));    							uint t;    							i = 0;  							mc = 0;  							do {  								mc += (ulong)mod.data[i] * (ulong)divEstimate;  								t = resultNum.data[u + i];  								resultNum.data[u + i] -= (uint)mc;  								mc >>= 32;  								if (resultNum.data[u + i] > t) mc++;  								i++;  							} while (i < resultNum.length);  							cc -= (uint)mc;    							if (cc != 0) {    								uint sc = 0' j = 0;  								uint[] s = mod.data;  								do {  									uint a = s[j];  									if (((a += sc) < sc) | ((resultNum.data[u + j] -= a) > ~a)) sc = 1;  									else sc = 0;  									j++;  								} while (j < resultNum.length);  								cc -= sc;  							}  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						} else {  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						}  					}  				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,EvenPow,The following statement contains a magic number: do {  					//  					// r = r ^ 2 % m  					//  					Kernel.SquarePositive(resultNum' ref wkspace);  					if (!(resultNum.length < mod.length))  						BarrettReduction(resultNum);    					if (exp.testBit(pos)) {    						//  						// r = r * b % m  						//    						uint u = 0;    						uint i = 0;  						ulong mc = 0;    						do {  							mc += (ulong)resultNum.data[u + i] * (ulong)b;  							resultNum.data[u + i] = (uint)mc;  							mc >>= 32;  						} while (++i < resultNum.length);    						if (resultNum.length < mod.length) {  							if (mc != 0) {  								resultNum.data[u + i] = (uint)mc;  								resultNum.length++;  								while (resultNum >= mod)  									Kernel.MinusEq(resultNum' mod);  							}  						} else if (mc != 0) {    							//  							// First' we estimate the quotient by dividing  							// the first part of each of the numbers. Then  							// we correct this' if necessary' with a subtraction.  							//    							uint cc = (uint)mc;    							// We would rather have this estimate overshoot'  							// so we add one to the divisor  							uint divEstimate = (uint)((((ulong)cc << 32) | (ulong)resultNum.data[u + i - 1]) /  								(mod.data[mod.length - 1] + 1));    							uint t;    							i = 0;  							mc = 0;  							do {  								mc += (ulong)mod.data[i] * (ulong)divEstimate;  								t = resultNum.data[u + i];  								resultNum.data[u + i] -= (uint)mc;  								mc >>= 32;  								if (resultNum.data[u + i] > t) mc++;  								i++;  							} while (i < resultNum.length);  							cc -= (uint)mc;    							if (cc != 0) {    								uint sc = 0' j = 0;  								uint[] s = mod.data;  								do {  									uint a = s[j];  									if (((a += sc) < sc) | ((resultNum.data[u + j] -= a) > ~a)) sc = 1;  									else sc = 0;  									j++;  								} while (j < resultNum.length);  								cc -= sc;  							}  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						} else {  							while (resultNum >= mod)  								Kernel.MinusEq(resultNum' mod);  						}  					}  				} while (pos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,EvenModTwoPow,The following statement contains a magic number: BigInteger resultNum = new BigInteger (2' mod.length << 1 +1);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,EvenModTwoPow,The following statement contains a magic number: do {  					value = exp.data [wPos];  					do {  						Kernel.SquarePositive (resultNum' ref wkspace);  						if (resultNum.length >= mod.length)  							BarrettReduction (resultNum);    						if ((value & mask) != 0) {  							//  							// resultNum = (resultNum * 2) % mod  							//    							uint u = 0;  							//  							// Double  							//  							uint uu = u;  							uint uuE = u + resultNum.length;  							uint x' carry = 0;  							while (uu < uuE) {  								x = resultNum.data[uu];  								resultNum.data[uu] = (x << 1) | carry;  								carry = x >> (32 - 1);  								uu++;  							}    							// subtraction inlined because we know it is square  							if (carry != 0 || resultNum >= mod) {  								uu = u;  								uint c = 0;  								uint[] s = mod.data;  								uint i = 0;  								do {  									uint a = s[i];  									if (((a += c) < c) | ((resultNum.data[uu++] -= a) > ~a))  										c = 1;  									else  										c = 0;  									i++;  								} while (uu < uuE);  							}    						}  					} while ((mask >>= 1) > 0);  					mask = 0x80000000;  				} while (wPos-- > 0);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,OddModTwoPow,The following statement contains a magic number: BigInteger resultNum = Montgomery.ToMont ((BigInteger)2' this.mod);
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,OddModTwoPow,The following statement contains a magic number: uint pos = (uint)exp.bitCount () - 2;
Magic Number,Mono.Math,ModulusRing,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,OddModTwoPow,The following statement contains a magic number: do {  					Kernel.SquarePositive (resultNum' ref wkspace);  					resultNum = Montgomery.Reduce (resultNum' mod' mPrime);    					if (exp.testBit(pos)) {  						//  						// resultNum = (resultNum * 2) % mod  						//    						uint u = 0;  						//  						// Double  						//  						uint uu = u;  						uint uuE = u + resultNum.length;  						uint x' carry = 0;  						while (uu < uuE) {  							x = resultNum.data[uu];  							resultNum.data[uu] = (x << 1) | carry;  							carry = x >> (32 - 1);  							uu++;  						}    						// subtraction inlined because we know it is square  						if (carry != 0 || resultNum >= mod) {  							uint s = 0;  							uu = u;  							uint c = 0;  							uint ss = s;  							do {  								uint a = mod.data[ss++];  								if (((a += c) < c) | ((resultNum.data[uu++] -= a) > ~a))  									c = 1;  								else  									c = 0;  							} while (uu < uuE);  						}  					}  				} while (pos-- > 0);
Magic Number,Mono.Math,Montgomery,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Inverse,The following statement contains a magic number: while ((z = n * y) != 1)  					y *= 2 - z;
Magic Number,Mono.Math,Montgomery,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,ToMont,The following statement contains a magic number: n <<= (int)m.length * 32;
Magic Number,Mono.Math,Montgomery,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Reduce,The following statement contains a magic number: for (uint i = 0; i < m.length; i++) {  					// The mod here is taken care of by the CPU'  					// since the multiply will overflow.  					uint u_i = A.data[a] * mPrime /* % 2^32 */;    					//  					// A += u_i * m;  					// A >>= 32  					//    					// mP = Position in mod  					// aSP = the source of bits from a  					// aDP = destination for bits  					uint mP = mm' aSP = a' aDP = a;    					ulong c = (ulong)u_i * (ulong)m.data[mP++] + A.data[aSP++];  					c >>= 32;  					uint j = 1;    					// Multiply and add  					for (; j < m.length; j++) {  						c += (ulong)u_i * (ulong)m.data[mP++] + A.data[aSP++];  						A.data[aDP++] = (uint)c;  						c >>= 32;  					}    					// Account for carry  					// TODO: use a better loop here' we dont need the ulong stuff  					for (; j < A.length; j++) {  						c += A.data[aSP++];  						A.data[aDP++] = (uint)c;  						c >>= 32;  						if (c == 0) { j++; break; }  					}  					// Copy the rest  					for (; j < A.length; j++) {  						A.data[aDP++] = A.data[aSP++];  					}    					A.data[aDP++] = (uint)c;  				}
Magic Number,Mono.Math,Montgomery,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Reduce,The following statement contains a magic number: for (uint i = 0; i < m.length; i++) {  					// The mod here is taken care of by the CPU'  					// since the multiply will overflow.  					uint u_i = A.data[a] * mPrime /* % 2^32 */;    					//  					// A += u_i * m;  					// A >>= 32  					//    					// mP = Position in mod  					// aSP = the source of bits from a  					// aDP = destination for bits  					uint mP = mm' aSP = a' aDP = a;    					ulong c = (ulong)u_i * (ulong)m.data[mP++] + A.data[aSP++];  					c >>= 32;  					uint j = 1;    					// Multiply and add  					for (; j < m.length; j++) {  						c += (ulong)u_i * (ulong)m.data[mP++] + A.data[aSP++];  						A.data[aDP++] = (uint)c;  						c >>= 32;  					}    					// Account for carry  					// TODO: use a better loop here' we dont need the ulong stuff  					for (; j < A.length; j++) {  						c += A.data[aSP++];  						A.data[aDP++] = (uint)c;  						c >>= 32;  						if (c == 0) { j++; break; }  					}  					// Copy the rest  					for (; j < A.length; j++) {  						A.data[aDP++] = A.data[aSP++];  					}    					A.data[aDP++] = (uint)c;  				}
Magic Number,Mono.Math,Montgomery,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Reduce,The following statement contains a magic number: for (uint i = 0; i < m.length; i++) {  					// The mod here is taken care of by the CPU'  					// since the multiply will overflow.  					uint u_i = A.data[a] * mPrime /* % 2^32 */;    					//  					// A += u_i * m;  					// A >>= 32  					//    					// mP = Position in mod  					// aSP = the source of bits from a  					// aDP = destination for bits  					uint mP = mm' aSP = a' aDP = a;    					ulong c = (ulong)u_i * (ulong)m.data[mP++] + A.data[aSP++];  					c >>= 32;  					uint j = 1;    					// Multiply and add  					for (; j < m.length; j++) {  						c += (ulong)u_i * (ulong)m.data[mP++] + A.data[aSP++];  						A.data[aDP++] = (uint)c;  						c >>= 32;  					}    					// Account for carry  					// TODO: use a better loop here' we dont need the ulong stuff  					for (; j < A.length; j++) {  						c += A.data[aSP++];  						A.data[aDP++] = (uint)c;  						c >>= 32;  						if (c == 0) { j++; break; }  					}  					// Copy the rest  					for (; j < A.length; j++) {  						A.data[aDP++] = A.data[aSP++];  					}    					A.data[aDP++] = (uint)c;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,AddSameSign,The following statement contains a magic number: do {  					sum = ((ulong)x [i]) + ((ulong)y [i]) + sum;  					r [i] = (uint)sum;  					sum >>= 32;  				} while (++i < yMax);
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,PlusEq,The following statement contains a magic number: do {  					sum += ((ulong)x [i]) + ((ulong)y [i]);  					r [i] = (uint)sum;  					sum >>= 32;  				} while (++i < yMax);
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,SingleByteDivideInPlace,The following statement contains a magic number: while (i-- > 0) {  					r <<= 32;  					r |= n.data [i];  					n.data [i] = (uint)(r / d);  					r %= d;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,DwordMod,The following statement contains a magic number: while (i-- > 0) {  					r <<= 32;  					r |= n.data [i];  					r %= d;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,DwordDiv,The following statement contains a magic number: while (i-- > 0) {  					r <<= 32;  					r |= n.data [i];  					ret.data [i] = (uint)(r / d);  					r %= d;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,DwordDivMod,The following statement contains a magic number: while (i-- > 0) {  					r <<= 32;  					r |= n.data [i];  					ret.data [i] = (uint)(r / d);  					r %= d;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,multiByteDivide,The following statement contains a magic number: if (Kernel.Compare (bi1' bi2) == Sign.Negative)  					return new BigInteger [2] { 0' new BigInteger (bi1) };
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,multiByteDivide,The following statement contains a magic number: ulong secondDivisorByte = bi2.data [bi2.length-2];
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,multiByteDivide,The following statement contains a magic number: while (j > 0) {  					ulong dividend = ((ulong)remainder [pos] << 32) + (ulong)remainder [pos-1];    					ulong q_hat = dividend / (ulong)firstDivisorByte;  					ulong r_hat = dividend % (ulong)firstDivisorByte;    					do {    						if (q_hat == 0x100000000 ||  							(q_hat * secondDivisorByte) > ((r_hat << 32) + remainder [pos-2])) {  							q_hat--;  							r_hat += (ulong)firstDivisorByte;    							if (r_hat < 0x100000000)  								continue;  						}  						break;  					} while (true);    					//  					// At this point' q_hat is either exact' or one too large  					// (more likely to be exact) so' we attempt to multiply the  					// divisor by q_hat' if we get a borrow' we just subtract  					// one from q_hat and add the divisor back.  					//    					uint t;  					uint dPos = 0;  					int nPos = pos - divisorLen + 1;  					ulong mc = 0;  					uint uint_q_hat = (uint)q_hat;  					do {  						mc += (ulong)bi2.data [dPos] * (ulong)uint_q_hat;  						t = remainder [nPos];  						remainder [nPos] -= (uint)mc;  						mc >>= 32;  						if (remainder [nPos] > t) mc++;  						dPos++; nPos++;  					} while (dPos < divisorLen);    					nPos = pos - divisorLen + 1;  					dPos = 0;    					// Overestimate  					if (mc != 0) {  						uint_q_hat--;  						ulong sum = 0;    						do {  							sum = ((ulong)remainder [nPos]) + ((ulong)bi2.data [dPos]) + sum;  							remainder [nPos] = (uint)sum;  							sum >>= 32;  							dPos++; nPos++;  						} while (dPos < divisorLen);    					}    					quot.data [resultPos--] = (uint)uint_q_hat;    					pos--;  					j--;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,multiByteDivide,The following statement contains a magic number: BigInteger [] ret = new BigInteger [2] { quot' rem };
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,LeftShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,LeftShift,The following statement contains a magic number: n &= ((1 << 5) - 1);
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,LeftShift,The following statement contains a magic number: if (n != 0) {  					uint x' carry = 0;  					while (i < l) {  						x = bi.data [i];  						ret.data [i + w] = (x << n) | carry;  						carry = x >> (32 - n);  						i++;  					}  					ret.data [i + w] = carry;  				} else {  					while (i < l) {  						ret.data [i + w] = bi.data [i];  						i++;  					}  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,RightShift,The following statement contains a magic number: int w = n >> 5;
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,RightShift,The following statement contains a magic number: int s = n & ((1 << 5) - 1);
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,RightShift,The following statement contains a magic number: if (s != 0) {    					uint x' carry = 0;    					while (l-- > 0) {  						x = bi.data [l + w];  						ret.data [l] = (x >> n) | carry;  						carry = x << (32 - n);  					}  				} else {  					while (l-- > 0)  						ret.data [l] = bi.data [l + w];    				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,MultiplyByDword,The following statement contains a magic number: do {  					c += (ulong)n.data [i] * (ulong)f;  					ret.data [i] = (uint)c;  					c >>= 32;  				} while (++i < n.length);
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,Multiply,The following statement contains a magic number: for (; xP < xE; xP++' dB++) {    					if (x[xP] == 0) continue;    					ulong mcarry = 0;    					uint dP = dB;  					for (uint yP = yB; yP < yE; yP++' dP++) {  						mcarry += ((ulong)x[xP] * (ulong)y[yP]) + (ulong)d[dP];    						d[dP] = (uint)mcarry;  						mcarry >>= 32;  					}    					if (mcarry != 0)  						d[dP] = (uint)mcarry;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,MultiplyMod2p32pmod,The following statement contains a magic number: for (; xP < xE; xP++' dB++)  				{    					if (x[xP] == 0) continue;    					ulong mcarry = 0;  					uint dP = dB;  					for (uint yP = yB; yP < yE && dP < dE; yP++' dP++)  					{  						mcarry += ((ulong)x[xP] * (ulong)y[yP]) + (ulong)d[dP];    						d[dP] = (uint)mcarry;  						mcarry >>= 32;  					}    					if (mcarry != 0 && dP < dE)  						d[dP] = (uint)mcarry;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,SquarePositive,The following statement contains a magic number: for (uint i = 0; i < dl; i++' dP++) {  					if (d[dP] == 0)  						continue;    					ulong mcarry = 0;  					uint bi1val = d[dP];    					uint dP2 = dP + 1' tP2 = tP + 2 * i + 1;    					for (uint j = i + 1; j < dl; j++' tP2++' dP2++) {  						// k = i + j  						mcarry += ((ulong)bi1val * (ulong)d[dP2]) + t[tP2];    						t[tP2] = (uint)mcarry;  						mcarry >>= 32;  					}    					if (mcarry != 0)  						t[tP2] = (uint)mcarry;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,SquarePositive,The following statement contains a magic number: for (uint i = 0; i < dl; i++' dP++) {  					if (d[dP] == 0)  						continue;    					ulong mcarry = 0;  					uint bi1val = d[dP];    					uint dP2 = dP + 1' tP2 = tP + 2 * i + 1;    					for (uint j = i + 1; j < dl; j++' tP2++' dP2++) {  						// k = i + j  						mcarry += ((ulong)bi1val * (ulong)d[dP2]) + t[tP2];    						t[tP2] = (uint)mcarry;  						mcarry >>= 32;  					}    					if (mcarry != 0)  						t[tP2] = (uint)mcarry;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,SquarePositive,The following statement contains a magic number: while (tP < ttE) {  					x = t[tP];  					t[tP] = (x << 1) | carry;  					carry = x >> (32 - 1);  					tP++;  				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,SquarePositive,The following statement contains a magic number: for (uint dE = dP + dl; (dP < dE); dP++' tP++) {  					ulong val = (ulong)d[dP] * (ulong)d[dP] + t[tP];  					t[tP] = (uint)val;  					val >>= 32;  					t[(++tP)] += (uint)val;  					if (t[tP] < (uint)val) {  						uint tP3 = tP;  						// Account for the first carry  						(t[++tP3])++;    						// Keep adding until no carry  						while ((t[tP3++]) == 0x0)  							(t[tP3])++;  					}    				}
Magic Number,Mono.Math,Kernel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,modInverse,The following statement contains a magic number: BigInteger [] q = new BigInteger [2];
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: if      (bc <= 100 ) Rounds = 27;  			else if (bc <= 150 ) Rounds = 18;  			else if (bc <= 200 ) Rounds = 15;  			else if (bc <= 250 ) Rounds = 12;  			else if (bc <= 300 ) Rounds =  9;  			else if (bc <= 350 ) Rounds =  8;  			else if (bc <= 400 ) Rounds =  7;  			else if (bc <= 500 ) Rounds =  6;  			else if (bc <= 600 ) Rounds =  5;  			else if (bc <= 800 ) Rounds =  4;  			else if (bc <= 1250) Rounds =  3;  			else		     Rounds =  2;
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: switch (confidence) {  				case ConfidenceFactor.ExtraLow:  					Rounds >>= 2;  					return Rounds != 0 ? Rounds : 1;  				case ConfidenceFactor.Low:  					Rounds >>= 1;  					return Rounds != 0 ? Rounds : 1;  				case ConfidenceFactor.Medium:  					return Rounds;  				case ConfidenceFactor.High:  					return Rounds <<= 1;  				case ConfidenceFactor.ExtraHigh:  					return Rounds <<= 2;  				case ConfidenceFactor.Provable:  					throw new Exception ("The Rabin-Miller test can not be executed in a way such that its results are provable");  				default:  					throw new ArgumentOutOfRangeException ("confidence");  			}
Magic Number,Mono.Math.Prime,PrimalityTests,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\PrimalityTests.cs,GetSPPRounds,The following statement contains a magic number: switch (confidence) {  				case ConfidenceFactor.ExtraLow:  					Rounds >>= 2;  					return Rounds != 0 ? Rounds : 1;  				case ConfidenceFactor.Low:  					Rounds >>= 1;  					return Rounds != 0 ? Rounds : 1;  				case ConfidenceFactor.Medium:  					return Rounds;  				case ConfidenceFactor.High:  					return Rounds <<= 1;  				case ConfidenceFactor.ExtraHigh:  					return Rounds <<= 2;  				case ConfidenceFactor.Provable:  					throw new Exception ("The Rabin-Miller test can not be executed in a way such that its results are provable");  				default:  					throw new ArgumentOutOfRangeException ("confidence");  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Magic Number,Mono.Math.Prime.Generator,SequentialSearchPrimeGeneratorBase,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\SequentialSearchPrimeGeneratorBase.cs,GenerateNewPrime,The following statement contains a magic number: while (true) {    				//  				// STEP 2.1 Sieve out numbers divisible by the first 9 primes  				//  				if (pMod1 %  3 == 0) goto biNotPrime;  				if (pMod1 %  5 == 0) goto biNotPrime;  				if (pMod1 %  7 == 0) goto biNotPrime;  				if (pMod1 % 11 == 0) goto biNotPrime;  				if (pMod1 % 13 == 0) goto biNotPrime;  				if (pMod1 % 17 == 0) goto biNotPrime;  				if (pMod1 % 19 == 0) goto biNotPrime;  				if (pMod1 % 23 == 0) goto biNotPrime;  				if (pMod1 % 29 == 0) goto biNotPrime;    				//  				// STEP 2.2 Sieve out all numbers divisible by the primes <= DivisionBound  				//  				for (int p = 9; p < SmallPrimes.Length && SmallPrimes [p] <= DivisionBound; p++) {  					if (curVal % SmallPrimes [p] == 0)  						goto biNotPrime;  				}    				//  				// STEP 2.3 Is the potential prime acceptable?  				//  				if (!IsPrimeAcceptable (curVal' Context)) goto biNotPrime;    				//  				// STEP 2.4 Filter out all primes that pass this step with a primality test  				//  				if (PrimalityTest (curVal' Confidence)) return curVal;      				//  				// STEP 2.4  				//  			biNotPrime:  				pMod1 += 2;  				if (pMod1 >= primeProd1) pMod1 -= primeProd1;  				curVal.Incr2 ();  			}
Missing Default,Mono.Math,BigInteger,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\Mono.Math\BigInteger.cs,BigInteger,The following switch statement is missing a default case: switch (leftOver) {  			case 1: data [length-1] = (uint)inData [0]; break;  			case 2: data [length-1] = (uint)((inData [0] << 8) | inData [1]); break;  			case 3: data [length-1] = (uint)((inData [0] << 16) | (inData [1] << 8) | inData [2]); break;  			}
