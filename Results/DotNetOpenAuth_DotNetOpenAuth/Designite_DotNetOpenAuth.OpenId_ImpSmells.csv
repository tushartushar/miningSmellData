Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DotNetOpenAuth.OpenId,Realm,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,Contains,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.OpenId,UriDiscoveryService,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverAsync,Cyclomatic complexity of the method is 8
Complex Method,DotNetOpenAuth.OpenId.Extensions,ExtensionArgumentsManager,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ExtensionArgumentsManager.cs,CreateIncomingExtensions,Cyclomatic complexity of the method is 11
Complex Method,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsRequest.cs,AssembleProfileFields,Cyclomatic complexity of the method is 10
Complex Method,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,PolicyRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\PolicyRequest.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,PolicyResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\PolicyResponse.cs,Equals,Cyclomatic complexity of the method is 9
Long Parameter List,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,IdentifierDiscoveryResult,The method has 6 parameters. Parameters: providerEndpoint' claimedIdentifier' userSuppliedIdentifier' providerLocalIdentifier' servicePriority' uriPriority
Long Parameter List,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForClaimedIdentifier,The method has 5 parameters. Parameters: claimedIdentifier' providerLocalIdentifier' providerEndpoint' servicePriority' uriPriority
Long Parameter List,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForClaimedIdentifier,The method has 6 parameters. Parameters: claimedIdentifier' userSuppliedIdentifier' providerLocalIdentifier' providerEndpoint' servicePriority' uriPriority
Long Parameter List,DotNetOpenAuth.OpenId,HmacShaAssociation,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,Create,The method has 5 parameters. Parameters: protocol' associationType' handle' secret' totalLifeLength
Long Parameter List,DotNetOpenAuth.OpenId,HmacShaAssociation,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,TryFindBestAssociation,The method has 6 parameters. Parameters: protocol' highSecurityIsBetter' securityRequirements' requireMatchingDHSessionType' associationType' sessionType
Long Parameter List,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,The method has 5 parameters. Parameters: uri' requireSsl' hostFactories' cancellationToken' acceptTypes
Long Identifier,DotNetOpenAuth.Configuration,HostMetaDiscoveryElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\HostMetaDiscoveryElement.cs,,The length of the parameter EnableCertificateValidationCacheConfigName is 42.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdElement.cs,,The length of the parameter MaxAuthenticationTimePropertyName is 33.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdProviderSecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdProviderSecuritySettingsElement.cs,,The length of the parameter ProtectDownlevelReplayAttacksConfigName is 39.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdProviderSecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdProviderSecuritySettingsElement.cs,,The length of the parameter MinimumHashBitLengthConfigName is 30.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdProviderSecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdProviderSecuritySettingsElement.cs,,The length of the parameter MaximumHashBitLengthConfigName is 30.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdProviderSecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdProviderSecuritySettingsElement.cs,,The length of the parameter EncodeAssociationSecretsInHandlesConfigName is 43.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdProviderSecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdProviderSecuritySettingsElement.cs,,The length of the parameter UnsolicitedAssertionVerificationConfigName is 42.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartyElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartyElement.cs,,The length of the parameter PreserveUserSuppliedIdentifierConfigName is 40.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter MinimumRequiredOpenIdVersionConfigName is 38.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter MinimumHashBitLengthConfigName is 30.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter MaximumHashBitLengthConfigName is 30.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter RequireDirectedIdentityConfigName is 33.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter RejectUnsolicitedAssertionsConfigName is 37.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter RejectDelegatingIdentifiersConfigName is 37.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter IgnoreUnsignedExtensionsConfigName is 34.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter AllowDualPurposeIdentifiersConfigName is 37.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter AllowApproximateIdentifierDiscoveryConfigName is 45.
Long Identifier,DotNetOpenAuth.Configuration,OpenIdRelyingPartySecuritySettingsElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Configuration\OpenIdRelyingPartySecuritySettingsElement.cs,,The length of the parameter ProtectDownlevelReplayAttacksConfigName is 39.
Long Identifier,DotNetOpenAuth.OpenId,HmacShaAssociation,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,IsDHSessionCompatible,The length of the parameter associationSecretLengthInBytes is 30.
Long Identifier,DotNetOpenAuth.OpenId,Protocol,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Protocol.cs,,The length of the parameter ClaimedIdentifierServiceTypeURI is 31.
Long Identifier,DotNetOpenAuth.OpenId,Protocol,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Protocol.cs,,The length of the parameter ClaimedIdentifierForOPIdentifier is 32.
Long Identifier,DotNetOpenAuth.OpenId,Protocol,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Protocol.cs,,The length of the parameter MaximumUserAgentAuthenticationTime is 34.
Long Identifier,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,,The length of the parameter ClaimedIdentifierParameterName is 30.
Long Identifier,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,,The length of the parameter ReturnToSignatureParameterName is 30.
Long Identifier,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,,The length of the parameter ReturnToSignatureHandleParameterName is 36.
Long Identifier,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,AuthenticationPolicies,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\AuthenticationPolicies.cs,,The length of the parameter NoPersonallyIdentifiableInformation is 35.
Long Identifier,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,Constants,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\Constants.cs,,The length of the parameter AuthLevelNamespaceDeclarationPrefix is 35.
Long Identifier,DotNetOpenAuth.OpenId.RelyingParty,RelyingPartySecuritySettings,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\RelyingParty\RelyingPartySecuritySettings.cs,,The length of the parameter ProtectDownlevelReplayAttacksDefault is 36.
Long Identifier,DotNetOpenAuth.OpenId.Provider,ProviderSecuritySettings,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Provider\ProviderSecuritySettings.cs,,The length of the parameter ProtectDownlevelReplayAttacksDefault is 36.
Long Identifier,DotNetOpenAuth.OpenId.Provider,ProviderSecuritySettings,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Provider\ProviderSecuritySettings.cs,,The length of the parameter EncodeAssociationSecretsInHandlesDefault is 40.
Long Identifier,DotNetOpenAuth.OpenId.Provider,ProviderSecuritySettings,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Provider\ProviderSecuritySettings.cs,,The length of the parameter UnsolicitedAssertionVerificationDefault is 39.
Long Identifier,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,,The length of the parameter IdentifierDiscoveryCachePolicy is 30.
Long Statement,DotNetOpenAuth.OpenId,OpenIdXrdsHelperRelyingParty,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenIdXrdsHelperRelyingParty.cs,GenerateOPIdentifierServiceEndpoints,The length of the statement  "				   select IdentifierDiscoveryResult.CreateForProviderIdentifier(opIdentifier' providerDescription' service.Priority' uri.Priority); " is 128.
Long Statement,DotNetOpenAuth.OpenId,OpenIdXrdsHelperRelyingParty,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenIdXrdsHelperRelyingParty.cs,GenerateClaimedIdentifierServiceEndpoints,The length of the statement  "				   select IdentifierDiscoveryResult.CreateForClaimedIdentifier(claimedIdentifier' userSuppliedIdentifier' service.ProviderLocalIdentifier' providerEndpoint' service.Priority' uri.Priority); " is 186.
Long Statement,DotNetOpenAuth.OpenId,OpenIdXrdsHelperRelyingParty,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenIdXrdsHelperRelyingParty.cs,GenerateClaimedIdentifierServiceEndpoints,The length of the statement  "					ErrorUtilities.VerifyProtocol(service.Xrd.IsCanonicalIdVerified' XrdsStrings.CIDVerificationFailed' userSuppliedIdentifier); " is 124.
Long Statement,DotNetOpenAuth.OpenId,OpenIdXrdsHelperRelyingParty,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenIdXrdsHelperRelyingParty.cs,GenerateClaimedIdentifierServiceEndpoints,The length of the statement  "					yield return IdentifierDiscoveryResult.CreateForClaimedIdentifier(claimedIdentifier' userSuppliedIdentifier' service.ProviderLocalIdentifier' providerEndpoint' service.Priority' uri.Priority); " is 192.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForClaimedIdentifier,The length of the statement  "			return CreateForClaimedIdentifier(claimedIdentifier' null' providerLocalIdentifier' providerEndpoint' servicePriority' uriPriority); " is 132.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForClaimedIdentifier,The length of the statement  "			return new IdentifierDiscoveryResult(providerEndpoint' claimedIdentifier' userSuppliedIdentifier' providerLocalIdentifier' servicePriority' uriPriority); " is 153.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryServices,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryServices.cs,DiscoverAsync,The length of the statement  "					Logger.OpenId.InfoFormat("Further discovery on '{0}' was stopped by the {1} discovery service."' identifier' discoverer.GetType().Name); " is 136.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryServices,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryServices.cs,DiscoverAsync,The length of the statement  "				var opIdentifiers = results.Where(result => result.ClaimedIdentifier == result.Protocol.ClaimedIdentifierForOPIdentifier); " is 122.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryServices,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryServices.cs,DiscoverAsync,The length of the statement  "				var claimedIdentifiers = results.Where(result => result.ClaimedIdentifier != result.Protocol.ClaimedIdentifierForOPIdentifier); " is 127.
Long Statement,DotNetOpenAuth.OpenId,OpenIdUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\OpenIdUtilities.cs,FixDoublyUriDecodedBase64String,The length of the statement  "				Logger.OpenId.Error("Deserializing a corrupted token.  The OpenID Provider may have inappropriately decoded the return_to URL before sending it back to us."); " is 158.
Long Statement,DotNetOpenAuth.OpenId,OpenIdUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\OpenIdUtilities.cs,CreateHttpClient,The length of the statement  "			ErrorUtilities.VerifyProtocol(!requireSsl || sslRequiredSet' "Unable to set RequireSsl on message handler because no HttpMessageHandler was of type {0}."' typeof(UntrustedWebRequestHandler).FullName); " is 200.
Long Statement,DotNetOpenAuth.OpenId,Realm,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,Contains,The length of the statement  "				Debug.Assert(!string.IsNullOrEmpty(this.Host)' "The host part of the Regex should evaluate to at least one char for successful parsed trust roots."); " is 149.
Long Statement,DotNetOpenAuth.OpenId,Realm,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,DiscoverAsync,The length of the statement  "			DiscoveryResult yadisResult = await Yadis.DiscoverAsync(hostFactories' this.UriWithWildcardChangedToWww' false' cancellationToken); " is 131.
Long Statement,DotNetOpenAuth.OpenId,Realm,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,DiscoverAsync,The length of the statement  "				ErrorUtilities.VerifyProtocol(allowRedirects || yadisResult.NormalizedUri == yadisResult.RequestUri' OpenIdStrings.RealmCausedRedirectUponDiscovery' yadisResult.RequestUri); " is 173.
Long Statement,DotNetOpenAuth.OpenId,DiffieHellmanUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\DiffieHellmanUtilities.cs,Lookup,The length of the statement  "			// We COULD use just First instead of FirstOrDefault' but we want to throw ProtocolException instead of InvalidOperationException. " is 130.
Long Statement,DotNetOpenAuth.OpenId,DiffieHellmanUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\DiffieHellmanUtilities.cs,Lookup,The length of the statement  "			DHSha match = diffieHellmanSessionTypes.FirstOrDefault(dhsha => string.Equals(dhsha.GetName(protocol)' sessionType' StringComparison.Ordinal)); " is 143.
Long Statement,DotNetOpenAuth.OpenId,DiffieHellmanUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\DiffieHellmanUtilities.cs,SHAHashXorSecret,The length of the statement  "			ErrorUtilities.VerifyProtocol(sharedBlockHash.Length == plainOrEncryptedSecret.Length' OpenIdStrings.AssociationSecretHashLengthMismatch' plainOrEncryptedSecret.Length' sharedBlockHash.Length); " is 193.
Long Statement,DotNetOpenAuth.OpenId,HmacShaAssociation,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,Create,The length of the statement  "			HmacSha match = hmacShaAssociationTypes.FirstOrDefault(sha => string.Equals(sha.GetAssociationType(protocol)' associationType' StringComparison.Ordinal)); " is 154.
Long Statement,DotNetOpenAuth.OpenId,HmacShaAssociation,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,GetSecretLength,The length of the statement  "			HmacSha match = hmacShaAssociationTypes.FirstOrDefault(shaType => string.Equals(shaType.GetAssociationType(protocol)' associationType' StringComparison.Ordinal)); " is 162.
Long Statement,DotNetOpenAuth.OpenId,HmacShaAssociation,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,TryFindBestAssociation,The length of the statement  "			// We use AsEnumerable() to avoid VerificationException (http://stackoverflow.com/questions/478422/why-does-simple-array-and-linq-generate-verificationexception-operation-could-de) " is 180.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverAsync,The length of the statement  "			DiscoveryResult yadisResult = await Yadis.DiscoverAsync(this.HostFactories' uriIdentifier' identifier.IsDiscoverySecureEndToEnd' cancellationToken); " is 148.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverAsync,The length of the statement  "					var htmlEndpoints = new List<IdentifierDiscoveryResult>(DiscoverFromHtml(yadisResult.NormalizedUri' uriIdentifier' yadisResult.ResponseText)); " is 142.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverAsync,The length of the statement  "						endpoints.AddRange(htmlEndpoints.Where(ep => !uriIdentifier.IsDiscoverySecureEndToEnd || ep.ProviderEndpoint.IsTransportSecure())); " is 131.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverFromHtml,The length of the statement  "				var serverLinkTag = linkTags.WithAttribute("rel").FirstOrDefault(tag => Regex.IsMatch(tag.Attributes["rel"]' @"\b" + Regex.Escape(protocol.HtmlDiscoveryProviderKey) + @"\b"' RegexOptions.IgnoreCase)); " is 200.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverFromHtml,The length of the statement  "					var delegateLinkTag = linkTags.WithAttribute("rel").FirstOrDefault(tag => Regex.IsMatch(tag.Attributes["rel"]' @"\b" + Regex.Escape(protocol.HtmlDiscoveryLocalIdKey) + @"\b"' RegexOptions.IgnoreCase)); " is 201.
Long Statement,DotNetOpenAuth.OpenId,XriDiscoveryProxyService,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\XriDiscoveryProxyService.cs,DownloadXrdsAsync,The length of the statement  "			using (var xrdsResponse = await Yadis.RequestAsync(GetXrdsUrl(identifier)' identifier.IsDiscoverySecureEndToEnd' hostFactories' cancellationToken)) { " is 149.
Long Statement,DotNetOpenAuth.OpenId,XriDiscoveryProxyService,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\XriDiscoveryProxyService.cs,DownloadXrdsAsync,The length of the statement  "				ErrorUtilities.VerifyProtocol(xrdsResponse.Content != null' "XRDS request \"{0}\" returned no response."' GetXrdsUrl(identifier)); " is 130.
Long Statement,DotNetOpenAuth.OpenId,SecuritySettings,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\SecuritySettings.cs,IsAssociationInPermittedRange,The length of the statement  "			return association.HashBitLength >= this.MinimumHashBitLength && association.HashBitLength <= this.MaximumHashBitLength; " is 120.
Long Statement,DotNetOpenAuth.OpenId,UriIdentifier,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryCanonicalize,The length of the statement  "				uriBuilder.Scheme = uriBuilder.Scheme == roundTrippingHttpParser.RegisteredScheme ? publishableHttpParser.RegisteredScheme : publishableHttpsParser.RegisteredScheme; " is 165.
Long Statement,DotNetOpenAuth.OpenId,XriIdentifier,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\XriIdentifier.cs,Equals,The length of the statement  "				ErrorUtilities.VerifyInternal(!string.IsNullOrEmpty(objString)' "Identifier.ToString() returned a null or empty string."); " is 122.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "					ErrorUtilities.VerifyProtocol(op_endpoint != null' MessagingStrings.RequiredParametersMissing' message.GetType().Name' ProviderEndpointParameterName); " is 150.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "						ErrorUtilities.VerifyProtocol(claimedId != null' MessagingStrings.RequiredParametersMissing' message.GetType().Name' ClaimedIdentifierParameterName); " is 149.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,ProcessOutgoingMessageAsync,The length of the statement  "						ErrorUtilities.VerifyProtocol(!extensionManager.ContainsExtension(extension.TypeUri)' OpenIdStrings.ExtensionAlreadyAddedWithSameTypeURI' extension.TypeUri); " is 157.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,ProcessOutgoingMessageAsync,The length of the statement  "						Logger.OpenId.WarnFormat("Unexpected extension type {0} did not implement {1}."' protocolExtension.GetType()' typeof(IOpenIdMessageExtension).Name); " is 148.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,ProcessOutgoingMessageAsync,The length of the statement  "				bool includeOpenIdPrefix = baseMessageDictionary.Keys.Any(key => key.StartsWith(protocol.openid.Prefix' StringComparison.Ordinal)); " is 131.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "					Func<string' bool> isNotSigned = typeUri => !extendableMessage.Extensions.Cast<IOpenIdMessageExtension>().Any(ext => ext.TypeUri == typeUri); " is 141.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,GetExtensions,The length of the statement  "			var extensionManager = ExtensionArgumentsManager.CreateIncomingExtensions(this.GetExtensionsDictionary(message' ignoreUnsigned)); " is 129.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "				Logger.Bindings.DebugFormat("Verifying incoming {0} message signature of: {1}"' message.GetType().Name' signedMessage.Signature); " is 129.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "					ErrorUtilities.VerifyInternal(this.Channel != null' "Cannot verify private association signature because we don't have a channel."); " is 132.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "					protectionsApplied = await this.VerifySignatureByUnrecognizedHandleAsync(message' signedMessage' protectionsApplied' cancellationToken); " is 136.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,GetSignature,The length of the statement  "			Requires.That(!string.IsNullOrEmpty(signedMessage.SignedParameterOrder)' "signedMessage"' "SignedParameterOrder must not be null or empty."); " is 141.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,EnsureParametersRequiringSignatureAreSigned,The length of the statement  "			ErrorUtilities.VerifyInternal(partsRequiringProtection.All(name => name.StartsWith(protocol.openid.Prefix' StringComparison.Ordinal))' "Signing only works when the parameters start with the 'openid.' prefix."); " is 210.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,EnsureParametersRequiringSignatureAreSigned,The length of the statement  "			ErrorUtilities.VerifyProtocol(!unsignedParts.Any()' OpenIdStrings.SignatureDoesNotIncludeMandatoryParts' string.Join("' "' unsignedParts.ToArray())); " is 149.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetBytes,The length of the statement  "							throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' OpenIdStrings.InvalidCharacterInKeyValueFormInput' pair.Key)); " is 132.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetBytes,The length of the statement  "							throw new ArgumentException(string.Format(CultureInfo.CurrentCulture' OpenIdStrings.InvalidCharacterInKeyValueFormInput' pair.Value)); " is 134.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The length of the statement  "						ErrorUtilities.VerifyFormat(!(char.IsWhiteSpace(parts[0]' parts[0].Length - 1) || char.IsWhiteSpace(parts[1]' 0))' OpenIdStrings.InvalidCharacterInKeyValueFormInput' ' '' line_num' line); " is 187.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The length of the statement  "					ErrorUtilities.VerifyFormat(reader.BaseStream.ReadByte() == '\n'' OpenIdStrings.InvalidKeyValueFormCharacterMissing' "\\n"' line_num' line); " is 140.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,ProcessOutgoingMessageAsync,The length of the statement  "				var cryptoKeyPair = this.cryptoKeyStore.GetCurrentKey(SecretUri.AbsoluteUri' OpenIdElement.Configuration.MaxAuthenticationTime); " is 128.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "					response.ReturnToParametersSignatureValidated = MessagingUtilities.AreEquivalentConstantTime(actualBytes' expectedBytes); " is 121.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,GetReturnToSignature,The length of the statement  "			Logger.Bindings.DebugFormat("ReturnTo signed data: {0}{1}"' Environment.NewLine' sortedReturnToParameters.ToStringDeferred()); " is 126.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,GetReturnToSignature,The length of the statement  "					cryptoKey = this.cryptoKeyStore.GetKey(SecretUri.AbsoluteUri' returnToParameters[ReturnToSignatureHandleParameterName]); " is 120.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SkipSecurityBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SkipSecurityBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "				Logger.Bindings.DebugFormat("Skipped security checks of incoming {0} message for preview purposes."' message.GetType().Name); " is 125.
Long Statement,DotNetOpenAuth.OpenId.Extensions,AliasManager,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AliasManager.cs,AssignNewAlias,The length of the statement  "			ErrorUtilities.VerifyInternal(!this.typeUriToAliasMap.ContainsKey(typeUri)' "Oops!  This type URI already has an alias!"); " is 122.
Long Statement,DotNetOpenAuth.OpenId.Extensions,ExtensionArgumentsManager,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ExtensionArgumentsManager.cs,CreateIncomingExtensions,The length of the statement  "					string key = periodIndex >= 0 ? pair.Key.Substring(mgr.protocol.openid.Prefix.Length + possibleAlias.Length + 1) : string.Empty; " is 128.
Long Statement,DotNetOpenAuth.OpenId.Extensions,ExtensionArgumentsManager,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ExtensionArgumentsManager.cs,AddExtensionArguments,The length of the statement  "			ErrorUtilities.VerifyProtocol(extensionArgs.Count == 0' OpenIdStrings.ExtensionAlreadyAddedWithSameTypeURI' extensionTypeUri); " is 126.
Long Statement,DotNetOpenAuth.OpenId.Extensions.AttributeExchange,FetchRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AttributeExchange\FetchRequest.cs,EnsureValidMessage,The length of the statement  "				Logger.OpenId.ErrorFormat("The AX fetch request update_url parameter was not absolute ('{0}').  Ignoring value."' this.UpdateUrl); " is 130.
Long Statement,DotNetOpenAuth.OpenId.Extensions.AttributeExchange,FetchResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AttributeExchange\FetchResponse.cs,EnsureValidMessage,The length of the statement  "				Logger.OpenId.ErrorFormat("The AX fetch response update_url parameter was not absolute ('{0}').  Ignoring value."' this.UpdateUrl); " is 131.
Long Statement,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsRequest.cs,ToString,The length of the statement  "			return string.Format(CultureInfo.CurrentCulture' format' this.Nickname' this.Email' this.FullName' this.BirthDate' this.Gender' this.PostalCode' this.Country' this.Language' this.TimeZone); " is 189.
Long Statement,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,DateTimeEncoder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\DateTimeEncoder.cs,Decode,The length of the statement  "			if (DateTime.TryParse(value' CultureInfo.InvariantCulture' DateTimeStyles.AdjustToUniversal' out dateTime) && dateTime.Kind == DateTimeKind.Utc) { // may be unspecified per our option above " is 189.
Long Statement,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,PolicyRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\PolicyRequest.cs,OnSending,The length of the statement  "				extraData.Add(Constants.RequestParameters.PreferredAuthLevelTypes' SerializeAuthLevels(this.PreferredAuthLevelTypes' authLevelAliases)); " is 136.
Long Statement,DotNetOpenAuth.OpenId.Messages,CheckIdRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\CheckIdRequest.cs,EnsureValidMessage,The length of the statement  "					(this.LocalIdentifier == this.Protocol.ClaimedIdentifierForOPIdentifier) == (this.ClaimedIdentifier == this.Protocol.ClaimedIdentifierForOPIdentifier)' " is 151.
Long Statement,DotNetOpenAuth.OpenId.Messages,IndirectSignedResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\IndirectSignedResponse.cs,IsQuerySubsetOf,The length of the statement  "			return subsetArgs.Keys.Cast<string>().All(key => string.Equals(subsetArgs[key]' supersetArgs[key]' StringComparison.Ordinal)); " is 126.
Long Statement,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,EnsureValidMessage,The length of the statement  "			ErrorUtilities.VerifyProtocol(string.Equals(this.Mode' Protocol.Args.Mode.setup_needed' StringComparison.Ordinal) || string.Equals(this.Mode' Protocol.Args.Mode.cancel' StringComparison.Ordinal)' MessagingStrings.UnexpectedMessagePartValue' Protocol.openid.mode' this.Mode); " is 274.
Long Statement,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,EnsureValidMessage,The length of the statement  "				ErrorUtilities.VerifyProtocol(this.UserSetupUrl != null' OpenIdStrings.UserSetupUrlRequiredInImmediateNegativeResponse); " is 120.
Long Statement,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,ConstructUserSetupUrlAsync,The length of the statement  "			var setupRequest = new CheckIdRequest(immediateRequest.Version' immediateRequest.Recipient' AuthenticationRequestMode.Setup); " is 125.
Long Statement,DotNetOpenAuth.OpenId.Messages,SignedResponseRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\SignedResponseRequest.cs,EnsureValidMessage,The length of the statement  "				ErrorUtilities.VerifyProtocol(this.Realm.Contains(this.ReturnTo)' OpenIdStrings.ReturnToNotUnderRealm' this.ReturnTo' this.Realm); " is 130.
Long Statement,DotNetOpenAuth.OpenId.Messages,SignedResponseRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\SignedResponseRequest.cs,GetMode,The length of the statement  "			return mode == AuthenticationRequestMode.Immediate ? protocol.Args.Mode.checkid_immediate : protocol.Args.Mode.checkid_setup; " is 125.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateDiffieHellmanRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateDiffieHellmanRequest.cs,InitializeRequest,The length of the statement  "				throw new InvalidOperationException(string.Format(CultureInfo.CurrentCulture' OpenIdStrings.DiffieHellmanRequiredPropertiesNotSet' string.Join("' "' new string[] { "DiffieHellmanModulus"' "DiffieHellmanGen" }))); " is 212.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateDiffieHellmanRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateDiffieHellmanRequest.cs,InitializeRequest,The length of the statement  "			this.Algorithm = new DiffieHellmanManaged(this.DiffieHellmanModulus ?? DefaultMod' this.DiffieHellmanGen ?? DefaultGen' DefaultX); " is 130.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateRequest.cs,EnsureValidMessage,The length of the statement  "				!string.Equals(this.SessionType' Protocol.Args.SessionType.NoEncryption' StringComparison.Ordinal) || this.Recipient.IsTransportSecure()' " is 137.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateSuccessfulResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateSuccessfulResponse.cs,EnsureValidMessage,The length of the statement  "					string.IsNullOrEmpty(this.SessionType) || string.Equals(this.SessionType' this.Protocol.Args.SessionType.DH_SHA1' StringComparison.Ordinal)' " is 140.
Long Statement,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The length of the statement  "				response = await RequestAsync(uri' requireSsl' hostFactories' cancellationToken' ContentTypes.Html' ContentTypes.XHtml' ContentTypes.Xrds); " is 139.
Long Statement,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The length of the statement  "					Logger.Yadis.ErrorFormat("HTTP error {0} {1} while performing discovery on {2}."' (int)response.StatusCode' response.StatusCode' uri); " is 134.
Long Statement,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The length of the statement  "				if (url == null && contentType != null && (contentType.MediaType == ContentTypes.Html || contentType.MediaType == ContentTypes.XHtml)) { " is 136.
Long Statement,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The length of the statement  "							Logger.Yadis.ErrorFormat("HTTP error {0} {1} while performing discovery on {2}."' (int)response2.StatusCode' response2.StatusCode' uri); " is 136.
Long Statement,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,The length of the statement  "					// http://stackoverflow.com/questions/14103154/how-to-determine-if-an-httpresponsemessage-was-fulfilled-from-cache-using-httpcl " is 127.
Long Statement,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,The length of the statement  "						Logger.Messaging.ErrorFormat("An HTTP {0} response was obtained from the cache.  Retrying with cache disabled."' response.StatusCode); " is 134.
Long Statement,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,The length of the statement  "						using (var nonCachingHttpClient = hostFactories.CreateHttpClient(requireSsl' new RequestCachePolicy(RequestCacheLevel.Reload))) { " is 129.
Complex Conditional,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,SendAsync,The conditional expression  "response.StatusCode == HttpStatusCode.MovedPermanently || response.StatusCode == HttpStatusCode.Redirect  						|| response.StatusCode == HttpStatusCode.RedirectMethod  						|| response.StatusCode == HttpStatusCode.RedirectKeepVerb"  is complex.
Complex Conditional,DotNetOpenAuth.Yadis,Yadis,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The conditional expression  "url == null && contentType != null && (contentType.MediaType == ContentTypes.Html || contentType.MediaType == ContentTypes.XHtml)"  is complex.
Magic Number,DotNetOpenAuth.OpenId,Association,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Association.cs,Equals,The following statement contains a magic number: if (a.Handle != this.Handle ||  				a.Issued != this.Issued ||  				!MessagingUtilities.Equals(a.TotalLifeLength' this.TotalLifeLength' TimeSpan.FromSeconds(2))) {  				return false;  			}
Magic Number,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,GetEndpointPrecedenceOrderByServiceType,The following statement contains a magic number: if (endpoint.Capabilities.Contains(Protocol.V11.ClaimedIdentifierServiceTypeURI)) {  				return 2;  			}
Magic Number,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,GetEndpointPrecedenceOrderByServiceType,The following statement contains a magic number: if (endpoint.Capabilities.Contains(Protocol.V10.ClaimedIdentifierServiceTypeURI)) {  				return 3;  			}
Magic Number,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,GetEndpointPrecedenceOrderByServiceType,The following statement contains a magic number: return 10;
Magic Number,DotNetOpenAuth.OpenId,OpenIdUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\OpenIdUtilities.cs,GenerateRandomAssociationHandle,The following statement contains a magic number: string uniq = MessagingUtilities.GetCryptoRandomDataAsBase64(4);
Magic Number,DotNetOpenAuth.OpenId,DiffieHellmanUtilities,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\DiffieHellmanUtilities.cs,EnsurePositive,The following statement contains a magic number: if (i > 127) {  				byte[] nowPositive = new byte[inputBytes.Length + 1];  				nowPositive[0] = 0;  				inputBytes.CopyTo(nowPositive' 1);  				return nowPositive;  			}
Magic Number,DotNetOpenAuth.OpenId,HmacShaAssociation,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,TryFindBestAssociation,The following statement contains a magic number: foreach (HmacSha sha in preferredOrder) {  				int hashSizeInBits = sha.SecretLength * 8;  				if (hashSizeInBits > securityRequirements.MaximumHashBitLength ||  					hashSizeInBits < securityRequirements.MinimumHashBitLength) {  					continue;  				}    				if (OpenIdUtilities.IsDiffieHellmanPresent) {  					sessionType = DiffieHellmanUtilities.GetNameForSize(protocol' hashSizeInBits);  				} else {  					sessionType = requireMatchingDHSessionType ? null : protocol.Args.SessionType.NoEncryption;  				}    				if (requireMatchingDHSessionType && sessionType == null) {  					continue;  				}  				associationType = sha.GetAssociationType(protocol);  				if (associationType == null) {  					continue;  				}    				return true;  			}
Magic Number,DotNetOpenAuth.OpenId,HmacShaAssociation,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,IsDHSessionCompatible,The following statement contains a magic number: if (OpenIdUtilities.IsDiffieHellmanPresent) {  				// When there _is_ a DH session' it must match in hash length with the association type.  				int associationSecretLengthInBytes = GetSecretLength(protocol' associationType);  				int sessionHashLengthInBytes = DiffieHellmanUtilities.Lookup(protocol' sessionType).HashSize / 8;  				return associationSecretLengthInBytes == sessionHashLengthInBytes;  			} else {  				return false;  			}
Magic Number,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,The following statement contains a magic number: if (IPAddress.TryParse(uri.DnsSafeHost' out hostIPAddress)) {  				byte[] addressBytes = hostIPAddress.GetAddressBytes();    				// The host is actually an IP address.  				switch (hostIPAddress.AddressFamily) {  					case System.Net.Sockets.AddressFamily.InterNetwork:  						if (addressBytes[0] == 127 || addressBytes[0] == 10) {  							return failsUnlessWhitelisted("it is a loopback address.");  						}  						break;  					case System.Net.Sockets.AddressFamily.InterNetworkV6:  						if (IsIPv6Loopback(hostIPAddress)) {  							return failsUnlessWhitelisted("it is a loopback address.");  						}  						break;  					default:  						return failsUnlessWhitelisted("it does not use an IPv4 or IPv6 address.");  				}  			} else {  				// The host is given by name.  We require names to contain periods to  				// help make sure it's not an internal address.  				if (!uri.Host.Contains(".")) {  					return failsUnlessWhitelisted("it does not contain a period in the host name.");  				}  			}
Magic Number,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,The following statement contains a magic number: if (IPAddress.TryParse(uri.DnsSafeHost' out hostIPAddress)) {  				byte[] addressBytes = hostIPAddress.GetAddressBytes();    				// The host is actually an IP address.  				switch (hostIPAddress.AddressFamily) {  					case System.Net.Sockets.AddressFamily.InterNetwork:  						if (addressBytes[0] == 127 || addressBytes[0] == 10) {  							return failsUnlessWhitelisted("it is a loopback address.");  						}  						break;  					case System.Net.Sockets.AddressFamily.InterNetworkV6:  						if (IsIPv6Loopback(hostIPAddress)) {  							return failsUnlessWhitelisted("it is a loopback address.");  						}  						break;  					default:  						return failsUnlessWhitelisted("it does not use an IPv4 or IPv6 address.");  				}  			} else {  				// The host is given by name.  We require names to contain periods to  				// help make sure it's not an internal address.  				if (!uri.Host.Contains(".")) {  					return failsUnlessWhitelisted("it does not contain a period in the host name.");  				}  			}
Magic Number,DotNetOpenAuth.OpenId,SecuritySettings,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\SecuritySettings.cs,IsAssociationInPermittedRange,The following statement contains a magic number: int lengthInBits = HmacShaAssociation.GetSecretLength(protocol' associationType) * 8;
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: try {  				UriParser.Register(roundTrippingHttpParser' "dnoarthttp"' 80);  				UriParser.Register(roundTrippingHttpsParser' "dnoarthttps"' 443);  				UriParser.Register(publishableHttpParser' "dnoahttp"' 80);  				UriParser.Register(publishableHttpsParser' "dnoahttps"' 443);  				roundTrippingHttpParser.Initialize(false);  				roundTrippingHttpsParser.Initialize(false);  				publishableHttpParser.Initialize(true);  				publishableHttpsParser.Initialize(true);  				schemeSubstitution = true;  				Logger.OpenId.Debug(".NET Uri class path compression overridden.");  				Reporting.RecordFeatureUse("FullTrust");  			} catch (SecurityException) {  				// We must be running in partial trust.  Nothing more we can do.  				Logger.OpenId.Warn("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  				Reporting.RecordFeatureUse("PartialTrust");  			} catch (FieldAccessException) { // one customer reported getting this exception  				// We must be running in partial trust.  Nothing more we can do.  				Logger.OpenId.Warn("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  				Reporting.RecordFeatureUse("PartialTrust");  			}
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: try {  				UriParser.Register(roundTrippingHttpParser' "dnoarthttp"' 80);  				UriParser.Register(roundTrippingHttpsParser' "dnoarthttps"' 443);  				UriParser.Register(publishableHttpParser' "dnoahttp"' 80);  				UriParser.Register(publishableHttpsParser' "dnoahttps"' 443);  				roundTrippingHttpParser.Initialize(false);  				roundTrippingHttpsParser.Initialize(false);  				publishableHttpParser.Initialize(true);  				publishableHttpsParser.Initialize(true);  				schemeSubstitution = true;  				Logger.OpenId.Debug(".NET Uri class path compression overridden.");  				Reporting.RecordFeatureUse("FullTrust");  			} catch (SecurityException) {  				// We must be running in partial trust.  Nothing more we can do.  				Logger.OpenId.Warn("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  				Reporting.RecordFeatureUse("PartialTrust");  			} catch (FieldAccessException) { // one customer reported getting this exception  				// We must be running in partial trust.  Nothing more we can do.  				Logger.OpenId.Warn("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  				Reporting.RecordFeatureUse("PartialTrust");  			}
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: try {  				UriParser.Register(roundTrippingHttpParser' "dnoarthttp"' 80);  				UriParser.Register(roundTrippingHttpsParser' "dnoarthttps"' 443);  				UriParser.Register(publishableHttpParser' "dnoahttp"' 80);  				UriParser.Register(publishableHttpsParser' "dnoahttps"' 443);  				roundTrippingHttpParser.Initialize(false);  				roundTrippingHttpsParser.Initialize(false);  				publishableHttpParser.Initialize(true);  				publishableHttpsParser.Initialize(true);  				schemeSubstitution = true;  				Logger.OpenId.Debug(".NET Uri class path compression overridden.");  				Reporting.RecordFeatureUse("FullTrust");  			} catch (SecurityException) {  				// We must be running in partial trust.  Nothing more we can do.  				Logger.OpenId.Warn("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  				Reporting.RecordFeatureUse("PartialTrust");  			} catch (FieldAccessException) { // one customer reported getting this exception  				// We must be running in partial trust.  Nothing more we can do.  				Logger.OpenId.Warn("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  				Reporting.RecordFeatureUse("PartialTrust");  			}
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: try {  				UriParser.Register(roundTrippingHttpParser' "dnoarthttp"' 80);  				UriParser.Register(roundTrippingHttpsParser' "dnoarthttps"' 443);  				UriParser.Register(publishableHttpParser' "dnoahttp"' 80);  				UriParser.Register(publishableHttpsParser' "dnoahttps"' 443);  				roundTrippingHttpParser.Initialize(false);  				roundTrippingHttpsParser.Initialize(false);  				publishableHttpParser.Initialize(true);  				publishableHttpsParser.Initialize(true);  				schemeSubstitution = true;  				Logger.OpenId.Debug(".NET Uri class path compression overridden.");  				Reporting.RecordFeatureUse("FullTrust");  			} catch (SecurityException) {  				// We must be running in partial trust.  Nothing more we can do.  				Logger.OpenId.Warn("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  				Reporting.RecordFeatureUse("PartialTrust");  			} catch (FieldAccessException) { // one customer reported getting this exception  				// We must be running in partial trust.  Nothing more we can do.  				Logger.OpenId.Warn("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  				Reporting.RecordFeatureUse("PartialTrust");  			}
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryRequireSsl,The following statement contains a magic number: if (this.SchemeImplicitlyPrepended) {  				UriBuilder newIdentifierUri = new UriBuilder(this.Uri);  				newIdentifierUri.Scheme = Uri.UriSchemeHttps;  				if (newIdentifierUri.Port == 80) {  					newIdentifierUri.Port = 443;  				}  				secureIdentifier = new UriIdentifier(newIdentifierUri.Uri' true);  				return true;  			}
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryRequireSsl,The following statement contains a magic number: if (this.SchemeImplicitlyPrepended) {  				UriBuilder newIdentifierUri = new UriBuilder(this.Uri);  				newIdentifierUri.Scheme = Uri.UriSchemeHttps;  				if (newIdentifierUri.Port == 80) {  					newIdentifierUri.Port = 443;  				}  				secureIdentifier = new UriIdentifier(newIdentifierUri.Uri' true);  				return true;  			}
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,ProcessOutgoingMessageAsync,The following statement contains a magic number: if (request != null && request.Version.Major < 2) {  				request.AddReturnToArguments(ProviderEndpointParameterName' request.Recipient.AbsoluteUri);    				CheckIdRequest authRequest = request as CheckIdRequest;  				if (authRequest != null) {  					request.AddReturnToArguments(ClaimedIdentifierParameterName' authRequest.ClaimedIdentifier);  				}    				return NoneTask;  			}
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,ProcessIncomingMessageAsync,The following statement contains a magic number: if (response != null && response.Version.Major < 2) {  				// GetReturnToArgument may return parameters that are not signed'  				// but we must allow for that since in OpenID 1.x' a stateless RP has   				// no way to preserve the provider endpoint and claimed identifier otherwise.    				// We'll verify the positive assertion later in the   				// RelyingParty.PositiveAuthenticationResponse constructor anyway.  				// If this is a 1.0 OP signed response without these parameters then we didn't initiate  				// the request 'and since 1.0 OPs are not supposed to be able to send unsolicited   				// assertions it's an invalid case that we throw an exception for.  				if (response.ProviderEndpoint == null) {  					string op_endpoint = response.GetReturnToArgument(ProviderEndpointParameterName);  					ErrorUtilities.VerifyProtocol(op_endpoint != null' MessagingStrings.RequiredParametersMissing' message.GetType().Name' ProviderEndpointParameterName);  					response.ProviderEndpoint = new Uri(op_endpoint);  				}    				PositiveAssertionResponse authResponse = response as PositiveAssertionResponse;  				if (authResponse != null) {  					if (authResponse.ClaimedIdentifier == null) {  						string claimedId = response.GetReturnToArgument(ClaimedIdentifierParameterName);  						ErrorUtilities.VerifyProtocol(claimedId != null' MessagingStrings.RequiredParametersMissing' message.GetType().Name' ClaimedIdentifierParameterName);  						authResponse.ClaimedIdentifier = claimedId;  					}  				}    				return NoneTask;  			}
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The following statement contains a magic number: using (StreamReader reader = new StreamReader(data' textEncoding)) {  				var dict = new Dictionary<string' string>();  				int line_num = 0;  				string line;  				while ((line = await reader.ReadLineAsync()) != null) {  					cancellationToken.ThrowIfCancellationRequested();  					line_num++;  					if (this.ConformanceLevel == KeyValueFormConformanceLevel.Loose) {  						line = line.Trim();  						if (line.Length == 0) {  							continue;  						}  					}  					string[] parts = line.Split(new[] { ':' }' 2);  					ErrorUtilities.VerifyFormat(parts.Length == 2' OpenIdStrings.InvalidKeyValueFormCharacterMissing' ':'' line_num' line);  					if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  						ErrorUtilities.VerifyFormat(!(char.IsWhiteSpace(parts[0]' parts[0].Length - 1) || char.IsWhiteSpace(parts[1]' 0))' OpenIdStrings.InvalidCharacterInKeyValueFormInput' ' '' line_num' line);  					}  					if (this.ConformanceLevel < KeyValueFormConformanceLevel.OpenId20) {  						parts[0] = parts[0].Trim();  						parts[1] = parts[1].Trim();  					}    					// calling Add method will throw if a key is encountered twice'  					// which we should do.  					dict.Add(parts[0]' parts[1]);  				}  				if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  					reader.BaseStream.Seek(-1' SeekOrigin.End);  					ErrorUtilities.VerifyFormat(reader.BaseStream.ReadByte() == '\n'' OpenIdStrings.InvalidKeyValueFormCharacterMissing' "\\n"' line_num' line);  				}  				return dict;  			}
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The following statement contains a magic number: using (StreamReader reader = new StreamReader(data' textEncoding)) {  				var dict = new Dictionary<string' string>();  				int line_num = 0;  				string line;  				while ((line = await reader.ReadLineAsync()) != null) {  					cancellationToken.ThrowIfCancellationRequested();  					line_num++;  					if (this.ConformanceLevel == KeyValueFormConformanceLevel.Loose) {  						line = line.Trim();  						if (line.Length == 0) {  							continue;  						}  					}  					string[] parts = line.Split(new[] { ':' }' 2);  					ErrorUtilities.VerifyFormat(parts.Length == 2' OpenIdStrings.InvalidKeyValueFormCharacterMissing' ':'' line_num' line);  					if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  						ErrorUtilities.VerifyFormat(!(char.IsWhiteSpace(parts[0]' parts[0].Length - 1) || char.IsWhiteSpace(parts[1]' 0))' OpenIdStrings.InvalidCharacterInKeyValueFormInput' ' '' line_num' line);  					}  					if (this.ConformanceLevel < KeyValueFormConformanceLevel.OpenId20) {  						parts[0] = parts[0].Trim();  						parts[1] = parts[1].Trim();  					}    					// calling Add method will throw if a key is encountered twice'  					// which we should do.  					dict.Add(parts[0]' parts[1]);  				}  				if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  					reader.BaseStream.Seek(-1' SeekOrigin.End);  					ErrorUtilities.VerifyFormat(reader.BaseStream.ReadByte() == '\n'' OpenIdStrings.InvalidKeyValueFormCharacterMissing' "\\n"' line_num' line);  				}  				return dict;  			}
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,OpenIdChannel,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\OpenIdChannel.cs,OnReceivingDirectResponse,The following statement contains a magic number: if (message.Version.Major >= 2) {  				var httpDirectResponse = message as IHttpDirectResponse;  				if (httpDirectResponse != null) {  					ErrorUtilities.VerifyProtocol(  						httpDirectResponse.HttpStatusCode == response.StatusCode'  						MessagingStrings.UnexpectedHttpStatusCode'  						(int)httpDirectResponse.HttpStatusCode'  						(int)response.StatusCode);  				}  			}
Magic Number,DotNetOpenAuth.OpenId.Extensions,ExtensionArgumentsManager,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ExtensionArgumentsManager.cs,CreateIncomingExtensions,The following statement contains a magic number: if (mgr.protocol.Version.Major < 2) {  				foreach (var pair in typeUriToAliasAffinity) {  					if (!mgr.aliasManager.IsAliasAssignedTo(pair.Key) &&  						!mgr.aliasManager.IsAliasUsed(pair.Value)) {  						mgr.aliasManager.SetAlias(pair.Value' pair.Key);  					}  				}  			}
Magic Number,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsRequest,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsRequest.cs,AssembleProfileFields,The following statement contains a magic number: List<string> fields = new List<string>(10);
Magic Number,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsResponse.cs,InitializeJavaScriptData,The following statement contains a magic number: var sreg = new Dictionary<string' string>(15);
Magic Number,DotNetOpenAuth.OpenId.RelyingParty,RelyingPartySecuritySettings,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\RelyingParty\RelyingPartySecuritySettings.cs,RelyingPartySecuritySettings,The following statement contains a magic number: this.PrivateSecretMaximumAge = TimeSpan.FromDays(7);
Magic Number,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,EnsureValidMessage,The following statement contains a magic number: if (this.Immediate && Protocol.Version.Major < 2) {  				ErrorUtilities.VerifyProtocol(this.UserSetupUrl != null' OpenIdStrings.UserSetupUrlRequiredInImmediateNegativeResponse);  			}
Magic Number,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,CreateAsync,The following statement contains a magic number: if (result.Version.Major < 2 && request.Immediate && channel != null) {  				// All requests are CheckIdRequests in OpenID 1.x' so this cast should be safe.  				result.UserSetupUrl = await ConstructUserSetupUrlAsync((CheckIdRequest)request' channel' cancellationToken);  			}
Magic Number,DotNetOpenAuth.OpenId.Messages,AssociateSuccessfulResponse,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateSuccessfulResponse.cs,EnsureValidMessage,The following statement contains a magic number: if (this.Version.Major < 2) {  				ErrorUtilities.VerifyProtocol(  					string.IsNullOrEmpty(this.SessionType) || string.Equals(this.SessionType' this.Protocol.Args.SessionType.DH_SHA1' StringComparison.Ordinal)'  					MessagingStrings.UnexpectedMessagePartValueForConstant'  					GetType().Name'  					Protocol.openid.session_type'  					this.Protocol.Args.SessionType.DH_SHA1'  					this.SessionType);  			}
Magic Number,DotNetOpenAuth.Xrds,XrdElement,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Xrds\XrdElement.cs,SearchForServiceTypeUris,The following statement contains a magic number: xpath.Length -= 4;
Missing Default,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,GenderEncoder,C:\repos\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\GenderEncoder.cs,Encode,The following switch statement is missing a default case: switch (gender.Value) {  					case Gender.Male: return Constants.Genders.Male;  					case Gender.Female: return Constants.Genders.Female;  				}
