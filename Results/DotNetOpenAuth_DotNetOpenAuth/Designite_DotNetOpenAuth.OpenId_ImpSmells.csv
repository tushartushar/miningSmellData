Implementation smell,Namespace,Class,File,Method,Description
Complex Method,DotNetOpenAuth.OpenId,Realm,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,Contains,Cyclomatic complexity of the method is 12
Complex Method,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,Cyclomatic complexity of the method is 13
Complex Method,DotNetOpenAuth.OpenId,UriDiscoveryService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverAsync,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,GetExtensions,Cyclomatic complexity of the method is 8
Complex Method,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetBytes,Cyclomatic complexity of the method is 8
Complex Method,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.OpenId.Extensions,ExtensionArgumentsManager,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ExtensionArgumentsManager.cs,CreateIncomingExtensions,Cyclomatic complexity of the method is 11
Complex Method,DotNetOpenAuth.OpenId.Extensions,OpenIdExtensionsInteropHelper,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\OpenIdExtensionsInteropHelper.cs,FetchAttribute,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.OpenId.Extensions.AttributeExchange,AXUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AttributeExchange\AXUtilities.cs,DeserializeAttributes,Cyclomatic complexity of the method is 8
Complex Method,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsRequest.cs,SetProfileRequestFromList,Cyclomatic complexity of the method is 33
Complex Method,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsRequest.cs,AssembleProfileFields,Cyclomatic complexity of the method is 10
Complex Method,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,PolicyRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\PolicyRequest.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,PolicyResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\PolicyResponse.cs,Equals,Cyclomatic complexity of the method is 9
Complex Method,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,Cyclomatic complexity of the method is 13
Complex Method,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,Cyclomatic complexity of the method is 8
Complex Method,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,IsXrdsDocumentAsync,Cyclomatic complexity of the method is 8
Long Parameter List,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,IdentifierDiscoveryResult,The method has 6 parameters.
Long Parameter List,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForClaimedIdentifier,The method has 5 parameters.
Long Parameter List,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForClaimedIdentifier,The method has 6 parameters.
Long Parameter List,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,Create,The method has 5 parameters.
Long Parameter List,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,TryFindBestAssociation,The method has 6 parameters.
Long Parameter List,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,The method has 5 parameters.
Long Identifier,DotNetOpenAuth.OpenId,ProviderEndpointDescription,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ProviderEndpointDescription.cs,ProviderEndpointDescription,The length of the parameter claimedIdentifierProviderVersion is 32.
Long Identifier,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,IsDHSessionCompatible,The length of the parameter associationSecretLengthInBytes is 30.
Long Statement,DotNetOpenAuth.OpenId,OpenIdXrdsHelperRelyingParty,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenIdXrdsHelperRelyingParty.cs,GenerateOPIdentifierServiceEndpoints,The length of the statement  "	select IdentifierDiscoveryResult.CreateForProviderIdentifier (opIdentifier' providerDescription' service.Priority' uri.Priority); " is 129.
Long Statement,DotNetOpenAuth.OpenId,OpenIdXrdsHelperRelyingParty,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenIdXrdsHelperRelyingParty.cs,GenerateClaimedIdentifierServiceEndpoints,The length of the statement  "	select IdentifierDiscoveryResult.CreateForClaimedIdentifier (claimedIdentifier' userSuppliedIdentifier' service.ProviderLocalIdentifier' providerEndpoint' service.Priority' uri.Priority); " is 187.
Long Statement,DotNetOpenAuth.OpenId,OpenIdXrdsHelperRelyingParty,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenIdXrdsHelperRelyingParty.cs,GenerateClaimedIdentifierServiceEndpoints,The length of the statement  "			ErrorUtilities.VerifyProtocol (service.Xrd.IsCanonicalIdVerified' XrdsStrings.CIDVerificationFailed' userSuppliedIdentifier); " is 125.
Long Statement,DotNetOpenAuth.OpenId,OpenIdXrdsHelperRelyingParty,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenIdXrdsHelperRelyingParty.cs,GenerateClaimedIdentifierServiceEndpoints,The length of the statement  "			yield return IdentifierDiscoveryResult.CreateForClaimedIdentifier (claimedIdentifier' userSuppliedIdentifier' service.ProviderLocalIdentifier' providerEndpoint' service.Priority' uri.Priority); " is 193.
Long Statement,DotNetOpenAuth.OpenId,Association,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Association.cs,Equals,The length of the statement  "	if (a.Handle != this.Handle || a.Issued != this.Issued || !MessagingUtilities.Equals (a.TotalLifeLength' this.TotalLifeLength' TimeSpan.FromSeconds (2))) { " is 155.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,Equals,The length of the statement  "	return this.ClaimedIdentifier == other.ClaimedIdentifier && this.ProviderEndpoint == other.ProviderEndpoint && this.ProviderLocalIdentifier == other.ProviderLocalIdentifier && this.Protocol.EqualsPractically (other.Protocol); " is 225.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForProviderIdentifier,The length of the statement  "	return new IdentifierDiscoveryResult (providerEndpoint' protocol.ClaimedIdentifierForOPIdentifier' providerIdentifier' protocol.ClaimedIdentifierForOPIdentifier' servicePriority' uriPriority); " is 192.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForClaimedIdentifier,The length of the statement  "	return CreateForClaimedIdentifier (claimedIdentifier' null' providerLocalIdentifier' providerEndpoint' servicePriority' uriPriority); " is 133.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,CreateForClaimedIdentifier,The length of the statement  "	return new IdentifierDiscoveryResult (providerEndpoint' claimedIdentifier' userSuppliedIdentifier' providerLocalIdentifier' servicePriority' uriPriority); " is 154.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryServices,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryServices.cs,DiscoverAsync,The length of the statement  "			Logger.OpenId.InfoFormat ("Further discovery on '{0}' was stopped by the {1} discovery service."' identifier' discoverer.GetType ().Name); " is 138.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryServices,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryServices.cs,DiscoverAsync,The length of the statement  "		var opIdentifiers = results.Where (result => result.ClaimedIdentifier == result.Protocol.ClaimedIdentifierForOPIdentifier); " is 123.
Long Statement,DotNetOpenAuth.OpenId,IdentifierDiscoveryServices,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryServices.cs,DiscoverAsync,The length of the statement  "		var claimedIdentifiers = results.Where (result => result.ClaimedIdentifier != result.Protocol.ClaimedIdentifierForOPIdentifier); " is 128.
Long Statement,DotNetOpenAuth.OpenId,OpenIdUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\OpenIdUtilities.cs,FixDoublyUriDecodedBase64String,The length of the statement  "		Logger.OpenId.Error ("Deserializing a corrupted token.  The OpenID Provider may have inappropriately decoded the return_to URL before sending it back to us."); " is 159.
Long Statement,DotNetOpenAuth.OpenId,OpenIdUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\OpenIdUtilities.cs,GetResolvedRealm,The length of the statement  "	UriBuilder fullyQualifiedRealm = new UriBuilder (new Uri (requestContext.GetPublicFacingUrl ()' page.ResolveUrl (realmNoWildcard))); " is 132.
Long Statement,DotNetOpenAuth.OpenId,OpenIdUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\OpenIdUtilities.cs,CreateHttpClient,The length of the statement  "		Logger.OpenId.Warn ("Unable to set cache policy due to HttpMessageHandler instances not being of type WebRequestHandler."); " is 123.
Long Statement,DotNetOpenAuth.OpenId,OpenIdUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\OpenIdUtilities.cs,CreateHttpClient,The length of the statement  "	ErrorUtilities.VerifyProtocol (!requireSsl || sslRequiredSet' "Unable to set RequireSsl on message handler because no HttpMessageHandler was of type {0}."' typeof(UntrustedWebRequestHandler).FullName); " is 201.
Long Statement,DotNetOpenAuth.OpenId,Realm,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,Contains,The length of the statement  "		Debug.Assert (!string.IsNullOrEmpty (this.Host)' "The host part of the Regex should evaluate to at least one char for successful parsed trust roots."); " is 151.
Long Statement,DotNetOpenAuth.OpenId,Realm,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,Contains,The length of the statement  "	if (this.PathAndQuery.Equals (url.PathAndQuery' StringComparison.Ordinal) || this.PathAndQuery.Equals ("/"' StringComparison.Ordinal)) { " is 136.
Long Statement,DotNetOpenAuth.OpenId,Realm,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,Contains,The length of the statement  "	return this.PathAndQuery.EndsWith ("/"' StringComparison.Ordinal) || url.PathAndQuery [path_len] == '?' || url.PathAndQuery [path_len] == '/'; " is 142.
Long Statement,DotNetOpenAuth.OpenId,Realm,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,DiscoverAsync,The length of the statement  "	DiscoveryResult yadisResult = await Yadis.DiscoverAsync (hostFactories' this.UriWithWildcardChangedToWww' false' cancellationToken); " is 132.
Long Statement,DotNetOpenAuth.OpenId,Realm,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Realm.cs,DiscoverAsync,The length of the statement  "		ErrorUtilities.VerifyProtocol (allowRedirects || yadisResult.NormalizedUri == yadisResult.RequestUri' OpenIdStrings.RealmCausedRedirectUponDiscovery' yadisResult.RequestUri); " is 174.
Long Statement,DotNetOpenAuth.OpenId,DiffieHellmanUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\DiffieHellmanUtilities.cs,Lookup,The length of the statement  "	// We COULD use just First instead of FirstOrDefault' but we want to throw ProtocolException instead of InvalidOperationException. " is 130.
Long Statement,DotNetOpenAuth.OpenId,DiffieHellmanUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\DiffieHellmanUtilities.cs,Lookup,The length of the statement  "	DHSha match = diffieHellmanSessionTypes.FirstOrDefault (dhsha => string.Equals (dhsha.GetName (protocol)' sessionType' StringComparison.Ordinal)); " is 146.
Long Statement,DotNetOpenAuth.OpenId,DiffieHellmanUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\DiffieHellmanUtilities.cs,SHAHashXorSecret,The length of the statement  "	ErrorUtilities.VerifyProtocol (sharedBlockHash.Length == plainOrEncryptedSecret.Length' OpenIdStrings.AssociationSecretHashLengthMismatch' plainOrEncryptedSecret.Length' sharedBlockHash.Length); " is 194.
Long Statement,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,Create,The length of the statement  "	HmacSha match = hmacShaAssociationTypes.FirstOrDefault (sha => string.Equals (sha.GetAssociationType (protocol)' associationType' StringComparison.Ordinal)); " is 157.
Long Statement,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,GetSecretLength,The length of the statement  "	HmacSha match = hmacShaAssociationTypes.FirstOrDefault (shaType => string.Equals (shaType.GetAssociationType (protocol)' associationType' StringComparison.Ordinal)); " is 165.
Long Statement,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,TryFindBestAssociation,The length of the statement  "	// We use AsEnumerable() to avoid VerificationException (http://stackoverflow.com/questions/478422/why-does-simple-array-and-linq-generate-verificationexception-operation-could-de) " is 180.
Long Statement,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,TryFindBestAssociation,The length of the statement  "	IEnumerable<HmacSha> preferredOrder = highSecurityIsBetter ? hmacShaAssociationTypes.AsEnumerable () : hmacShaAssociationTypes.Reverse (); " is 138.
Long Statement,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,TryFindBestAssociation,The length of the statement  "		if (hashSizeInBits > securityRequirements.MaximumHashBitLength || hashSizeInBits < securityRequirements.MinimumHashBitLength) { " is 127.
Long Statement,DotNetOpenAuth.OpenId,Protocol,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Protocol.cs,Detect,The length of the statement  "	return FindBestVersion (p => p.OPIdentifierServiceTypeURI' serviceTypeURIs) ?? FindBestVersion (p => p.ClaimedIdentifierServiceTypeURI' serviceTypeURIs) ?? FindBestVersion (p => p.RPReturnToTypeURI' serviceTypeURIs); " is 216.
Long Statement,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,SendAsync,The length of the statement  "			if (response.StatusCode == HttpStatusCode.MovedPermanently || response.StatusCode == HttpStatusCode.Redirect || response.StatusCode == HttpStatusCode.RedirectMethod || response.StatusCode == HttpStatusCode.RedirectKeepVerb) { " is 225.
Long Statement,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,SendAsync,The length of the statement  "				ErrorUtilities.VerifyProtocol (request.Method != HttpMethod.Post' MessagingStrings.UntrustedRedirectsOnPOSTNotSupported); " is 121.
Long Statement,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,SendAsync,The length of the statement  "			Logger.Http.InfoFormat ("HTTP POST to {0} resulted in 417 Expectation Failed.  Changing ServicePoint to not use Expect: Continue next time."' request.RequestUri); " is 162.
Long Statement,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,EnsureAllowableRequestUri,The length of the statement  "	ErrorUtilities.VerifyProtocol (this.IsUriAllowable (requestUri)' MessagingStrings.UnsafeWebRequestDetected' requestUri); " is 120.
Long Statement,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,EnsureAllowableRequestUri,The length of the statement  "	ErrorUtilities.VerifyProtocol (!this.IsSslRequired || string.Equals (requestUri.Scheme' Uri.UriSchemeHttps' StringComparison.OrdinalIgnoreCase)' MessagingStrings.InsecureWebRequestWithSslRequired' requestUri); " is 209.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverAsync,The length of the statement  "	DiscoveryResult yadisResult = await Yadis.DiscoverAsync (this.HostFactories' uriIdentifier' identifier.IsDiscoverySecureEndToEnd' cancellationToken); " is 149.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverAsync,The length of the statement  "			var htmlEndpoints = new List<IdentifierDiscoveryResult> (DiscoverFromHtml (yadisResult.NormalizedUri' uriIdentifier' yadisResult.ResponseText)); " is 144.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverAsync,The length of the statement  "				endpoints.AddRange (htmlEndpoints.Where (ep => !uriIdentifier.IsDiscoverySecureEndToEnd || ep.ProviderEndpoint.IsTransportSecure ())); " is 134.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverFromHtml,The length of the statement  "		var serverLinkTag = linkTags.WithAttribute ("rel").FirstOrDefault (tag => Regex.IsMatch (tag.Attributes ["rel"]' @"\b" + Regex.Escape (protocol.HtmlDiscoveryProviderKey) + @"\b"' RegexOptions.IgnoreCase)); " is 205.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverFromHtml,The length of the statement  "			var delegateLinkTag = linkTags.WithAttribute ("rel").FirstOrDefault (tag => Regex.IsMatch (tag.Attributes ["rel"]' @"\b" + Regex.Escape (protocol.HtmlDiscoveryLocalIdKey) + @"\b"' RegexOptions.IgnoreCase)); " is 206.
Long Statement,DotNetOpenAuth.OpenId,UriDiscoveryService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriDiscoveryService.cs,DiscoverFromHtml,The length of the statement  "			yield return IdentifierDiscoveryResult.CreateForClaimedIdentifier (claimedIdentifier' userSuppliedIdentifier' providerLocalIdentifier' new ProviderEndpointDescription (providerEndpoint' typeURIs)' (int?)null' (int?)null); " is 221.
Long Statement,DotNetOpenAuth.OpenId,XriDiscoveryProxyService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\XriDiscoveryProxyService.cs,DownloadXrdsAsync,The length of the statement  "	using (var xrdsResponse = await Yadis.RequestAsync (GetXrdsUrl (identifier)' identifier.IsDiscoverySecureEndToEnd' hostFactories' cancellationToken)) { " is 151.
Long Statement,DotNetOpenAuth.OpenId,XriDiscoveryProxyService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\XriDiscoveryProxyService.cs,DownloadXrdsAsync,The length of the statement  "		ErrorUtilities.VerifyProtocol (xrdsResponse.Content != null' "XRDS request \"{0}\" returned no response."' GetXrdsUrl (identifier)); " is 132.
Long Statement,DotNetOpenAuth.OpenId,XriDiscoveryProxyService,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\XriDiscoveryProxyService.cs,GetXrdsUrl,The length of the statement  "	return new Uri (string.Format (CultureInfo.InvariantCulture' xriResolverProxy' identifier' OpenIdElement.Configuration.XriResolver.Proxy.Name)); " is 144.
Long Statement,DotNetOpenAuth.OpenId,SecuritySettings,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\SecuritySettings.cs,IsAssociationInPermittedRange,The length of the statement  "	return association.HashBitLength >= this.MinimumHashBitLength && association.HashBitLength <= this.MaximumHashBitLength; " is 120.
Long Statement,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,IsAllowedScheme,The length of the statement  "	return Array.FindIndex (allowedSchemes' s => uri.StartsWith (s + Uri.SchemeDelimiter' StringComparison.OrdinalIgnoreCase)) >= 0; " is 128.
Long Statement,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryCanonicalize,The length of the statement  "		uriBuilder.Scheme = uriBuilder.Scheme == roundTrippingHttpParser.RegisteredScheme ? publishableHttpParser.RegisteredScheme : publishableHttpsParser.RegisteredScheme; " is 165.
Long Statement,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,NormalSchemeToSpecialRoundTrippingScheme,The length of the statement  "	if (string.Equals (normalScheme' Uri.UriSchemeHttp' StringComparison.OrdinalIgnoreCase) || string.Equals (normalScheme' publishableHttpParser.RegisteredScheme' StringComparison.OrdinalIgnoreCase)) { " is 198.
Long Statement,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,NormalSchemeToSpecialRoundTrippingScheme,The length of the statement  "	} else if (string.Equals (normalScheme' Uri.UriSchemeHttps' StringComparison.OrdinalIgnoreCase) || string.Equals (normalScheme' publishableHttpsParser.RegisteredScheme' StringComparison.OrdinalIgnoreCase)) { " is 207.
Long Statement,DotNetOpenAuth.OpenId,XriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\XriIdentifier.cs,Equals,The length of the statement  "		ErrorUtilities.VerifyInternal (!string.IsNullOrEmpty (objString)' "Identifier.ToString() returned a null or empty string."); " is 124.
Long Statement,DotNetOpenAuth.OpenId,XriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\XriIdentifier.cs,IsValidXri,The length of the statement  "	return xri.IndexOfAny (GlobalContextSymbols) == 0 || xri.StartsWith ("("' StringComparison.Ordinal) || xri.StartsWith (XriScheme' StringComparison.OrdinalIgnoreCase); " is 166.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "			ErrorUtilities.VerifyProtocol (op_endpoint != null' MessagingStrings.RequiredParametersMissing' message.GetType ().Name' ProviderEndpointParameterName); " is 152.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "				ErrorUtilities.VerifyProtocol (claimedId != null' MessagingStrings.RequiredParametersMissing' message.GetType ().Name' ClaimedIdentifierParameterName); " is 151.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,ProcessOutgoingMessageAsync,The length of the statement  "				ErrorUtilities.VerifyProtocol (!extensionManager.ContainsExtension (extension.TypeUri)' OpenIdStrings.ExtensionAlreadyAddedWithSameTypeURI' extension.TypeUri); " is 159.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,ProcessOutgoingMessageAsync,The length of the statement  "				Logger.OpenId.WarnFormat ("Unexpected extension type {0} did not implement {1}."' protocolExtension.GetType ()' typeof(IOpenIdMessageExtension).Name); " is 150.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,ProcessOutgoingMessageAsync,The length of the statement  "		bool includeOpenIdPrefix = baseMessageDictionary.Keys.Any (key => key.StartsWith (protocol.openid.Prefix' StringComparison.Ordinal)); " is 133.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "			Func<string' bool> isNotSigned = typeUri => !extendableMessage.Extensions.Cast<IOpenIdMessageExtension> ().Any (ext => ext.TypeUri == typeUri); " is 143.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ExtensionsBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ExtensionsBindingElement.cs,GetExtensions,The length of the statement  "	var extensionManager = ExtensionArgumentsManager.CreateIncomingExtensions (this.GetExtensionsDictionary (message' ignoreUnsigned)); " is 131.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "		Logger.Bindings.DebugFormat ("Verifying incoming {0} message signature of: {1}"' message.GetType ().Name' signedMessage.Signature); " is 131.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "			ErrorUtilities.VerifyInternal (this.Channel != null' "Cannot verify private association signature because we don't have a channel."); " is 133.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "			protectionsApplied = await this.VerifySignatureByUnrecognizedHandleAsync (message' signedMessage' protectionsApplied' cancellationToken); " is 137.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,GetSignature,The length of the statement  "	Requires.That (!string.IsNullOrEmpty (signedMessage.SignedParameterOrder)' "signedMessage"' "SignedParameterOrder must not be null or empty."); " is 143.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,GetSignature,The length of the statement  "		Logger.Signatures.DebugFormat ("Signing these message parts: {0}{1}{0}Base64 representation of signed data: {2}{0}Signature: {3}"' Environment.NewLine' parametersToSign.ToStringDeferred ()' Convert.ToBase64String (dataToSign)' signature); " is 238.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,EnsureParametersRequiringSignatureAreSigned,The length of the statement  "	ErrorUtilities.VerifyInternal (partsRequiringProtection.All (name => name.StartsWith (protocol.openid.Prefix' StringComparison.Ordinal))' "Signing only works when the parameters start with the 'openid.' prefix."); " is 213.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SigningBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SigningBindingElement.cs,EnsureParametersRequiringSignatureAreSigned,The length of the statement  "	ErrorUtilities.VerifyProtocol (!unsignedParts.Any ()' OpenIdStrings.SignatureDoesNotIncludeMandatoryParts' string.Join ("' "' unsignedParts.ToArray ())); " is 153.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetBytes,The length of the statement  "					throw new ArgumentException (string.Format (CultureInfo.CurrentCulture' OpenIdStrings.InvalidCharacterInKeyValueFormInput' pair.Key)); " is 134.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetBytes,The length of the statement  "					throw new ArgumentException (string.Format (CultureInfo.CurrentCulture' OpenIdStrings.InvalidCharacterInKeyValueFormInput' pair.Value)); " is 136.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The length of the statement  "			ErrorUtilities.VerifyFormat (parts.Length == 2' OpenIdStrings.InvalidKeyValueFormCharacterMissing' ':'' line_num' line); " is 120.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The length of the statement  "				ErrorUtilities.VerifyFormat (!(char.IsWhiteSpace (parts [0]' parts [0].Length - 1) || char.IsWhiteSpace (parts [1]' 0))' OpenIdStrings.InvalidCharacterInKeyValueFormInput' ' '' line_num' line); " is 193.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The length of the statement  "			ErrorUtilities.VerifyFormat (reader.BaseStream.ReadByte () == '\n'' OpenIdStrings.InvalidKeyValueFormCharacterMissing' "\\n"' line_num' line); " is 142.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,OpenIdChannel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\OpenIdChannel.cs,ProcessIncomingMessageAsync,The length of the statement  "		string exceptionMessage = string.Format (CultureInfo.CurrentCulture' OpenIdStrings.IndirectErrorFormattedMessage' errorMessage.ErrorMessage' errorMessage.Contact' errorMessage.Reference); " is 187.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,OpenIdChannel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\OpenIdChannel.cs,OnReceivingDirectResponse,The length of the statement  "			ErrorUtilities.VerifyProtocol (httpDirectResponse.HttpStatusCode == response.StatusCode' MessagingStrings.UnexpectedHttpStatusCode' (int)httpDirectResponse.HttpStatusCode' (int)response.StatusCode); " is 198.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,ProcessOutgoingMessageAsync,The length of the statement  "		var cryptoKeyPair = this.cryptoKeyStore.GetCurrentKey (SecretUri.AbsoluteUri' OpenIdElement.Configuration.MaxAuthenticationTime); " is 129.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "			response.ReturnToParametersSignatureValidated = MessagingUtilities.AreEquivalentConstantTime (actualBytes' expectedBytes); " is 122.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,GetReturnToSignature,The length of the statement  "	Logger.Bindings.DebugFormat ("ReturnTo signed data: {0}{1}"' Environment.NewLine' sortedReturnToParameters.ToStringDeferred ()); " is 128.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,GetReturnToSignature,The length of the statement  "			cryptoKey = this.cryptoKeyStore.GetKey (SecretUri.AbsoluteUri' returnToParameters [ReturnToSignatureHandleParameterName]); " is 122.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,ReturnToSignatureBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\ReturnToSignatureBindingElement.cs,GetReturnToSignature,The length of the statement  "			ErrorUtilities.VerifyProtocol (cryptoKey != null' MessagingStrings.MissingDecryptionKeyForHandle' SecretUri.AbsoluteUri' returnToParameters [ReturnToSignatureHandleParameterName]); " is 180.
Long Statement,DotNetOpenAuth.OpenId.ChannelElements,SkipSecurityBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\SkipSecurityBindingElement.cs,ProcessIncomingMessageAsync,The length of the statement  "		Logger.Bindings.DebugFormat ("Skipped security checks of incoming {0} message for preview purposes."' message.GetType ().Name); " is 127.
Long Statement,DotNetOpenAuth.OpenId.Extensions,AliasManager,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AliasManager.cs,AssignNewAlias,The length of the statement  "	ErrorUtilities.VerifyInternal (!this.typeUriToAliasMap.ContainsKey (typeUri)' "Oops!  This type URI already has an alias!"); " is 124.
Long Statement,DotNetOpenAuth.OpenId.Extensions,ExtensionArgumentsManager,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ExtensionArgumentsManager.cs,CreateIncomingExtensions,The length of the statement  "			string key = periodIndex >= 0 ? pair.Key.Substring (mgr.protocol.openid.Prefix.Length + possibleAlias.Length + 1) : string.Empty; " is 129.
Long Statement,DotNetOpenAuth.OpenId.Extensions,ExtensionArgumentsManager,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ExtensionArgumentsManager.cs,AddExtensionArguments,The length of the statement  "	ErrorUtilities.VerifyProtocol (extensionArgs.Count == 0' OpenIdStrings.ExtensionAlreadyAddedWithSameTypeURI' extensionTypeUri); " is 127.
Long Statement,DotNetOpenAuth.OpenId.Extensions.AttributeExchange,FetchRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AttributeExchange\FetchRequest.cs,OnReceiving,The length of the statement  "		Logger.OpenId.Error ("Attribute Exchange extension did not provide any aliases in the if_available or required lists."); " is 120.
Long Statement,DotNetOpenAuth.OpenId.Extensions.AttributeExchange,FetchRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AttributeExchange\FetchRequest.cs,EnsureValidMessage,The length of the statement  "		Logger.OpenId.ErrorFormat ("The AX fetch request update_url parameter was not absolute ('{0}').  Ignoring value."' this.UpdateUrl); " is 131.
Long Statement,DotNetOpenAuth.OpenId.Extensions.AttributeExchange,FetchResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AttributeExchange\FetchResponse.cs,EnsureValidMessage,The length of the statement  "		Logger.OpenId.ErrorFormat ("The AX fetch response update_url parameter was not absolute ('{0}').  Ignoring value."' this.UpdateUrl); " is 132.
Long Statement,DotNetOpenAuth.OpenId.Extensions.AttributeExchange,StoreResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\AttributeExchange\StoreResponse.cs,EnsureValidMessage,The length of the statement  "	ErrorUtilities.VerifyProtocol (this.Mode == SuccessMode || this.Mode == FailureMode' MessagingStrings.UnexpectedMessagePartValue' "mode"' this.Mode); " is 149.
Long Statement,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsRequest.cs,Equals,The length of the statement  "	return this.BirthDate.Equals (other.BirthDate) && this.Country.Equals (other.Country) && this.Language.Equals (other.Language) && this.Email.Equals (other.Email) && this.FullName.Equals (other.FullName) && this.Gender.Equals (other.Gender) && this.Nickname.Equals (other.Nickname) && this.PostalCode.Equals (other.PostalCode) && this.TimeZone.Equals (other.TimeZone) && this.PolicyUrl.EqualsNullSafe (other.PolicyUrl); " is 418.
Long Statement,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsRequest.cs,ToString,The length of the statement  "	return string.Format (CultureInfo.CurrentCulture' format' this.Nickname' this.Email' this.FullName' this.BirthDate' this.Gender' this.PostalCode' this.Country' this.Language' this.TimeZone); " is 190.
Long Statement,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,ClaimsResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\ClaimsResponse.cs,Equals,The length of the statement  "	return this.BirthDateRaw.EqualsNullSafe (other.BirthDateRaw) && this.Country.EqualsNullSafe (other.Country) && this.Language.EqualsNullSafe (other.Language) && this.Email.EqualsNullSafe (other.Email) && this.FullName.EqualsNullSafe (other.FullName) && this.Gender.Equals (other.Gender) && this.Nickname.EqualsNullSafe (other.Nickname) && this.PostalCode.EqualsNullSafe (other.PostalCode) && this.TimeZone.EqualsNullSafe (other.TimeZone); " is 437.
Long Statement,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,DateTimeEncoder,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\DateTimeEncoder.cs,Decode,The length of the statement  "	if (DateTime.TryParse (value' CultureInfo.InvariantCulture' DateTimeStyles.AdjustToUniversal' out dateTime) && dateTime.Kind == DateTimeKind.Utc) { " is 147.
Long Statement,DotNetOpenAuth.OpenId.Extensions.ProviderAuthenticationPolicy,PolicyRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ProviderAuthenticationPolicy\PolicyRequest.cs,OnSending,The length of the statement  "		extraData.Add (Constants.RequestParameters.PreferredAuthLevelTypes' SerializeAuthLevels (this.PreferredAuthLevelTypes' authLevelAliases)); " is 138.
Long Statement,DotNetOpenAuth.OpenId.RelyingParty,RelyingPartySecuritySettings,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\RelyingParty\RelyingPartySecuritySettings.cs,FilterEndpoints,The length of the statement  "	return endpoints.Where (se => !this.RejectDelegatingIdentifiers || se.ClaimedIdentifier == se.ProviderLocalIdentifier).Where (se => !this.RequireDirectedIdentity || se.ClaimedIdentifier == se.Protocol.ClaimedIdentifierForOPIdentifier); " is 235.
Long Statement,DotNetOpenAuth.OpenId.Messages,CheckIdRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\CheckIdRequest.cs,EnsureValidMessage,The length of the statement  "		ErrorUtilities.VerifyProtocol ((this.LocalIdentifier == this.Protocol.ClaimedIdentifierForOPIdentifier) == (this.ClaimedIdentifier == this.Protocol.ClaimedIdentifierForOPIdentifier)' OpenIdStrings.MatchingArgumentsExpected' Protocol.openid.claimed_id' Protocol.openid.identity' Protocol.ClaimedIdentifierForOPIdentifier); " is 321.
Long Statement,DotNetOpenAuth.OpenId.Messages,IndirectSignedResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\IndirectSignedResponse.cs,IsQuerySubsetOf,The length of the statement  "	return subsetArgs.Keys.Cast<string> ().All (key => string.Equals (subsetArgs [key]' supersetArgs [key]' StringComparison.Ordinal)); " is 131.
Long Statement,DotNetOpenAuth.OpenId.Messages,IndirectSignedResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\IndirectSignedResponse.cs,VerifyReturnToMatchesRecipient,The length of the statement  "	ErrorUtilities.VerifyProtocol (string.Equals (this.Recipient.Scheme' this.ReturnTo.Scheme' StringComparison.OrdinalIgnoreCase) && string.Equals (this.Recipient.Authority' this.ReturnTo.Authority' StringComparison.OrdinalIgnoreCase) && string.Equals (this.Recipient.AbsolutePath' this.ReturnTo.AbsolutePath' StringComparison.Ordinal) && IsQuerySubsetOf (this.Recipient.Query' this.ReturnTo.Query)' OpenIdStrings.ReturnToParamDoesNotMatchRequestUrl' Protocol.openid.return_to' this.ReturnTo' this.Recipient); " is 506.
Long Statement,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,EnsureValidMessage,The length of the statement  "	ErrorUtilities.VerifyProtocol (string.Equals (this.Mode' Protocol.Args.Mode.setup_needed' StringComparison.Ordinal) || string.Equals (this.Mode' Protocol.Args.Mode.cancel' StringComparison.Ordinal)' MessagingStrings.UnexpectedMessagePartValue' Protocol.openid.mode' this.Mode); " is 277.
Long Statement,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,EnsureValidMessage,The length of the statement  "		ErrorUtilities.VerifyProtocol (this.UserSetupUrl != null' OpenIdStrings.UserSetupUrlRequiredInImmediateNegativeResponse); " is 121.
Long Statement,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,ConstructUserSetupUrlAsync,The length of the statement  "	var setupRequest = new CheckIdRequest (immediateRequest.Version' immediateRequest.Recipient' AuthenticationRequestMode.Setup); " is 126.
Long Statement,DotNetOpenAuth.OpenId.Messages,SignedResponseRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\SignedResponseRequest.cs,EnsureValidMessage,The length of the statement  "		ErrorUtilities.VerifyProtocol (this.Realm.Contains (this.ReturnTo)' OpenIdStrings.ReturnToNotUnderRealm' this.ReturnTo' this.Realm); " is 132.
Long Statement,DotNetOpenAuth.OpenId.Messages,SignedResponseRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\SignedResponseRequest.cs,GetMode,The length of the statement  "	return mode == AuthenticationRequestMode.Immediate ? protocol.Args.Mode.checkid_immediate : protocol.Args.Mode.checkid_setup; " is 125.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateUnencryptedRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateUnencryptedRequest.cs,EnsureValidMessage,The length of the statement  "	ErrorUtilities.VerifyProtocol (string.Equals (this.SessionType' Protocol.Args.SessionType.NoEncryption' StringComparison.Ordinal)' MessagingStrings.UnexpectedMessagePartValueForConstant' GetType ().Name' Protocol.openid.session_type' Protocol.Args.SessionType.NoEncryption' SessionType); " is 287.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateDiffieHellmanRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateDiffieHellmanRequest.cs,InitializeRequest,The length of the statement  "		throw new InvalidOperationException (string.Format (CultureInfo.CurrentCulture' OpenIdStrings.DiffieHellmanRequiredPropertiesNotSet' string.Join ("' "' new string[] { " is 166.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateDiffieHellmanRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateDiffieHellmanRequest.cs,InitializeRequest,The length of the statement  "	this.Algorithm = new DiffieHellmanManaged (this.DiffieHellmanModulus ?? DefaultMod' this.DiffieHellmanGen ?? DefaultGen' DefaultX); " is 131.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateRequest,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateRequest.cs,EnsureValidMessage,The length of the statement  "	ErrorUtilities.VerifyProtocol (!string.Equals (this.SessionType' Protocol.Args.SessionType.NoEncryption' StringComparison.Ordinal) || this.Recipient.IsTransportSecure ()' OpenIdStrings.NoEncryptionSessionRequiresHttps' this); " is 225.
Long Statement,DotNetOpenAuth.OpenId.Messages,AssociateSuccessfulResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateSuccessfulResponse.cs,EnsureValidMessage,The length of the statement  "		ErrorUtilities.VerifyProtocol (string.IsNullOrEmpty (this.SessionType) || string.Equals (this.SessionType' this.Protocol.Args.SessionType.DH_SHA1' StringComparison.Ordinal)' MessagingStrings.UnexpectedMessagePartValueForConstant' GetType ().Name' Protocol.openid.session_type' this.Protocol.Args.SessionType.DH_SHA1' this.SessionType); " is 335.
Long Statement,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The length of the statement  "		response = await RequestAsync (uri' requireSsl' hostFactories' cancellationToken' ContentTypes.Html' ContentTypes.XHtml' ContentTypes.Xrds); " is 140.
Long Statement,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The length of the statement  "			Logger.Yadis.ErrorFormat ("HTTP error {0} {1} while performing discovery on {2}."' (int)response.StatusCode' response.StatusCode' uri); " is 135.
Long Statement,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The length of the statement  "		if (url == null && contentType != null && (contentType.MediaType == ContentTypes.Html || contentType.MediaType == ContentTypes.XHtml)) { " is 136.
Long Statement,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The length of the statement  "					Logger.Yadis.ErrorFormat ("HTTP error {0} {1} while performing discovery on {2}."' (int)response2.StatusCode' response2.StatusCode' uri); " is 137.
Long Statement,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,The length of the statement  "			// http://stackoverflow.com/questions/14103154/how-to-determine-if-an-httpresponsemessage-was-fulfilled-from-cache-using-httpcl " is 127.
Long Statement,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,The length of the statement  "				Logger.Messaging.ErrorFormat ("An HTTP {0} response was obtained from the cache.  Retrying with cache disabled."' response.StatusCode); " is 135.
Long Statement,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,RequestAsync,The length of the statement  "				using (var nonCachingHttpClient = hostFactories.CreateHttpClient (requireSsl' new RequestCachePolicy (RequestCacheLevel.Reload))) { " is 131.
Complex Conditional,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,SendAsync,The conditional expression  "response.StatusCode == HttpStatusCode.MovedPermanently || response.StatusCode == HttpStatusCode.Redirect || response.StatusCode == HttpStatusCode.RedirectMethod || response.StatusCode == HttpStatusCode.RedirectKeepVerb"  is complex.
Complex Conditional,DotNetOpenAuth.Yadis,Yadis,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Yadis\Yadis.cs,DiscoverAsync,The conditional expression  "url == null && contentType != null && (contentType.MediaType == ContentTypes.Html || contentType.MediaType == ContentTypes.XHtml)"  is complex.
Magic Number,DotNetOpenAuth.OpenId,Association,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Association.cs,Equals,The following statement contains a magic number: if (a.Handle != this.Handle || a.Issued != this.Issued || !MessagingUtilities.Equals (a.TotalLifeLength' this.TotalLifeLength' TimeSpan.FromSeconds (2))) {  	return false;  }  
Magic Number,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,GetEndpointPrecedenceOrderByServiceType,The following statement contains a magic number: if (endpoint.Capabilities.Contains (Protocol.V11.ClaimedIdentifierServiceTypeURI)) {  	return 2;  }  
Magic Number,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,GetEndpointPrecedenceOrderByServiceType,The following statement contains a magic number: return 2;  
Magic Number,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,GetEndpointPrecedenceOrderByServiceType,The following statement contains a magic number: if (endpoint.Capabilities.Contains (Protocol.V10.ClaimedIdentifierServiceTypeURI)) {  	return 3;  }  
Magic Number,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,GetEndpointPrecedenceOrderByServiceType,The following statement contains a magic number: return 3;  
Magic Number,DotNetOpenAuth.OpenId,IdentifierDiscoveryResult,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\IdentifierDiscoveryResult.cs,GetEndpointPrecedenceOrderByServiceType,The following statement contains a magic number: return 10;  
Magic Number,DotNetOpenAuth.OpenId,DiffieHellmanUtilities,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\DiffieHellmanUtilities.cs,EnsurePositive,The following statement contains a magic number: if (i > 127) {  	byte[] nowPositive = new byte[inputBytes.Length + 1];  	nowPositive [0] = 0;  	inputBytes.CopyTo (nowPositive' 1);  	return nowPositive;  }  
Magic Number,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,TryFindBestAssociation,The following statement contains a magic number: foreach (HmacSha sha in preferredOrder) {  	int hashSizeInBits = sha.SecretLength * 8;  	if (hashSizeInBits > securityRequirements.MaximumHashBitLength || hashSizeInBits < securityRequirements.MinimumHashBitLength) {  		continue;  	}  	if (OpenIdUtilities.IsDiffieHellmanPresent) {  		sessionType = DiffieHellmanUtilities.GetNameForSize (protocol' hashSizeInBits);  	} else {  		sessionType = requireMatchingDHSessionType ? null : protocol.Args.SessionType.NoEncryption;  	}  	if (requireMatchingDHSessionType && sessionType == null) {  		continue;  	}  	associationType = sha.GetAssociationType (protocol);  	if (associationType == null) {  		continue;  	}  	return true;  }  
Magic Number,DotNetOpenAuth.OpenId,HmacShaAssociation,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\HmacShaAssociation.cs,IsDHSessionCompatible,The following statement contains a magic number: if (OpenIdUtilities.IsDiffieHellmanPresent) {  	// When there _is_ a DH session' it must match in hash length with the association type.  	int associationSecretLengthInBytes = GetSecretLength (protocol' associationType);  	int sessionHashLengthInBytes = DiffieHellmanUtilities.Lookup (protocol' sessionType).HashSize / 8;  	return associationSecretLengthInBytes == sessionHashLengthInBytes;  } else {  	return false;  }  
Magic Number,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,The following statement contains a magic number: if (IPAddress.TryParse (uri.DnsSafeHost' out hostIPAddress)) {  	byte[] addressBytes = hostIPAddress.GetAddressBytes ();  	// The host is actually an IP address.  	switch (hostIPAddress.AddressFamily) {  	case System.Net.Sockets.AddressFamily.InterNetwork:  		if (addressBytes [0] == 127 || addressBytes [0] == 10) {  			return failsUnlessWhitelisted ("it is a loopback address.");  		}  		break;  	case System.Net.Sockets.AddressFamily.InterNetworkV6:  		if (IsIPv6Loopback (hostIPAddress)) {  			return failsUnlessWhitelisted ("it is a loopback address.");  		}  		break;  	default:  		return failsUnlessWhitelisted ("it does not use an IPv4 or IPv6 address.");  	}  } else {  	// The host is given by name.  We require names to contain periods to  	// help make sure it's not an internal address.  	if (!uri.Host.Contains (".")) {  		return failsUnlessWhitelisted ("it does not contain a period in the host name.");  	}  }  
Magic Number,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,The following statement contains a magic number: if (IPAddress.TryParse (uri.DnsSafeHost' out hostIPAddress)) {  	byte[] addressBytes = hostIPAddress.GetAddressBytes ();  	// The host is actually an IP address.  	switch (hostIPAddress.AddressFamily) {  	case System.Net.Sockets.AddressFamily.InterNetwork:  		if (addressBytes [0] == 127 || addressBytes [0] == 10) {  			return failsUnlessWhitelisted ("it is a loopback address.");  		}  		break;  	case System.Net.Sockets.AddressFamily.InterNetworkV6:  		if (IsIPv6Loopback (hostIPAddress)) {  			return failsUnlessWhitelisted ("it is a loopback address.");  		}  		break;  	default:  		return failsUnlessWhitelisted ("it does not use an IPv4 or IPv6 address.");  	}  } else {  	// The host is given by name.  We require names to contain periods to  	// help make sure it's not an internal address.  	if (!uri.Host.Contains (".")) {  		return failsUnlessWhitelisted ("it does not contain a period in the host name.");  	}  }  
Magic Number,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,The following statement contains a magic number: switch (hostIPAddress.AddressFamily) {  case System.Net.Sockets.AddressFamily.InterNetwork:  	if (addressBytes [0] == 127 || addressBytes [0] == 10) {  		return failsUnlessWhitelisted ("it is a loopback address.");  	}  	break;  case System.Net.Sockets.AddressFamily.InterNetworkV6:  	if (IsIPv6Loopback (hostIPAddress)) {  		return failsUnlessWhitelisted ("it is a loopback address.");  	}  	break;  default:  	return failsUnlessWhitelisted ("it does not use an IPv4 or IPv6 address.");  }  
Magic Number,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,The following statement contains a magic number: switch (hostIPAddress.AddressFamily) {  case System.Net.Sockets.AddressFamily.InterNetwork:  	if (addressBytes [0] == 127 || addressBytes [0] == 10) {  		return failsUnlessWhitelisted ("it is a loopback address.");  	}  	break;  case System.Net.Sockets.AddressFamily.InterNetworkV6:  	if (IsIPv6Loopback (hostIPAddress)) {  		return failsUnlessWhitelisted ("it is a loopback address.");  	}  	break;  default:  	return failsUnlessWhitelisted ("it does not use an IPv4 or IPv6 address.");  }  
Magic Number,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,The following statement contains a magic number: if (addressBytes [0] == 127 || addressBytes [0] == 10) {  	return failsUnlessWhitelisted ("it is a loopback address.");  }  
Magic Number,DotNetOpenAuth.OpenId,UntrustedWebRequestHandler,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UntrustedWebRequestHandler.cs,IsUriAllowable,The following statement contains a magic number: if (addressBytes [0] == 127 || addressBytes [0] == 10) {  	return failsUnlessWhitelisted ("it is a loopback address.");  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: try {  	UriParser.Register (roundTrippingHttpParser' "dnoarthttp"' 80);  	UriParser.Register (roundTrippingHttpsParser' "dnoarthttps"' 443);  	UriParser.Register (publishableHttpParser' "dnoahttp"' 80);  	UriParser.Register (publishableHttpsParser' "dnoahttps"' 443);  	roundTrippingHttpParser.Initialize (false);  	roundTrippingHttpsParser.Initialize (false);  	publishableHttpParser.Initialize (true);  	publishableHttpsParser.Initialize (true);  	schemeSubstitution = true;  	Logger.OpenId.Debug (".NET Uri class path compression overridden.");  	Reporting.RecordFeatureUse ("FullTrust");  } catch (SecurityException) {  	// We must be running in partial trust.  Nothing more we can do.  	Logger.OpenId.Warn ("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  	Reporting.RecordFeatureUse ("PartialTrust");  } catch (FieldAccessException) {  	// one customer reported getting this exception  	// We must be running in partial trust.  Nothing more we can do.  	Logger.OpenId.Warn ("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  	Reporting.RecordFeatureUse ("PartialTrust");  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: try {  	UriParser.Register (roundTrippingHttpParser' "dnoarthttp"' 80);  	UriParser.Register (roundTrippingHttpsParser' "dnoarthttps"' 443);  	UriParser.Register (publishableHttpParser' "dnoahttp"' 80);  	UriParser.Register (publishableHttpsParser' "dnoahttps"' 443);  	roundTrippingHttpParser.Initialize (false);  	roundTrippingHttpsParser.Initialize (false);  	publishableHttpParser.Initialize (true);  	publishableHttpsParser.Initialize (true);  	schemeSubstitution = true;  	Logger.OpenId.Debug (".NET Uri class path compression overridden.");  	Reporting.RecordFeatureUse ("FullTrust");  } catch (SecurityException) {  	// We must be running in partial trust.  Nothing more we can do.  	Logger.OpenId.Warn ("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  	Reporting.RecordFeatureUse ("PartialTrust");  } catch (FieldAccessException) {  	// one customer reported getting this exception  	// We must be running in partial trust.  Nothing more we can do.  	Logger.OpenId.Warn ("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  	Reporting.RecordFeatureUse ("PartialTrust");  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: try {  	UriParser.Register (roundTrippingHttpParser' "dnoarthttp"' 80);  	UriParser.Register (roundTrippingHttpsParser' "dnoarthttps"' 443);  	UriParser.Register (publishableHttpParser' "dnoahttp"' 80);  	UriParser.Register (publishableHttpsParser' "dnoahttps"' 443);  	roundTrippingHttpParser.Initialize (false);  	roundTrippingHttpsParser.Initialize (false);  	publishableHttpParser.Initialize (true);  	publishableHttpsParser.Initialize (true);  	schemeSubstitution = true;  	Logger.OpenId.Debug (".NET Uri class path compression overridden.");  	Reporting.RecordFeatureUse ("FullTrust");  } catch (SecurityException) {  	// We must be running in partial trust.  Nothing more we can do.  	Logger.OpenId.Warn ("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  	Reporting.RecordFeatureUse ("PartialTrust");  } catch (FieldAccessException) {  	// one customer reported getting this exception  	// We must be running in partial trust.  Nothing more we can do.  	Logger.OpenId.Warn ("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  	Reporting.RecordFeatureUse ("PartialTrust");  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: try {  	UriParser.Register (roundTrippingHttpParser' "dnoarthttp"' 80);  	UriParser.Register (roundTrippingHttpsParser' "dnoarthttps"' 443);  	UriParser.Register (publishableHttpParser' "dnoahttp"' 80);  	UriParser.Register (publishableHttpsParser' "dnoahttps"' 443);  	roundTrippingHttpParser.Initialize (false);  	roundTrippingHttpsParser.Initialize (false);  	publishableHttpParser.Initialize (true);  	publishableHttpsParser.Initialize (true);  	schemeSubstitution = true;  	Logger.OpenId.Debug (".NET Uri class path compression overridden.");  	Reporting.RecordFeatureUse ("FullTrust");  } catch (SecurityException) {  	// We must be running in partial trust.  Nothing more we can do.  	Logger.OpenId.Warn ("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  	Reporting.RecordFeatureUse ("PartialTrust");  } catch (FieldAccessException) {  	// one customer reported getting this exception  	// We must be running in partial trust.  Nothing more we can do.  	Logger.OpenId.Warn ("Unable to coerce .NET to stop compressing URI paths due to partial trust limitations.  Some URL identifiers may be unable to complete login.");  	Reporting.RecordFeatureUse ("PartialTrust");  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: UriParser.Register (roundTrippingHttpParser' "dnoarthttp"' 80);  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: UriParser.Register (roundTrippingHttpsParser' "dnoarthttps"' 443);  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: UriParser.Register (publishableHttpParser' "dnoahttp"' 80);  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,UriIdentifier,The following statement contains a magic number: UriParser.Register (publishableHttpsParser' "dnoahttps"' 443);  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryRequireSsl,The following statement contains a magic number: if (this.SchemeImplicitlyPrepended) {  	UriBuilder newIdentifierUri = new UriBuilder (this.Uri);  	newIdentifierUri.Scheme = Uri.UriSchemeHttps;  	if (newIdentifierUri.Port == 80) {  		newIdentifierUri.Port = 443;  	}  	secureIdentifier = new UriIdentifier (newIdentifierUri.Uri' true);  	return true;  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryRequireSsl,The following statement contains a magic number: if (this.SchemeImplicitlyPrepended) {  	UriBuilder newIdentifierUri = new UriBuilder (this.Uri);  	newIdentifierUri.Scheme = Uri.UriSchemeHttps;  	if (newIdentifierUri.Port == 80) {  		newIdentifierUri.Port = 443;  	}  	secureIdentifier = new UriIdentifier (newIdentifierUri.Uri' true);  	return true;  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryRequireSsl,The following statement contains a magic number: if (newIdentifierUri.Port == 80) {  	newIdentifierUri.Port = 443;  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryRequireSsl,The following statement contains a magic number: if (newIdentifierUri.Port == 80) {  	newIdentifierUri.Port = 443;  }  
Magic Number,DotNetOpenAuth.OpenId,UriIdentifier,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\UriIdentifier.cs,TryRequireSsl,The following statement contains a magic number: newIdentifierUri.Port = 443;  
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,ProcessOutgoingMessageAsync,The following statement contains a magic number: if (request != null && request.Version.Major < 2) {  	request.AddReturnToArguments (ProviderEndpointParameterName' request.Recipient.AbsoluteUri);  	CheckIdRequest authRequest = request as CheckIdRequest;  	if (authRequest != null) {  		request.AddReturnToArguments (ClaimedIdentifierParameterName' authRequest.ClaimedIdentifier);  	}  	return NoneTask;  }  
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,BackwardCompatibilityBindingElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\BackwardCompatibilityBindingElement.cs,ProcessIncomingMessageAsync,The following statement contains a magic number: if (response != null && response.Version.Major < 2) {  	// GetReturnToArgument may return parameters that are not signed'  	// but we must allow for that since in OpenID 1.x' a stateless RP has   	// no way to preserve the provider endpoint and claimed identifier otherwise.    	// We'll verify the positive assertion later in the   	// RelyingParty.PositiveAuthenticationResponse constructor anyway.  	// If this is a 1.0 OP signed response without these parameters then we didn't initiate  	// the request 'and since 1.0 OPs are not supposed to be able to send unsolicited   	// assertions it's an invalid case that we throw an exception for.  	if (response.ProviderEndpoint == null) {  		string op_endpoint = response.GetReturnToArgument (ProviderEndpointParameterName);  		ErrorUtilities.VerifyProtocol (op_endpoint != null' MessagingStrings.RequiredParametersMissing' message.GetType ().Name' ProviderEndpointParameterName);  		response.ProviderEndpoint = new Uri (op_endpoint);  	}  	PositiveAssertionResponse authResponse = response as PositiveAssertionResponse;  	if (authResponse != null) {  		if (authResponse.ClaimedIdentifier == null) {  			string claimedId = response.GetReturnToArgument (ClaimedIdentifierParameterName);  			ErrorUtilities.VerifyProtocol (claimedId != null' MessagingStrings.RequiredParametersMissing' message.GetType ().Name' ClaimedIdentifierParameterName);  			authResponse.ClaimedIdentifier = claimedId;  		}  	}  	return NoneTask;  }  
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The following statement contains a magic number: using (StreamReader reader = new StreamReader (data' textEncoding)) {  	var dict = new Dictionary<string' string> ();  	int line_num = 0;  	string line;  	while ((line = await reader.ReadLineAsync ()) != null) {  		cancellationToken.ThrowIfCancellationRequested ();  		line_num++;  		if (this.ConformanceLevel == KeyValueFormConformanceLevel.Loose) {  			line = line.Trim ();  			if (line.Length == 0) {  				continue;  			}  		}  		string[] parts = line.Split (new[] {  			':'  		}' 2);  		ErrorUtilities.VerifyFormat (parts.Length == 2' OpenIdStrings.InvalidKeyValueFormCharacterMissing' ':'' line_num' line);  		if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  			ErrorUtilities.VerifyFormat (!(char.IsWhiteSpace (parts [0]' parts [0].Length - 1) || char.IsWhiteSpace (parts [1]' 0))' OpenIdStrings.InvalidCharacterInKeyValueFormInput' ' '' line_num' line);  		}  		if (this.ConformanceLevel < KeyValueFormConformanceLevel.OpenId20) {  			parts [0] = parts [0].Trim ();  			parts [1] = parts [1].Trim ();  		}  		// calling Add method will throw if a key is encountered twice'  		// which we should do.  		dict.Add (parts [0]' parts [1]);  	}  	if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  		reader.BaseStream.Seek (-1' SeekOrigin.End);  		ErrorUtilities.VerifyFormat (reader.BaseStream.ReadByte () == '\n'' OpenIdStrings.InvalidKeyValueFormCharacterMissing' "\\n"' line_num' line);  	}  	return dict;  }  
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The following statement contains a magic number: using (StreamReader reader = new StreamReader (data' textEncoding)) {  	var dict = new Dictionary<string' string> ();  	int line_num = 0;  	string line;  	while ((line = await reader.ReadLineAsync ()) != null) {  		cancellationToken.ThrowIfCancellationRequested ();  		line_num++;  		if (this.ConformanceLevel == KeyValueFormConformanceLevel.Loose) {  			line = line.Trim ();  			if (line.Length == 0) {  				continue;  			}  		}  		string[] parts = line.Split (new[] {  			':'  		}' 2);  		ErrorUtilities.VerifyFormat (parts.Length == 2' OpenIdStrings.InvalidKeyValueFormCharacterMissing' ':'' line_num' line);  		if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  			ErrorUtilities.VerifyFormat (!(char.IsWhiteSpace (parts [0]' parts [0].Length - 1) || char.IsWhiteSpace (parts [1]' 0))' OpenIdStrings.InvalidCharacterInKeyValueFormInput' ' '' line_num' line);  		}  		if (this.ConformanceLevel < KeyValueFormConformanceLevel.OpenId20) {  			parts [0] = parts [0].Trim ();  			parts [1] = parts [1].Trim ();  		}  		// calling Add method will throw if a key is encountered twice'  		// which we should do.  		dict.Add (parts [0]' parts [1]);  	}  	if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  		reader.BaseStream.Seek (-1' SeekOrigin.End);  		ErrorUtilities.VerifyFormat (reader.BaseStream.ReadByte () == '\n'' OpenIdStrings.InvalidKeyValueFormCharacterMissing' "\\n"' line_num' line);  	}  	return dict;  }  
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The following statement contains a magic number: while ((line = await reader.ReadLineAsync ()) != null) {  	cancellationToken.ThrowIfCancellationRequested ();  	line_num++;  	if (this.ConformanceLevel == KeyValueFormConformanceLevel.Loose) {  		line = line.Trim ();  		if (line.Length == 0) {  			continue;  		}  	}  	string[] parts = line.Split (new[] {  		':'  	}' 2);  	ErrorUtilities.VerifyFormat (parts.Length == 2' OpenIdStrings.InvalidKeyValueFormCharacterMissing' ':'' line_num' line);  	if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  		ErrorUtilities.VerifyFormat (!(char.IsWhiteSpace (parts [0]' parts [0].Length - 1) || char.IsWhiteSpace (parts [1]' 0))' OpenIdStrings.InvalidCharacterInKeyValueFormInput' ' '' line_num' line);  	}  	if (this.ConformanceLevel < KeyValueFormConformanceLevel.OpenId20) {  		parts [0] = parts [0].Trim ();  		parts [1] = parts [1].Trim ();  	}  	// calling Add method will throw if a key is encountered twice'  	// which we should do.  	dict.Add (parts [0]' parts [1]);  }  
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The following statement contains a magic number: while ((line = await reader.ReadLineAsync ()) != null) {  	cancellationToken.ThrowIfCancellationRequested ();  	line_num++;  	if (this.ConformanceLevel == KeyValueFormConformanceLevel.Loose) {  		line = line.Trim ();  		if (line.Length == 0) {  			continue;  		}  	}  	string[] parts = line.Split (new[] {  		':'  	}' 2);  	ErrorUtilities.VerifyFormat (parts.Length == 2' OpenIdStrings.InvalidKeyValueFormCharacterMissing' ':'' line_num' line);  	if (this.ConformanceLevel > KeyValueFormConformanceLevel.Loose) {  		ErrorUtilities.VerifyFormat (!(char.IsWhiteSpace (parts [0]' parts [0].Length - 1) || char.IsWhiteSpace (parts [1]' 0))' OpenIdStrings.InvalidCharacterInKeyValueFormInput' ' '' line_num' line);  	}  	if (this.ConformanceLevel < KeyValueFormConformanceLevel.OpenId20) {  		parts [0] = parts [0].Trim ();  		parts [1] = parts [1].Trim ();  	}  	// calling Add method will throw if a key is encountered twice'  	// which we should do.  	dict.Add (parts [0]' parts [1]);  }  
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,KeyValueFormEncoding,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\KeyValueFormEncoding.cs,GetDictionaryAsync,The following statement contains a magic number: ErrorUtilities.VerifyFormat (parts.Length == 2' OpenIdStrings.InvalidKeyValueFormCharacterMissing' ':'' line_num' line);  
Magic Number,DotNetOpenAuth.OpenId.ChannelElements,OpenIdChannel,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\ChannelElements\OpenIdChannel.cs,OnReceivingDirectResponse,The following statement contains a magic number: if (message.Version.Major >= 2) {  	var httpDirectResponse = message as IHttpDirectResponse;  	if (httpDirectResponse != null) {  		ErrorUtilities.VerifyProtocol (httpDirectResponse.HttpStatusCode == response.StatusCode' MessagingStrings.UnexpectedHttpStatusCode' (int)httpDirectResponse.HttpStatusCode' (int)response.StatusCode);  	}  }  
Magic Number,DotNetOpenAuth.OpenId.Extensions,ExtensionArgumentsManager,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\ExtensionArgumentsManager.cs,CreateIncomingExtensions,The following statement contains a magic number: if (mgr.protocol.Version.Major < 2) {  	foreach (var pair in typeUriToAliasAffinity) {  		if (!mgr.aliasManager.IsAliasAssignedTo (pair.Key) && !mgr.aliasManager.IsAliasUsed (pair.Value)) {  			mgr.aliasManager.SetAlias (pair.Value' pair.Key);  		}  	}  }  
Magic Number,DotNetOpenAuth.OpenId.RelyingParty,RelyingPartySecuritySettings,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\RelyingParty\RelyingPartySecuritySettings.cs,RelyingPartySecuritySettings,The following statement contains a magic number: this.PrivateSecretMaximumAge = TimeSpan.FromDays (7);  
Magic Number,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,EnsureValidMessage,The following statement contains a magic number: if (this.Immediate && Protocol.Version.Major < 2) {  	ErrorUtilities.VerifyProtocol (this.UserSetupUrl != null' OpenIdStrings.UserSetupUrlRequiredInImmediateNegativeResponse);  }  
Magic Number,DotNetOpenAuth.OpenId.Messages,NegativeAssertionResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\NegativeAssertionResponse.cs,CreateAsync,The following statement contains a magic number: if (result.Version.Major < 2 && request.Immediate && channel != null) {  	// All requests are CheckIdRequests in OpenID 1.x' so this cast should be safe.  	result.UserSetupUrl = await ConstructUserSetupUrlAsync ((CheckIdRequest)request' channel' cancellationToken);  }  
Magic Number,DotNetOpenAuth.OpenId.Messages,AssociateSuccessfulResponse,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Messages\AssociateSuccessfulResponse.cs,EnsureValidMessage,The following statement contains a magic number: if (this.Version.Major < 2) {  	ErrorUtilities.VerifyProtocol (string.IsNullOrEmpty (this.SessionType) || string.Equals (this.SessionType' this.Protocol.Args.SessionType.DH_SHA1' StringComparison.Ordinal)' MessagingStrings.UnexpectedMessagePartValueForConstant' GetType ().Name' Protocol.openid.session_type' this.Protocol.Args.SessionType.DH_SHA1' this.SessionType);  }  
Magic Number,DotNetOpenAuth.Xrds,XrdElement,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\Xrds\XrdElement.cs,SearchForServiceTypeUris,The following statement contains a magic number: xpath.Length -= 4;  
Missing Default,DotNetOpenAuth.OpenId.Extensions.SimpleRegistration,GenderEncoder,F:\newReposMay17\DotNetOpenAuth_DotNetOpenAuth\src\DotNetOpenAuth.OpenId\OpenId\Extensions\SimpleRegistration\GenderEncoder.cs,Encode,The following switch statement is missing a default case: switch (gender.Value) {  case Gender.Male:  	return Constants.Genders.Male;  case Gender.Female:  	return Constants.Genders.Female;  }  
