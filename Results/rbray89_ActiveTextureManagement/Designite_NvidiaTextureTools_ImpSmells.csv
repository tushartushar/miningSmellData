Implementation smell,Namespace,Class,File,Method,Description
Complex Method,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,Cyclomatic complexity of the method is 12
Long Parameter List,NvidiaTextureTools,ColorBlock,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\ColorBlock.cs,init,The method has 5 parameters. Parameters: w' h' data' x' y
Long Parameter List,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,computeCovariance,The method has 5 parameters. Parameters: n' points' weights' metric' covariance
Long Parameter List,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The method has 5 parameters. Parameters: n' points' weights' metric' cluster
Complex Conditional,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The conditional expression  "equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3])"  is complex.
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,u,The following statement contains a magic number: return (uint)(color.r | (color.g << 8) | (color.b << 16) | (color.a << 24));
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,u,The following statement contains a magic number: return (uint)(color.r | (color.g << 8) | (color.b << 16) | (color.a << 24));
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,u,The following statement contains a magic number: return (uint)(color.r | (color.g << 8) | (color.b << 16) | (color.a << 24));
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,component,The following statement contains a magic number: return new byte[4] { color.b' color.g' color.r' color.a };
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,bytes,The following statement contains a magic number: byte[] array = new byte[texture.width * texture.height * 4];
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,bytes,The following statement contains a magic number: for (int i = 0; i < colors.Length; i++ )              {                  array[i*4] = colors[i].r;                  array[i*4+1] = colors[i].g;                  array[i*4+2] = colors[i].b;                  array[i*4+3] = colors[i].a;              }
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,bytes,The following statement contains a magic number: for (int i = 0; i < colors.Length; i++ )              {                  array[i*4] = colors[i].r;                  array[i*4+1] = colors[i].g;                  array[i*4+2] = colors[i].b;                  array[i*4+3] = colors[i].a;              }
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,bytes,The following statement contains a magic number: for (int i = 0; i < colors.Length; i++ )              {                  array[i*4] = colors[i].r;                  array[i*4+1] = colors[i].g;                  array[i*4+2] = colors[i].b;                  array[i*4+3] = colors[i].a;              }
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,bytes,The following statement contains a magic number: for (int i = 0; i < colors.Length; i++ )              {                  array[i*4] = colors[i].r;                  array[i*4+1] = colors[i].g;                  array[i*4+2] = colors[i].b;                  array[i*4+3] = colors[i].a;              }
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,bytes,The following statement contains a magic number: for (int i = 0; i < colors.Length; i++ )              {                  array[i*4] = colors[i].r;                  array[i*4+1] = colors[i].g;                  array[i*4+2] = colors[i].b;                  array[i*4+3] = colors[i].a;              }
Magic Number,NvidiaTextureTools,ColorExtensions,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Color16.cs,bytes,The following statement contains a magic number: for (int i = 0; i < colors.Length; i++ )              {                  array[i*4] = colors[i].r;                  array[i*4+1] = colors[i].g;                  array[i*4+2] = colors[i].b;                  array[i*4+3] = colors[i].a;              }
Magic Number,NvidiaTextureTools,ColorBlock,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\ColorBlock.cs,isSingleColor,The following statement contains a magic number: for (uint i = 1; i < 16; i++)              {                  if (u != (m_color[i].u()))                  {                      return false;                  }              }
Magic Number,NvidiaTextureTools,ColorBlock,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\ColorBlock.cs,init,The following statement contains a magic number: for (uint i = 0; i < 4; i++)              {                  uint by = i % bh;                    for (uint e = 0; e < 4; e++)                  {                      uint bx = e % bw;                      uint idx = (y + by) * w + x + bx;                        m_color[e' i] = data[idx];                  }              }
Magic Number,NvidiaTextureTools,ColorBlock,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\ColorBlock.cs,init,The following statement contains a magic number: for (uint i = 0; i < 4; i++)              {                  uint by = i % bh;                    for (uint e = 0; e < 4; e++)                  {                      uint bx = e % bw;                      uint idx = (y + by) * w + x + bx;                        m_color[e' i] = data[idx];                  }              }
Magic Number,NvidiaTextureTools,AlphaBlock4x4,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\ColorBlock.cs,init,The following statement contains a magic number: for (int i = 0; i < 16; i++)              {                  alpha[i] = a;                  weights[i] = 1.0f;              }
Magic Number,NvidiaTextureTools,AlphaBlock4x4,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\ColorBlock.cs,init,The following statement contains a magic number: if (channel == 0) channel = 2;              else if (channel == 2) channel = 0;
Magic Number,NvidiaTextureTools,AlphaBlock4x4,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\ColorBlock.cs,init,The following statement contains a magic number: if (channel == 0) channel = 2;              else if (channel == 2) channel = 0;
Magic Number,NvidiaTextureTools,AlphaBlock4x4,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\ColorBlock.cs,init,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  alpha[i] = src.color[i].component()[channel];                  weights[i] = 1.0f;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,WriteBytes,The following statement contains a magic number: BitConverter.GetBytes(col1.u).CopyTo(dst' index+2);
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,WriteBytes,The following statement contains a magic number: row.CopyTo(dst' index + 4);
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[0].b = (byte)((col0.b << 3) | (col0.b >> 2));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[0].b = (byte)((col0.b << 3) | (col0.b >> 2));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[0].g = (byte)((col0.g << 2) | (col0.g >> 4));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[0].g = (byte)((col0.g << 2) | (col0.g >> 4));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[0].r = (byte)((col0.r << 3) | (col0.r >> 2));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[0].r = (byte)((col0.r << 3) | (col0.r >> 2));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[1].r = (byte)((col1.r << 3) | (col1.r >> 2));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[1].r = (byte)((col1.r << 3) | (col1.r >> 2));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[1].g = (byte)((col1.g << 2) | (col1.g >> 4));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[1].g = (byte)((col1.g << 2) | (col1.g >> 4));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[1].b = (byte)((col1.b << 3) | (col1.b >> 2));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: color_array[1].b = (byte)((col1.b << 3) | (col1.b >> 2));
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,BlockDXT1,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette,The following statement contains a magic number: if (col0.u > col1.u)              {                  int bias = 0;                  if (d3d9) bias = 1;                    // Four-color block: derive the other two colors.                  color_array[2].r = (byte)((2 * color_array[0].r + color_array[1].r + bias) / 3);                  color_array[2].g = (byte)((2 * color_array[0].g + color_array[1].g + bias) / 3);                  color_array[2].b = (byte)((2 * color_array[0].b + color_array[1].b + bias) / 3);                  color_array[2].a = 0xFF;                    color_array[3].r = (byte)((2 * color_array[1].r + color_array[0].r + bias) / 3);                  color_array[3].g = (byte)((2 * color_array[1].g + color_array[0].g + bias) / 3);                  color_array[3].b = (byte)((2 * color_array[1].b + color_array[0].b + bias) / 3);                  color_array[3].a = 0xFF;                    return 4;              }              else              {                  // Three-color block: derive the other color.                  color_array[2].r = (byte)((color_array[0].r + color_array[1].r) / 2);                  color_array[2].g = (byte)((color_array[0].g + color_array[1].g) / 2);                  color_array[2].b = (byte)((color_array[0].b + color_array[1].b) / 2);                  color_array[2].a = 0xFF;                    // Set all components to 0 to match DXT specs.                  color_array[3].r = 0x00; // color_array[2].r;                  color_array[3].g = 0x00; // color_array[2].g;                  color_array[3].b = 0x00; // color_array[2].b;                  color_array[3].a = 0x00;                    return 3;              }
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: if (d3d9) bias = 3;
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[2] = (byte)((6 * alpha[0] + 1 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[3] = (byte)((5 * alpha[0] + 2 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[4] = (byte)((4 * alpha[0] + 3 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[5] = (byte)((3 * alpha[0] + 4 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[6] = (byte)((2 * alpha[0] + 5 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette8,The following statement contains a magic number: alpha[7] = (byte)((1 * alpha[0] + 6 * alpha[1] + bias) / 7);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: if (d3d9) bias = 2;
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[2] = (byte)((4 * alpha[0] + 1 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[3] = (byte)((3 * alpha[0] + 2 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[4] = (byte)((2 * alpha[0] + 3 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[5] = (byte)((1 * alpha[0] + 4 * alpha[1] + bias) / 5);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[6] = 0x00;
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,evaluatePalette6,The following statement contains a magic number: alpha[7] = 0xFF;
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,index,The following statement contains a magic number: uint offset = (3 * index + 16);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,index,The following statement contains a magic number: uint offset = (3 * index + 16);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,setIndex,The following statement contains a magic number: uint offset = (3 * index + 16);
Magic Number,NvidiaTextureTools,AlphaBlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,setIndex,The following statement contains a magic number: uint offset = (3 * index + 16);
Magic Number,NvidiaTextureTools,BlockDXT5,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\DXT.cs,WriteBytes,The following statement contains a magic number: color.WriteBytes(dst' index+8);
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,computeCovariance,The following statement contains a magic number: for (int i = 0; i < 6; i++)              {                  covariance[i] = 0.0f;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,computeCovariance,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  Vector3 a = Vector3.Scale((points[i] - centroid)' metric);                  Vector3 b = weights[i] * a;                    covariance[0] += a.x * b.x;                  covariance[1] += a.x * b.y;                  covariance[2] += a.x * b.z;                  covariance[3] += a.y * b.y;                  covariance[4] += a.y * b.z;                  covariance[5] += a.z * b.z;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,computeCovariance,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  Vector3 a = Vector3.Scale((points[i] - centroid)' metric);                  Vector3 b = weights[i] * a;                    covariance[0] += a.x * b.x;                  covariance[1] += a.x * b.y;                  covariance[2] += a.x * b.z;                  covariance[3] += a.y * b.y;                  covariance[4] += a.y * b.z;                  covariance[5] += a.z * b.z;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,computeCovariance,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  Vector3 a = Vector3.Scale((points[i] - centroid)' metric);                  Vector3 b = weights[i] * a;                    covariance[0] += a.x * b.x;                  covariance[1] += a.x * b.y;                  covariance[2] += a.x * b.z;                  covariance[3] += a.y * b.y;                  covariance[4] += a.y * b.z;                  covariance[5] += a.z * b.z;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,computeCovariance,The following statement contains a magic number: for (int i = 0; i < n; i++)              {                  Vector3 a = Vector3.Scale((points[i] - centroid)' metric);                  Vector3 b = weights[i] * a;                    covariance[0] += a.x * b.x;                  covariance[1] += a.x * b.y;                  covariance[2] += a.x * b.z;                  covariance[3] += a.y * b.y;                  covariance[4] += a.y * b.z;                  covariance[5] += a.z * b.z;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,estimatePrincipalComponent,The following statement contains a magic number: Vector3 row0 = new Vector3(matrix[0]' matrix[1]' matrix[2]);
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,estimatePrincipalComponent,The following statement contains a magic number: Vector3 row1 = new Vector3(matrix[1]' matrix[3]' matrix[4]);
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,estimatePrincipalComponent,The following statement contains a magic number: Vector3 row1 = new Vector3(matrix[1]' matrix[3]' matrix[4]);
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,estimatePrincipalComponent,The following statement contains a magic number: Vector3 row2 = new Vector3(matrix[2]' matrix[4]' matrix[5]);
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,estimatePrincipalComponent,The following statement contains a magic number: Vector3 row2 = new Vector3(matrix[2]' matrix[4]' matrix[5]);
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,estimatePrincipalComponent,The following statement contains a magic number: Vector3 row2 = new Vector3(matrix[2]' matrix[4]' matrix[5]);
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: if (matrix[0] == 0 && matrix[3] == 0 && matrix[5] == 0)              {                  return Vector3.zero;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: if (matrix[0] == 0 && matrix[3] == 0 && matrix[5] == 0)              {                  return Vector3.zero;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: const int NUM = 8;
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: for (int i = 0; i < NUM; i++)              {                  float x = v.x * matrix[0] + v.y * matrix[1] + v.z * matrix[2];                  float y = v.x * matrix[1] + v.y * matrix[3] + v.z * matrix[4];                  float z = v.x * matrix[2] + v.y * matrix[4] + v.z * matrix[5];                    float norm = Mathf.Max(Mathf.Max(x' y)' z);                    v = new Vector3(x' y' z) / norm;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: for (int i = 0; i < NUM; i++)              {                  float x = v.x * matrix[0] + v.y * matrix[1] + v.z * matrix[2];                  float y = v.x * matrix[1] + v.y * matrix[3] + v.z * matrix[4];                  float z = v.x * matrix[2] + v.y * matrix[4] + v.z * matrix[5];                    float norm = Mathf.Max(Mathf.Max(x' y)' z);                    v = new Vector3(x' y' z) / norm;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: for (int i = 0; i < NUM; i++)              {                  float x = v.x * matrix[0] + v.y * matrix[1] + v.z * matrix[2];                  float y = v.x * matrix[1] + v.y * matrix[3] + v.z * matrix[4];                  float z = v.x * matrix[2] + v.y * matrix[4] + v.z * matrix[5];                    float norm = Mathf.Max(Mathf.Max(x' y)' z);                    v = new Vector3(x' y' z) / norm;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: for (int i = 0; i < NUM; i++)              {                  float x = v.x * matrix[0] + v.y * matrix[1] + v.z * matrix[2];                  float y = v.x * matrix[1] + v.y * matrix[3] + v.z * matrix[4];                  float z = v.x * matrix[2] + v.y * matrix[4] + v.z * matrix[5];                    float norm = Mathf.Max(Mathf.Max(x' y)' z);                    v = new Vector3(x' y' z) / norm;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: for (int i = 0; i < NUM; i++)              {                  float x = v.x * matrix[0] + v.y * matrix[1] + v.z * matrix[2];                  float y = v.x * matrix[1] + v.y * matrix[3] + v.z * matrix[4];                  float z = v.x * matrix[2] + v.y * matrix[4] + v.z * matrix[5];                    float norm = Mathf.Max(Mathf.Max(x' y)' z);                    v = new Vector3(x' y' z) / norm;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,firstEigenVector_PowerMethod,The following statement contains a magic number: for (int i = 0; i < NUM; i++)              {                  float x = v.x * matrix[0] + v.y * matrix[1] + v.z * matrix[2];                  float y = v.x * matrix[1] + v.y * matrix[3] + v.z * matrix[4];                  float z = v.x * matrix[2] + v.y * matrix[4] + v.z * matrix[5];                    float norm = Mathf.Max(Mathf.Max(x' y)' z);                    v = new Vector3(x' y' z) / norm;              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: float[] matrix = new float[6];
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: cluster[2] = (2.0f * cluster[0] + cluster[1]) / 3.0f;
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: cluster[3] = (2.0f * cluster[1] + cluster[0]) / 3.0f;
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,Fitting,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Fitting.cs,compute4Means,The following statement contains a magic number: while (true)              {                  Vector3[] newCluster = new Vector3[4] { Vector3.zero' Vector3.zero' Vector3.zero' Vector3.zero };                  float[] total = new float[4] { 0' 0' 0' 0 };                    for (int i = 0; i < n; ++i)                  {                      // Find nearest cluster.                      int nearest = 0;                      float mindist = float.MaxValue;                      for (int j = 0; j < 4; j++)                      {                          float dist = Vector3.Scale((cluster[j] - points[i])' metric).sqrMagnitude;                          if (dist < mindist)                          {                              mindist = dist;                              nearest = j;                          }                      }                        newCluster[nearest] += weights[i] * points[i];                      total[nearest] += weights[i];                  }                    for (int j = 0; j < 4; j++)                  {                      if (total[j] != 0)                          newCluster[j] /= total[j];                  }                    if (equal(cluster[0]' newCluster[0]) && equal(cluster[1]' newCluster[1]) &&                      equal(cluster[2]' newCluster[2]) && equal(cluster[3]' newCluster[3]))                  {                      return ((total[0] != 0) ? 1 : 0) + ((total[1] != 0) ? 1 : 0) + ((total[2] != 0) ? 1 : 0) + ((total[3] != 0) ? 1 : 0);                  }                    cluster[0] = newCluster[0];                  cluster[1] = newCluster[1];                  cluster[2] = newCluster[2];                  cluster[3] = newCluster[3];                    // Sort clusters by weight.                  for (int i = 0; i < 4; i++)                  {                      for (int j = i; j > 0 && total[j] > total[j - 1]; j--)                      {                          swap(ref total[j]' ref total[j - 1]);                          swap(ref cluster[j]' ref cluster[j - 1]);                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: int[] palette = new int[4];
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[0] = (block.col0.g << 2) | (block.col0.g >> 4);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[0] = (block.col0.g << 2) | (block.col0.g >> 4);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[1] = (block.col1.g << 2) | (block.col1.g >> 4);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[1] = (block.col1.g << 2) | (block.col1.g >> 4);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[2] = (2 * palette[0] + palette[1]) / 3;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[2] = (2 * palette[0] + palette[1]) / 3;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[2] = (2 * palette[0] + palette[1]) / 3;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[3] = (2 * palette[1] + palette[0]) / 3;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[3] = (2 * palette[1] + palette[0]) / 3;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: palette[3] = (2 * palette[1] + palette[0]) / 3;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  int green = rgba.color[i].g;                    uint error = greenDistance(green' palette[0]);                  error = Math.Min(error' greenDistance(green' palette[1]));                  error = Math.Min(error' greenDistance(green' palette[2]));                  error = Math.Min(error' greenDistance(green' palette[3]));                    totalError += error;                    //      totalError += nearestGreen4(green' g0' g1);                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  int green = rgba.color[i].g;                    uint error = greenDistance(green' palette[0]);                  error = Math.Min(error' greenDistance(green' palette[1]));                  error = Math.Min(error' greenDistance(green' palette[2]));                  error = Math.Min(error' greenDistance(green' palette[3]));                    totalError += error;                    //      totalError += nearestGreen4(green' g0' g1);                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenError,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  int green = rgba.color[i].g;                    uint error = greenDistance(green' palette[0]);                  error = Math.Min(error' greenDistance(green' palette[1]));                  error = Math.Min(error' greenDistance(green' palette[2]));                  error = Math.Min(error' greenDistance(green' palette[3]));                    totalError += error;                    //      totalError += nearestGreen4(green' g0' g1);                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenIndices,The following statement contains a magic number: int color2 = palette[2].g;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenIndices,The following statement contains a magic number: int color3 = palette[3].g;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  int color = rgba.color[i].g;                    uint d0 = greenDistance(color0' color);                  uint d1 = greenDistance(color1' color);                  uint d2 = greenDistance(color2' color);                  uint d3 = greenDistance(color3' color);                    uint b0 = d0 > d3 ? (uint)1 : (uint)0;                  uint b1 = d1 > d2 ? (uint)1 : (uint)0;                  uint b2 = d0 > d2 ? (uint)1 : (uint)0;                  uint b3 = d1 > d3 ? (uint)1 : (uint)0;                  uint b4 = d2 > d3 ? (uint)1 : (uint)0;                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                    indices |= (x2 | ((x0 | x1) << 1)) << (int)(2 * i);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeGreenIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  int color = rgba.color[i].g;                    uint d0 = greenDistance(color0' color);                  uint d1 = greenDistance(color1' color);                  uint d2 = greenDistance(color2' color);                  uint d3 = greenDistance(color3' color);                    uint b0 = d0 > d3 ? (uint)1 : (uint)0;                  uint b1 = d1 > d2 ? (uint)1 : (uint)0;                  uint b2 = d0 > d2 ? (uint)1 : (uint)0;                  uint b3 = d1 > d3 ? (uint)1 : (uint)0;                  uint b4 = d2 > d3 ? (uint)1 : (uint)0;                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                    indices |= (x2 | ((x0 | x1) << 1)) << (int)(2 * i);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: int q0 = Math.Max((int)(a >> 4) - 1' 0);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: int q1 = (a >> 4);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: int q2 = Math.Max((int)(a >> 4) + 1' 0xF);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: q0 = (q0 << 4) | q0;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: q1 = (q1 << 4) | q1;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: q2 = (q2 << 4) | q2;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: if (d0 < d1 && d0 < d2) return (uint)(q0 >> 4);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: if (d1 < d2) return (uint)(q1 >> 4);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,quantize4,The following statement contains a magic number: return (uint)(q2 >> 4);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,nearestAlpha8,The following statement contains a magic number: return (index * minAlpha + (7 - index) * maxAlpha) / 7;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,nearestAlpha8,The following statement contains a magic number: return (index * minAlpha + (7 - index) * maxAlpha) / 7;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError,The following statement contains a magic number: byte[] alphas = new byte[8];
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte alpha = src.alpha[i];                    uint minDist = int.MaxValue;                  for (uint p = 0; p < 8; p++)                  {                      uint dist = alphaDistance(alpha' alphas[p]);                      minDist = Math.Min(dist' minDist);                  }                    totalError += minDist * src.weights[i];                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte alpha = src.alpha[i];                    uint minDist = int.MaxValue;                  for (uint p = 0; p < 8; p++)                  {                      uint dist = alphaDistance(alpha' alphas[p]);                      minDist = Math.Min(dist' minDist);                  }                    totalError += minDist * src.weights[i];                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices,The following statement contains a magic number: byte[] alphas = new byte[8];
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte alpha = src.alpha[i];                    uint minDist = int.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      uint dist = alphaDistance(alpha' alphas[p]);                        if (dist < minDist)                      {                          minDist = dist;                          bestIndex = p;                      }                  }                  dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte alpha = src.alpha[i];                    uint minDist = int.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      uint dist = alphaDistance(alpha' alphas[p]);                        if (dist < minDist)                      {                          minDist = dist;                          bestIndex = p;                      }                  }                  dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte alpha = src.alpha[i];                    uint minDist = int.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      uint dist = alphaDistance(alpha' alphas[p]);                        if (dist < minDist)                      {                          minDist = dist;                          bestIndex = p;                      }                  }                  dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,Mul8Bit,The following statement contains a magic number: int t = a * b + 128;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,Mul8Bit,The following statement contains a magic number: return (t + (t >> 8)) >> 8;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,Mul8Bit,The following statement contains a magic number: return (t + (t >> 8)) >> 8;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,Lerp13,The following statement contains a magic number: return (a * 2 + b) / 3;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,Lerp13,The following statement contains a magic number: return (a * 2 + b) / 3;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,PrepareOptTable,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  int bestErr = 256 * 100;                    for (int min = 0; min < size; min++)                  {                      for (int max = 0; max < size; max++)                      {                          int mine = expand[min];                          int maxe = expand[max];                            int err;                          if (alpha_mode) err = Math.Abs((maxe + mine) / 2 - i);                          else err = Math.Abs(Lerp13(maxe' mine) - i);                          err *= 100;                            // DX10 spec says that interpolation must be within 3% of "correct" result'                          // add this as error term. (normally we'd expect a random distribution of                          // +-1.5% error' but nowhere in the spec does it say that the error has to be                          // unbiased - better safe than sorry).                          err += Math.Abs(max - min) * 3;                            if (err < bestErr)                          {                              table[i * 2' 0] = (byte)max;                              table[i * 2' 1] = (byte)min;                              bestErr = err;                          }                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,PrepareOptTable,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  int bestErr = 256 * 100;                    for (int min = 0; min < size; min++)                  {                      for (int max = 0; max < size; max++)                      {                          int mine = expand[min];                          int maxe = expand[max];                            int err;                          if (alpha_mode) err = Math.Abs((maxe + mine) / 2 - i);                          else err = Math.Abs(Lerp13(maxe' mine) - i);                          err *= 100;                            // DX10 spec says that interpolation must be within 3% of "correct" result'                          // add this as error term. (normally we'd expect a random distribution of                          // +-1.5% error' but nowhere in the spec does it say that the error has to be                          // unbiased - better safe than sorry).                          err += Math.Abs(max - min) * 3;                            if (err < bestErr)                          {                              table[i * 2' 0] = (byte)max;                              table[i * 2' 1] = (byte)min;                              bestErr = err;                          }                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,PrepareOptTable,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  int bestErr = 256 * 100;                    for (int min = 0; min < size; min++)                  {                      for (int max = 0; max < size; max++)                      {                          int mine = expand[min];                          int maxe = expand[max];                            int err;                          if (alpha_mode) err = Math.Abs((maxe + mine) / 2 - i);                          else err = Math.Abs(Lerp13(maxe' mine) - i);                          err *= 100;                            // DX10 spec says that interpolation must be within 3% of "correct" result'                          // add this as error term. (normally we'd expect a random distribution of                          // +-1.5% error' but nowhere in the spec does it say that the error has to be                          // unbiased - better safe than sorry).                          err += Math.Abs(max - min) * 3;                            if (err < bestErr)                          {                              table[i * 2' 0] = (byte)max;                              table[i * 2' 1] = (byte)min;                              bestErr = err;                          }                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,PrepareOptTable,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  int bestErr = 256 * 100;                    for (int min = 0; min < size; min++)                  {                      for (int max = 0; max < size; max++)                      {                          int mine = expand[min];                          int maxe = expand[max];                            int err;                          if (alpha_mode) err = Math.Abs((maxe + mine) / 2 - i);                          else err = Math.Abs(Lerp13(maxe' mine) - i);                          err *= 100;                            // DX10 spec says that interpolation must be within 3% of "correct" result'                          // add this as error term. (normally we'd expect a random distribution of                          // +-1.5% error' but nowhere in the spec does it say that the error has to be                          // unbiased - better safe than sorry).                          err += Math.Abs(max - min) * 3;                            if (err < bestErr)                          {                              table[i * 2' 0] = (byte)max;                              table[i * 2' 1] = (byte)min;                              bestErr = err;                          }                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,PrepareOptTable,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  int bestErr = 256 * 100;                    for (int min = 0; min < size; min++)                  {                      for (int max = 0; max < size; max++)                      {                          int mine = expand[min];                          int maxe = expand[max];                            int err;                          if (alpha_mode) err = Math.Abs((maxe + mine) / 2 - i);                          else err = Math.Abs(Lerp13(maxe' mine) - i);                          err *= 100;                            // DX10 spec says that interpolation must be within 3% of "correct" result'                          // add this as error term. (normally we'd expect a random distribution of                          // +-1.5% error' but nowhere in the spec does it say that the error has to be                          // unbiased - better safe than sorry).                          err += Math.Abs(max - min) * 3;                            if (err < bestErr)                          {                              table[i * 2' 0] = (byte)max;                              table[i * 2' 1] = (byte)min;                              bestErr = err;                          }                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,PrepareOptTable,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  int bestErr = 256 * 100;                    for (int min = 0; min < size; min++)                  {                      for (int max = 0; max < size; max++)                      {                          int mine = expand[min];                          int maxe = expand[max];                            int err;                          if (alpha_mode) err = Math.Abs((maxe + mine) / 2 - i);                          else err = Math.Abs(Lerp13(maxe' mine) - i);                          err *= 100;                            // DX10 spec says that interpolation must be within 3% of "correct" result'                          // add this as error term. (normally we'd expect a random distribution of                          // +-1.5% error' but nowhere in the spec does it say that the error has to be                          // unbiased - better safe than sorry).                          err += Math.Abs(max - min) * 3;                            if (err < bestErr)                          {                              table[i * 2' 0] = (byte)max;                              table[i * 2' 1] = (byte)min;                              bestErr = err;                          }                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,PrepareOptTable,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  int bestErr = 256 * 100;                    for (int min = 0; min < size; min++)                  {                      for (int max = 0; max < size; max++)                      {                          int mine = expand[min];                          int maxe = expand[max];                            int err;                          if (alpha_mode) err = Math.Abs((maxe + mine) / 2 - i);                          else err = Math.Abs(Lerp13(maxe' mine) - i);                          err *= 100;                            // DX10 spec says that interpolation must be within 3% of "correct" result'                          // add this as error term. (normally we'd expect a random distribution of                          // +-1.5% error' but nowhere in the spec does it say that the error has to be                          // unbiased - better safe than sorry).                          err += Math.Abs(max - min) * 3;                            if (err < bestErr)                          {                              table[i * 2' 0] = (byte)max;                              table[i * 2' 1] = (byte)min;                              bestErr = err;                          }                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,PrepareOptTable,The following statement contains a magic number: for (int i = 0; i < 256; i++)              {                  int bestErr = 256 * 100;                    for (int min = 0; min < size; min++)                  {                      for (int max = 0; max < size; max++)                      {                          int mine = expand[min];                          int maxe = expand[max];                            int err;                          if (alpha_mode) err = Math.Abs((maxe + mine) / 2 - i);                          else err = Math.Abs(Lerp13(maxe' mine) - i);                          err *= 100;                            // DX10 spec says that interpolation must be within 3% of "correct" result'                          // add this as error term. (normally we'd expect a random distribution of                          // +-1.5% error' but nowhere in the spec does it say that the error has to be                          // unbiased - better safe than sorry).                          err += Math.Abs(max - min) * 3;                            if (err < bestErr)                          {                              table[i * 2' 0] = (byte)max;                              table[i * 2' 1] = (byte)min;                              bestErr = err;                          }                      }                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,initSingleColorLookup,The following statement contains a magic number: if (!init)              {                  init = true;                  byte[] expand5 = new byte[32];                  byte[] expand6 = new byte[64];                    for (int i = 0; i < 32; i++)                  {                      expand5[i] = (byte)((i << 3) | (i >> 2));                  }                    for (int i = 0; i < 64; i++)                  {                      expand6[i] = (byte)((i << 2) | (i >> 4));                  }                    PrepareOptTable(OMatch5' expand5' 32' false);                  PrepareOptTable(OMatch6' expand6' 64' false);                  PrepareOptTable(OMatchAlpha5' expand5' 32' true);                  PrepareOptTable(OMatchAlpha6' expand6' 64' true);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: dxtBlock.col0.r = 31;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: dxtBlock.col1.r = 31;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: byte ming = 63;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte green = (byte)((rgba.color[i].g + 1) >> 2);                  ming = Math.Min(ming' green);                  maxg = Math.Max(maxg' green);                    if (rgba.color[i].g != singleColor) isSingleColor = false;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte green = (byte)((rgba.color[i].g + 1) >> 2);                  ming = Math.Min(ming' green);                  maxg = Math.Max(maxg' green);                    if (rgba.color[i].g != singleColor) isSingleColor = false;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: block.col0.r = 31;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: block.col1.r = 31;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: int greenExpand = 4;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: maxg = (byte)((maxg >= 63 - greenExpand) ? 63 : maxg + greenExpand);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: maxg = (byte)((maxg >= 63 - greenExpand) ? 63 : maxg + greenExpand);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1G,The following statement contains a magic number: Color32[] palette = new Color32[4];
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT1_Luma,The following statement contains a magic number: Color32[] palette = new Color32[4];
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: byte mina = 255;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: byte mina_no01 = 255;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte alpha = src.alpha[i];                  mina = Math.Min(mina' alpha);                  maxa = Math.Max(maxa' alpha);                    if (alpha != 0 && alpha != 255)                  {                      mina_no01 = Math.Min(mina_no01' alpha);                      maxa_no01 = Math.Max(maxa_no01' alpha);                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  byte alpha = src.alpha[i];                  mina = Math.Min(mina' alpha);                  maxa = Math.Max(maxa' alpha);                    if (alpha != 0 && alpha != 255)                  {                      mina_no01 = Math.Min(mina_no01' alpha);                      maxa_no01 = Math.Max(maxa_no01' alpha);                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: if (maxa - mina < 8)              {                  dst.alpha0 = maxa;                  dst.alpha1 = mina;                }              else if (maxa_no01 - mina_no01 < 6)              {                  dst.alpha0 = mina_no01;                  dst.alpha1 = maxa_no01;                }              else              {                  float besterror = computeAlphaError(src' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                          dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError(src' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError(src' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A,The following statement contains a magic number: tmp.init(src' 3);
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError_RGBM,The following statement contains a magic number: byte[] alphas = new byte[8];
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        minDist = Mathf.Min(error' minDist);                  }                    totalError += minDist * src.weights[i];                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        minDist = Mathf.Min(error' minDist);                  }                    totalError += minDist * src.weights[i];                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        minDist = Mathf.Min(error' minDist);                  }                    totalError += minDist * src.weights[i];                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        minDist = Mathf.Min(error' minDist);                  }                    totalError += minDist * src.weights[i];                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaError_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        minDist = Mathf.Min(error' minDist);                  }                    totalError += minDist * src.weights[i];                    if (totalError > bestError)                  {                      // early out                      return totalError;                  }              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices_RGBM,The following statement contains a magic number: byte[] alphas = new byte[8];
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        if (error < minDist)                      {                          minDist = error;                          bestIndex = p;                      }                  }                    dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        if (error < minDist)                      {                          minDist = error;                          bestIndex = p;                      }                  }                    dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        if (error < minDist)                      {                          minDist = error;                          bestIndex = p;                      }                  }                    dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        if (error < minDist)                      {                          minDist = error;                          bestIndex = p;                      }                  }                    dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        if (error < minDist)                      {                          minDist = error;                          bestIndex = p;                      }                  }                    dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,computeAlphaIndices_RGBM,The following statement contains a magic number: for (uint i = 0; i < 16; i++)              {                  float R = src.color[i].x;                  float G = src.color[i].y;                  float B = src.color[i].z;                    float r = (float)(RGB.color[i].r) / 255.0f;                  float g = (float)(RGB.color[i].g) / 255.0f;                  float b = (float)(RGB.color[i].b) / 255.0f;                    float minDist = float.MaxValue;                  uint bestIndex = 8;                  for (uint p = 0; p < 8; p++)                  {                      // Compute M.                      float M = (float)(alphas[p]) / 255.0f * (1 - threshold) + threshold;                        // Decode color.                      float fr = r * M;                      float fg = g * M;                      float fb = b * M;                        // Measure error.                      float error = Mathf.Pow(R - fr' 2) + Mathf.Pow(G - fg' 2) + Mathf.Pow(B - fb' 2);                        if (error < minDist)                      {                          minDist = error;                          bestIndex = p;                      }                  }                    dst.setIndex(i' bestIndex);              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: byte mina = 255;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: byte mina_no01 = 255;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: maxa = 255;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: maxa_no01 = 255;
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,OptimalCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\OptimalCompress.cs,compressDXT5A_RGBM,The following statement contains a magic number: {                  float besterror = computeAlphaError_RGBM(src' RGB' dst);                  byte besta0 = maxa;                  byte besta1 = mina;                    // Expand search space a bit.                  int alphaExpand = 8;                  mina = (byte)((mina <= alphaExpand) ? 0 : mina - alphaExpand);                  maxa = (byte)((maxa >= 255 - alphaExpand) ? 255 : maxa + alphaExpand);                    for (byte a0 = (byte)(mina + 9); a0 < maxa; a0++)                  {                      for (byte a1 = mina; a1 < a0 - 8; a1++)                      {                            dst.alpha0 = a0;                          dst.alpha1 = a1;                          float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                            if (error < besterror)                          {                              besterror = error;                              besta0 = a0;                              besta1 = a1;                          }                      }                  }                    // Try using the 6 step encoding.                  /*if (mina == 0 || maxa == 255)*/                  {                        // Expand search space a bit.                      alphaExpand = 6;                      mina_no01 = (byte)((mina_no01 <= alphaExpand) ? 0 : mina_no01 - alphaExpand);                      maxa_no01 = (byte)((maxa_no01 >= 255 - alphaExpand) ? 255 : maxa_no01 + alphaExpand);                        for (byte a0 = (byte)(mina_no01 + 9); a0 < maxa_no01; a0++)                      {                          for (byte a1 = mina_no01; a1 < a0 - 8; a1++)                          {                              dst.alpha0 = a1;                              dst.alpha1 = a0;                              float error = computeAlphaError_RGBM(src' RGB' dst' besterror);                                if (error < besterror)                              {                                  besterror = error;                                  besta0 = a1;                                  besta1 = a0;                              }                          }                      }                  }                    dst.alpha0 = besta0;                  dst.alpha1 = besta1;              }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,extractColorBlockRGB,The following statement contains a magic number: for (uint i = 0; i < 16; i++)          {                  Color32 c = rgba.color[i];                  block[i] = new Vector3(c.r' c.g' c.b);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,extractColorBlockRGBA,The following statement contains a magic number: for (uint i = 0; i < 16; i++)          {                  Color32 c = rgba.color[i];                  if (c.a > 127)                  {                          block[num++] = new Vector3(c.r' c.g' c.b);                  }          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,extractColorBlockRGBA,The following statement contains a magic number: for (uint i = 0; i < 16; i++)          {                  Color32 c = rgba.color[i];                  if (c.a > 127)                  {                          block[num++] = new Vector3(c.r' c.g' c.b);                  }          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,findMinMaxColorsBox,The following statement contains a magic number: minColor = new Vector3(255' 255' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,findMinMaxColorsBox,The following statement contains a magic number: minColor = new Vector3(255' 255' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,findMinMaxColorsBox,The following statement contains a magic number: minColor = new Vector3(255' 255' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float r0 = ((r+0) << 3) | ((r+0) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float r0 = ((r+0) << 3) | ((r+0) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float r1 = ((r+1) << 3) | ((r+1) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float r1 = ((r+1) << 3) | ((r+1) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float g0 = ((g+0) << 2) | ((g+0) >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float g0 = ((g+0) << 2) | ((g+0) >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float g1 = ((g+1) << 2) | ((g+1) >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float g1 = ((g+1) << 2) | ((g+1) >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float b0 = ((b+0) << 3) | ((b+0) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float b0 = ((b+0) << 3) | ((b+0) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float b1 = ((b+1) << 3) | ((b+1) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: float b1 = ((b+1) << 3) | ((b+1) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: ushort w = (ushort)((r << 11) | (g << 5) | b);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: ushort w = (ushort)((r << 11) | (g << 5) | b);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: r = (r << 3) | (r >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: r = (r << 3) | (r >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: g = (g << 2) | (g >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: g = (g << 2) | (g >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: b = (b << 3) | (b >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand,The following statement contains a magic number: b = (b << 3) | (b >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float r0 = ((r+0) << 3) | ((r+0) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float r0 = ((r+0) << 3) | ((r+0) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float r1 = ((r+1) << 3) | ((r+1) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float r1 = ((r+1) << 3) | ((r+1) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float g0 = ((g+0) << 2) | ((g+0) >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float g0 = ((g+0) << 2) | ((g+0) >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float g1 = ((g+1) << 2) | ((g+1) >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float g1 = ((g+1) << 2) | ((g+1) >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float b0 = ((b+0) << 3) | ((b+0) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float b0 = ((b+0) << 3) | ((b+0) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float b1 = ((b+1) << 3) | ((b+1) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: float b1 = ((b+1) << 3) | ((b+1) >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: ushort w = (ushort)((r << 11) | (g << 5) | b);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: ushort w = (ushort)((r << 11) | (g << 5) | b);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: r = (r << 3) | (r >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: r = (r << 3) | (r >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: g = (g << 2) | (g >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: g = (g << 2) | (g >> 4);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: b = (b << 3) | (b >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,roundAndExpand01,The following statement contains a magic number: b = (b << 3) | (b >> 2);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: Vector3[] palette = new Vector3[4];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: palette[2] = Vector3.Lerp(palette[0]' palette[1]' 1.0f / 3.0f);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: palette[3] = Vector3.Lerp(palette[0]' palette[1]' 2.0f / 3.0f);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for(int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  float d3 = colorDistance(palette[3]' block[i]);                                uint b0 = d0 > d3? (uint)1 : (uint)0;                  uint b1 = d1 > d2? (uint)1 : (uint)0;                  uint b2 = d0 > d2? (uint)1 : (uint)0;                  uint b3 = d1 > d3? (uint)1 : (uint)0;                  uint b4 = d2 > d3? (uint)1 : (uint)0;                                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                                    indices |= (x2 | ((x0 | x1) << 1)) << (2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for(int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  float d3 = colorDistance(palette[3]' block[i]);                                uint b0 = d0 > d3? (uint)1 : (uint)0;                  uint b1 = d1 > d2? (uint)1 : (uint)0;                  uint b2 = d0 > d2? (uint)1 : (uint)0;                  uint b3 = d1 > d3? (uint)1 : (uint)0;                  uint b4 = d2 > d3? (uint)1 : (uint)0;                                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                                    indices |= (x2 | ((x0 | x1) << 1)) << (2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for(int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  float d3 = colorDistance(palette[3]' block[i]);                                uint b0 = d0 > d3? (uint)1 : (uint)0;                  uint b1 = d1 > d2? (uint)1 : (uint)0;                  uint b2 = d0 > d2? (uint)1 : (uint)0;                  uint b3 = d1 > d3? (uint)1 : (uint)0;                  uint b4 = d2 > d3? (uint)1 : (uint)0;                                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                                    indices |= (x2 | ((x0 | x1) << 1)) << (2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for(int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  float d3 = colorDistance(palette[3]' block[i]);                                uint b0 = d0 > d3? (uint)1 : (uint)0;                  uint b1 = d1 > d2? (uint)1 : (uint)0;                  uint b2 = d0 > d2? (uint)1 : (uint)0;                  uint b3 = d1 > d3? (uint)1 : (uint)0;                  uint b4 = d2 > d3? (uint)1 : (uint)0;                                    uint x0 = b1 & b2;                  uint x1 = b0 & b3;                  uint x2 = b0 & b4;                                    indices |= (x2 | ((x0 | x1) << 1)) << (2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: Vector3[] palette = new Vector3[4];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: palette[2] = Vector3.Lerp(palette[0]' palette[1]' 1.0f / 3.0f);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: palette[3] = Vector3.Lerp(palette[0]' palette[1]' 2.0f / 3.0f);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: Vector3[] row0 = new Vector3[6];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: Vector3[] row1 = new Vector3[6];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for (uint y = 0; y < 4; y++) {                  for (uint x = 0; x < 4; x++) {              uint i = y*4+x;                if (!set.isValidIndex(i)) {                  // Skip masked pixels and out of bounds.                  continue;              }                Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                // Add error.              color += row0[1+x];                        float d0 = colorDistance(palette[0]' color);                      float d1 = colorDistance(palette[1]' color);                      float d2 = colorDistance(palette[2]' color);                      float d3 = colorDistance(palette[3]' color);                                        uint b0 = d0 > d3?(uint)1:(uint)0;                      uint b1 = d1 > d2?(uint)1:(uint)0;                      uint b2 = d0 > d2?(uint)1:(uint)0;                      uint b3 = d1 > d3?(uint)1:(uint)0;                      uint b4 = d2 > d3?(uint)1:(uint)0;                                        uint x0 = b1 & b2;                      uint x1 = b0 & b3;                      uint x2 = b0 & b4;                uint index = x2 | ((x0 | x1) << 1);                      indices |= index << (int)(2 * i);                        // Compute new error.                      Vector3 diff = color - palette[index];                                    // Propagate new error.                      //row0[1+x+1] += 7.0f / 16.0f * diff;                      //row1[1+x-1] += 3.0f / 16.0f * diff;                      //row1[1+x+0] += 5.0f / 16.0f * diff;                      //row1[1+x+1] += 1.0f / 16.0f * diff;          }                    swap(ref row0' ref row1);                  row1 = new Vector3[6];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for (uint y = 0; y < 4; y++) {                  for (uint x = 0; x < 4; x++) {              uint i = y*4+x;                if (!set.isValidIndex(i)) {                  // Skip masked pixels and out of bounds.                  continue;              }                Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                // Add error.              color += row0[1+x];                        float d0 = colorDistance(palette[0]' color);                      float d1 = colorDistance(palette[1]' color);                      float d2 = colorDistance(palette[2]' color);                      float d3 = colorDistance(palette[3]' color);                                        uint b0 = d0 > d3?(uint)1:(uint)0;                      uint b1 = d1 > d2?(uint)1:(uint)0;                      uint b2 = d0 > d2?(uint)1:(uint)0;                      uint b3 = d1 > d3?(uint)1:(uint)0;                      uint b4 = d2 > d3?(uint)1:(uint)0;                                        uint x0 = b1 & b2;                      uint x1 = b0 & b3;                      uint x2 = b0 & b4;                uint index = x2 | ((x0 | x1) << 1);                      indices |= index << (int)(2 * i);                        // Compute new error.                      Vector3 diff = color - palette[index];                                    // Propagate new error.                      //row0[1+x+1] += 7.0f / 16.0f * diff;                      //row1[1+x-1] += 3.0f / 16.0f * diff;                      //row1[1+x+0] += 5.0f / 16.0f * diff;                      //row1[1+x+1] += 1.0f / 16.0f * diff;          }                    swap(ref row0' ref row1);                  row1 = new Vector3[6];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for (uint y = 0; y < 4; y++) {                  for (uint x = 0; x < 4; x++) {              uint i = y*4+x;                if (!set.isValidIndex(i)) {                  // Skip masked pixels and out of bounds.                  continue;              }                Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                // Add error.              color += row0[1+x];                        float d0 = colorDistance(palette[0]' color);                      float d1 = colorDistance(palette[1]' color);                      float d2 = colorDistance(palette[2]' color);                      float d3 = colorDistance(palette[3]' color);                                        uint b0 = d0 > d3?(uint)1:(uint)0;                      uint b1 = d1 > d2?(uint)1:(uint)0;                      uint b2 = d0 > d2?(uint)1:(uint)0;                      uint b3 = d1 > d3?(uint)1:(uint)0;                      uint b4 = d2 > d3?(uint)1:(uint)0;                                        uint x0 = b1 & b2;                      uint x1 = b0 & b3;                      uint x2 = b0 & b4;                uint index = x2 | ((x0 | x1) << 1);                      indices |= index << (int)(2 * i);                        // Compute new error.                      Vector3 diff = color - palette[index];                                    // Propagate new error.                      //row0[1+x+1] += 7.0f / 16.0f * diff;                      //row1[1+x-1] += 3.0f / 16.0f * diff;                      //row1[1+x+0] += 5.0f / 16.0f * diff;                      //row1[1+x+1] += 1.0f / 16.0f * diff;          }                    swap(ref row0' ref row1);                  row1 = new Vector3[6];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for (uint y = 0; y < 4; y++) {                  for (uint x = 0; x < 4; x++) {              uint i = y*4+x;                if (!set.isValidIndex(i)) {                  // Skip masked pixels and out of bounds.                  continue;              }                Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                // Add error.              color += row0[1+x];                        float d0 = colorDistance(palette[0]' color);                      float d1 = colorDistance(palette[1]' color);                      float d2 = colorDistance(palette[2]' color);                      float d3 = colorDistance(palette[3]' color);                                        uint b0 = d0 > d3?(uint)1:(uint)0;                      uint b1 = d1 > d2?(uint)1:(uint)0;                      uint b2 = d0 > d2?(uint)1:(uint)0;                      uint b3 = d1 > d3?(uint)1:(uint)0;                      uint b4 = d2 > d3?(uint)1:(uint)0;                                        uint x0 = b1 & b2;                      uint x1 = b0 & b3;                      uint x2 = b0 & b4;                uint index = x2 | ((x0 | x1) << 1);                      indices |= index << (int)(2 * i);                        // Compute new error.                      Vector3 diff = color - palette[index];                                    // Propagate new error.                      //row0[1+x+1] += 7.0f / 16.0f * diff;                      //row1[1+x-1] += 3.0f / 16.0f * diff;                      //row1[1+x+0] += 5.0f / 16.0f * diff;                      //row1[1+x+1] += 1.0f / 16.0f * diff;          }                    swap(ref row0' ref row1);                  row1 = new Vector3[6];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for (uint y = 0; y < 4; y++) {                  for (uint x = 0; x < 4; x++) {              uint i = y*4+x;                if (!set.isValidIndex(i)) {                  // Skip masked pixels and out of bounds.                  continue;              }                Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                // Add error.              color += row0[1+x];                        float d0 = colorDistance(palette[0]' color);                      float d1 = colorDistance(palette[1]' color);                      float d2 = colorDistance(palette[2]' color);                      float d3 = colorDistance(palette[3]' color);                                        uint b0 = d0 > d3?(uint)1:(uint)0;                      uint b1 = d1 > d2?(uint)1:(uint)0;                      uint b2 = d0 > d2?(uint)1:(uint)0;                      uint b3 = d1 > d3?(uint)1:(uint)0;                      uint b4 = d2 > d3?(uint)1:(uint)0;                                        uint x0 = b1 & b2;                      uint x1 = b0 & b3;                      uint x2 = b0 & b4;                uint index = x2 | ((x0 | x1) << 1);                      indices |= index << (int)(2 * i);                        // Compute new error.                      Vector3 diff = color - palette[index];                                    // Propagate new error.                      //row0[1+x+1] += 7.0f / 16.0f * diff;                      //row1[1+x-1] += 3.0f / 16.0f * diff;                      //row1[1+x+0] += 5.0f / 16.0f * diff;                      //row1[1+x+1] += 1.0f / 16.0f * diff;          }                    swap(ref row0' ref row1);                  row1 = new Vector3[6];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for (uint y = 0; y < 4; y++) {                  for (uint x = 0; x < 4; x++) {              uint i = y*4+x;                if (!set.isValidIndex(i)) {                  // Skip masked pixels and out of bounds.                  continue;              }                Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                // Add error.              color += row0[1+x];                        float d0 = colorDistance(palette[0]' color);                      float d1 = colorDistance(palette[1]' color);                      float d2 = colorDistance(palette[2]' color);                      float d3 = colorDistance(palette[3]' color);                                        uint b0 = d0 > d3?(uint)1:(uint)0;                      uint b1 = d1 > d2?(uint)1:(uint)0;                      uint b2 = d0 > d2?(uint)1:(uint)0;                      uint b3 = d1 > d3?(uint)1:(uint)0;                      uint b4 = d2 > d3?(uint)1:(uint)0;                                        uint x0 = b1 & b2;                      uint x1 = b0 & b3;                      uint x2 = b0 & b4;                uint index = x2 | ((x0 | x1) << 1);                      indices |= index << (int)(2 * i);                        // Compute new error.                      Vector3 diff = color - palette[index];                                    // Propagate new error.                      //row0[1+x+1] += 7.0f / 16.0f * diff;                      //row1[1+x-1] += 3.0f / 16.0f * diff;                      //row1[1+x+0] += 5.0f / 16.0f * diff;                      //row1[1+x+1] += 1.0f / 16.0f * diff;          }                    swap(ref row0' ref row1);                  row1 = new Vector3[6];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices4,The following statement contains a magic number: for (uint y = 0; y < 4; y++) {                  for (uint x = 0; x < 4; x++) {              uint i = y*4+x;                if (!set.isValidIndex(i)) {                  // Skip masked pixels and out of bounds.                  continue;              }                Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                // Add error.              color += row0[1+x];                        float d0 = colorDistance(palette[0]' color);                      float d1 = colorDistance(palette[1]' color);                      float d2 = colorDistance(palette[2]' color);                      float d3 = colorDistance(palette[3]' color);                                        uint b0 = d0 > d3?(uint)1:(uint)0;                      uint b1 = d1 > d2?(uint)1:(uint)0;                      uint b2 = d0 > d2?(uint)1:(uint)0;                      uint b3 = d1 > d3?(uint)1:(uint)0;                      uint b4 = d2 > d3?(uint)1:(uint)0;                                        uint x0 = b1 & b2;                      uint x1 = b0 & b3;                      uint x2 = b0 & b4;                uint index = x2 | ((x0 | x1) << 1);                      indices |= index << (int)(2 * i);                        // Compute new error.                      Vector3 diff = color - palette[index];                                    // Propagate new error.                      //row0[1+x+1] += 7.0f / 16.0f * diff;                      //row1[1+x-1] += 3.0f / 16.0f * diff;                      //row1[1+x+0] += 5.0f / 16.0f * diff;                      //row1[1+x+1] += 1.0f / 16.0f * diff;          }                    swap(ref row0' ref row1);                  row1 = new Vector3[6];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError4,The following statement contains a magic number: Vector3[] palette = new Vector3[4];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError4,The following statement contains a magic number: palette[2] = Vector3.Lerp(palette[0]' palette[1]' 1.0f / 3.0f);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError4,The following statement contains a magic number: palette[3] = Vector3.Lerp(palette[0]' palette[1]' 2.0f / 3.0f);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError4,The following statement contains a magic number: for (int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  float d3 = colorDistance(palette[3]' block[i]);                    total += Mathf.Min(Mathf.Min(d0' d1)' Mathf.Min(d2' d3));          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError4,The following statement contains a magic number: for (int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  float d3 = colorDistance(palette[3]' block[i]);                    total += Mathf.Min(Mathf.Min(d0' d1)' Mathf.Min(d2' d3));          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError4,The following statement contains a magic number: for (int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  float d3 = colorDistance(palette[3]' block[i]);                    total += Mathf.Min(Mathf.Min(d0' d1)' Mathf.Min(d2' d3));          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError3,The following statement contains a magic number: Vector3[] palette = new Vector3[4];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError3,The following statement contains a magic number: palette[2] = (palette[0] + palette[1]) * 0.5f;
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError3,The following statement contains a magic number: palette[3] = Vector3.zero;
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError3,The following statement contains a magic number: for (int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  //float d3 = colorDistance(palette[3]' block[i]);                    //total += min(min(d0' d1)' min(d2' d3));          total += Mathf.Min(Mathf.Min(d0' d1)' d2);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,evaluatePaletteError3,The following statement contains a magic number: for (int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                  //float d3 = colorDistance(palette[3]' block[i]);                    //total += min(min(d0' d1)' min(d2' d3));          total += Mathf.Min(Mathf.Min(d0' d1)' d2);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: Vector3[] palette = new Vector3[4];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: palette[2] = (palette[0] + palette[1]) * 0.5f;
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(uint i = 0; i < 16; i++)          {          if (!set.isValidIndex(i)) {              // Skip masked pixels and out of bounds.              indices |= (uint) 3 << (int)(2 * i);              continue;          }            Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                                    float d0 = colorDistance(palette[0]' color);                  float d1 = colorDistance(palette[1]' color);                  float d2 = colorDistance(palette[2]' color);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (int)(2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(uint i = 0; i < 16; i++)          {          if (!set.isValidIndex(i)) {              // Skip masked pixels and out of bounds.              indices |= (uint) 3 << (int)(2 * i);              continue;          }            Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                                    float d0 = colorDistance(palette[0]' color);                  float d1 = colorDistance(palette[1]' color);                  float d2 = colorDistance(palette[2]' color);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (int)(2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(uint i = 0; i < 16; i++)          {          if (!set.isValidIndex(i)) {              // Skip masked pixels and out of bounds.              indices |= (uint) 3 << (int)(2 * i);              continue;          }            Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                                    float d0 = colorDistance(palette[0]' color);                  float d1 = colorDistance(palette[1]' color);                  float d2 = colorDistance(palette[2]' color);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (int)(2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(uint i = 0; i < 16; i++)          {          if (!set.isValidIndex(i)) {              // Skip masked pixels and out of bounds.              indices |= (uint) 3 << (int)(2 * i);              continue;          }            Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                                    float d0 = colorDistance(palette[0]' color);                  float d1 = colorDistance(palette[1]' color);                  float d2 = colorDistance(palette[2]' color);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (int)(2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(uint i = 0; i < 16; i++)          {          if (!set.isValidIndex(i)) {              // Skip masked pixels and out of bounds.              indices |= (uint) 3 << (int)(2 * i);              continue;          }            Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                                    float d0 = colorDistance(palette[0]' color);                  float d1 = colorDistance(palette[1]' color);                  float d2 = colorDistance(palette[2]' color);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (int)(2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(uint i = 0; i < 16; i++)          {          if (!set.isValidIndex(i)) {              // Skip masked pixels and out of bounds.              indices |= (uint) 3 << (int)(2 * i);              continue;          }            Vector3 color = new Vector3(set.color[i].x' set.color[i].y' set.color[i].z);                                    float d0 = colorDistance(palette[0]' color);                  float d1 = colorDistance(palette[1]' color);                  float d2 = colorDistance(palette[2]' color);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (int)(2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: Vector3[] palette = new Vector3[4];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: palette[2] = (palette[0] + palette[1]) * 0.5f;
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeIndices3,The following statement contains a magic number: for(int i = 0; i < 16; i++)          {                  float d0 = colorDistance(palette[0]' block[i]);                  float d1 = colorDistance(palette[1]' block[i]);                  float d2 = colorDistance(palette[2]' block[i]);                                    uint index;                  if (d0 < d1 && d0 < d2) index = 0;                  else if (d1 < d2) index = 1;                  else index = 2;                                    indices |= index << (2 * i);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: for( int i = 0; i < 16; ++i )          {                  uint bits = dxtBlock.indices >> (2 * i);                                    float beta = (bits & 1);                  if ((bits & 2) != 0) beta = (1 + beta) / 3.0f;                  float alpha = 1.0f - beta;                                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: for( int i = 0; i < 16; ++i )          {                  uint bits = dxtBlock.indices >> (2 * i);                                    float beta = (bits & 1);                  if ((bits & 2) != 0) beta = (1 + beta) / 3.0f;                  float alpha = 1.0f - beta;                                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: for( int i = 0; i < 16; ++i )          {                  uint bits = dxtBlock.indices >> (2 * i);                                    float beta = (bits & 1);                  if ((bits & 2) != 0) beta = (1 + beta) / 3.0f;                  float alpha = 1.0f - beta;                                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: a.x = Mathf.Clamp(a.x' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: a.y = Mathf.Clamp(a.y' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: a.z = Mathf.Clamp(a.z' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: b.x = Mathf.Clamp(b.x' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: b.y = Mathf.Clamp(b.y' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints4,The following statement contains a magic number: b.z = Mathf.Clamp(b.z' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: for( int i = 0; i < 16; ++i )          {                  uint bits = dxtBlock.indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) != 0) beta = 0.5f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: for( int i = 0; i < 16; ++i )          {                  uint bits = dxtBlock.indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) != 0) beta = 0.5f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: for( int i = 0; i < 16; ++i )          {                  uint bits = dxtBlock.indices >> (2 * i);                    float beta = (float)(bits & 1);                  if ((bits & 2) != 0) beta = 0.5f;                  float alpha = 1.0f - beta;                    alpha2_sum += alpha * alpha;                  beta2_sum += beta * beta;                  alphabeta_sum += alpha * beta;                  alphax_sum += alpha * block[i];                  betax_sum += beta * block[i];          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: a.x = Mathf.Clamp(a.x' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: a.y = Mathf.Clamp(a.y' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: a.z = Mathf.Clamp(a.z' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: b.x = Mathf.Clamp(b.x' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: b.y = Mathf.Clamp(b.y' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeEndPoints3,The following statement contains a magic number: b.z = Mathf.Clamp(b.z' 0' 255);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeAlphaIndices,The following statement contains a magic number: byte[] alphas = new byte[8];
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeAlphaIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)                  {                          byte alpha = src.alpha[i];                            uint besterror = 256*256;                          uint best = 8;                          for(uint p = 0; p < 8; p++)                          {                                  int d = alphas[p] - alpha;                                  uint error = (uint)(d * d);                                    if (error < besterror)                                  {                                          besterror = error;                                          best = p;                                  }                          }                          //nvDebugCheck(best < 8);                            totalError += besterror;                          block.setIndex(i' best);                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeAlphaIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)                  {                          byte alpha = src.alpha[i];                            uint besterror = 256*256;                          uint best = 8;                          for(uint p = 0; p < 8; p++)                          {                                  int d = alphas[p] - alpha;                                  uint error = (uint)(d * d);                                    if (error < besterror)                                  {                                          besterror = error;                                          best = p;                                  }                          }                          //nvDebugCheck(best < 8);                            totalError += besterror;                          block.setIndex(i' best);                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeAlphaIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)                  {                          byte alpha = src.alpha[i];                            uint besterror = 256*256;                          uint best = 8;                          for(uint p = 0; p < 8; p++)                          {                                  int d = alphas[p] - alpha;                                  uint error = (uint)(d * d);                                    if (error < besterror)                                  {                                          besterror = error;                                          best = p;                                  }                          }                          //nvDebugCheck(best < 8);                            totalError += besterror;                          block.setIndex(i' best);                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeAlphaIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)                  {                          byte alpha = src.alpha[i];                            uint besterror = 256*256;                          uint best = 8;                          for(uint p = 0; p < 8; p++)                          {                                  int d = alphas[p] - alpha;                                  uint error = (uint)(d * d);                                    if (error < besterror)                                  {                                          besterror = error;                                          best = p;                                  }                          }                          //nvDebugCheck(best < 8);                            totalError += besterror;                          block.setIndex(i' best);                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,computeAlphaIndices,The following statement contains a magic number: for (uint i = 0; i < 16; i++)                  {                          byte alpha = src.alpha[i];                            uint besterror = 256*256;                          uint best = 8;                          for(uint p = 0; p < 8; p++)                          {                                  int d = alphas[p] - alpha;                                  uint error = (uint)(d * d);                                    if (error < besterror)                                  {                                          besterror = error;                                          best = p;                                  }                          }                          //nvDebugCheck(best < 8);                            totalError += besterror;                          block.setIndex(i' best);                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeAlpha8,The following statement contains a magic number: for (uint i = 0; i < 16; i++)                  {                          uint idx = block.index(i);                          float alpha;                          if (idx < 2) alpha = 1.0f - idx;                          else alpha = (8.0f - idx) / 7.0f;                                                    float beta = 1 - alpha;                            alpha2_sum += alpha * alpha;                          beta2_sum += beta * beta;                          alphabeta_sum += alpha * beta;                          alphax_sum += alpha * src.alpha[i];                          betax_sum += beta * src.alpha[i];                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeAlpha8,The following statement contains a magic number: for (uint i = 0; i < 16; i++)                  {                          uint idx = block.index(i);                          float alpha;                          if (idx < 2) alpha = 1.0f - idx;                          else alpha = (8.0f - idx) / 7.0f;                                                    float beta = 1 - alpha;                            alpha2_sum += alpha * alpha;                          beta2_sum += beta * beta;                          alphabeta_sum += alpha * beta;                          alphax_sum += alpha * src.alpha[i];                          betax_sum += beta * src.alpha[i];                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeAlpha8,The following statement contains a magic number: if (alpha0 < alpha1)                  {                          swap(ref alpha0' ref alpha1);                            // Flip indices:                          for (uint i = 0; i < 16; i++)                          {                                  uint idx = block.index(i);                                  if (idx < 2) block.setIndex(i' 1 - idx);                                  else block.setIndex(i' 9 - idx);                          }                  }                  else if (alpha0 == alpha1)                  {                          for (uint i = 0; i < 16; i++)                          {                                  block.setIndex(i' 0);                          }                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeAlpha8,The following statement contains a magic number: if (alpha0 < alpha1)                  {                          swap(ref alpha0' ref alpha1);                            // Flip indices:                          for (uint i = 0; i < 16; i++)                          {                                  uint idx = block.index(i);                                  if (idx < 2) block.setIndex(i' 1 - idx);                                  else block.setIndex(i' 9 - idx);                          }                  }                  else if (alpha0 == alpha1)                  {                          for (uint i = 0; i < 16; i++)                          {                                  block.setIndex(i' 0);                          }                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeAlpha8,The following statement contains a magic number: if (alpha0 < alpha1)                  {                          swap(ref alpha0' ref alpha1);                            // Flip indices:                          for (uint i = 0; i < 16; i++)                          {                                  uint idx = block.index(i);                                  if (idx < 2) block.setIndex(i' 1 - idx);                                  else block.setIndex(i' 9 - idx);                          }                  }                  else if (alpha0 == alpha1)                  {                          for (uint i = 0; i < 16; i++)                          {                                  block.setIndex(i' 0);                          }                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,optimizeAlpha8,The following statement contains a magic number: if (alpha0 < alpha1)                  {                          swap(ref alpha0' ref alpha1);                            // Flip indices:                          for (uint i = 0; i < 16; i++)                          {                                  uint idx = block.index(i);                                  if (idx < 2) block.setIndex(i' 1 - idx);                                  else block.setIndex(i' 9 - idx);                          }                  }                  else if (alpha0 == alpha1)                  {                          for (uint i = 0; i < 16; i++)                          {                                  block.setIndex(i' 0);                          }                  }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT1,The following statement contains a magic number: if (rgba.isSingleColor())          {                  OptimalCompress.compressDXT1(rgba.color[0]' dxtBlock);          }          else          {                  // read block                  Vector3[] block = new Vector3[16];                  extractColorBlockRGB(rgba' block);  #if true                  // find min and max colors                  Vector3 maxColor = Vector3.zero' minColor = Vector3.zero;                  findMinMaxColorsBox(block' 16' ref maxColor' ref minColor);                                    selectDiagonal(block' 16' ref maxColor' ref minColor);                                    insetBBox(ref maxColor' ref minColor);  #else                  float[] weights = new float[16]{1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1};                  Vector3[] cluster = new Vector3[4];                  int count = Fitting.Compute4Means(16' block' weights' Vector3.one' cluster);                    Vector3 maxColor' minColor;                  float bestError = FLT_MAX;                    for (int i = 1; i < 4; i++)                  {                          for (int j = 0; j < i; j++)                          {                          uint16 color0 = roundAndExpand(&cluster[i]);                          uint16 color1 = roundAndExpand(&cluster[j]);                                    float error = evaluatePaletteError4(block' cluster[i]' cluster[j]);                                  if (error < bestError) {                                          bestError = error;                                          maxColor = cluster[i];                                          minColor = cluster[j];                                  }                          }                  }  #endif                    ushort color0 = roundAndExpand(ref maxColor);                  ushort color1 = roundAndExpand(ref minColor);                    if (color0 < color1)                  {                          swap(ref maxColor' ref minColor);                          swap(ref color0' ref color1);                  }                    dxtBlock.col0 = new Color16(color0);                  dxtBlock.col1 = new Color16(color1);                  dxtBlock.indices = computeIndices4(block' maxColor' minColor);                    optimizeEndPoints4(block' dxtBlock);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT1,The following statement contains a magic number: if (rgba.isSingleColor())          {                  OptimalCompress.compressDXT1(rgba.color[0]' dxtBlock);          }          else          {                  // read block                  Vector3[] block = new Vector3[16];                  extractColorBlockRGB(rgba' block);  #if true                  // find min and max colors                  Vector3 maxColor = Vector3.zero' minColor = Vector3.zero;                  findMinMaxColorsBox(block' 16' ref maxColor' ref minColor);                                    selectDiagonal(block' 16' ref maxColor' ref minColor);                                    insetBBox(ref maxColor' ref minColor);  #else                  float[] weights = new float[16]{1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1};                  Vector3[] cluster = new Vector3[4];                  int count = Fitting.Compute4Means(16' block' weights' Vector3.one' cluster);                    Vector3 maxColor' minColor;                  float bestError = FLT_MAX;                    for (int i = 1; i < 4; i++)                  {                          for (int j = 0; j < i; j++)                          {                          uint16 color0 = roundAndExpand(&cluster[i]);                          uint16 color1 = roundAndExpand(&cluster[j]);                                    float error = evaluatePaletteError4(block' cluster[i]' cluster[j]);                                  if (error < bestError) {                                          bestError = error;                                          maxColor = cluster[i];                                          minColor = cluster[j];                                  }                          }                  }  #endif                    ushort color0 = roundAndExpand(ref maxColor);                  ushort color1 = roundAndExpand(ref minColor);                    if (color0 < color1)                  {                          swap(ref maxColor' ref minColor);                          swap(ref color0' ref color1);                  }                    dxtBlock.col0 = new Color16(color0);                  dxtBlock.col1 = new Color16(color1);                  dxtBlock.indices = computeIndices4(block' maxColor' minColor);                    optimizeEndPoints4(block' dxtBlock);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT1,The following statement contains a magic number: if (rgba.isSingleColor())          {                  OptimalCompress.compressDXT1(rgba.color[0]' dxtBlock);          }          else          {                  // read block                  Vector3[] block = new Vector3[16];                  extractColorBlockRGB(rgba' block);  #if true                  // find min and max colors                  Vector3 maxColor = Vector3.zero' minColor = Vector3.zero;                  findMinMaxColorsBox(block' 16' ref maxColor' ref minColor);                                    selectDiagonal(block' 16' ref maxColor' ref minColor);                                    insetBBox(ref maxColor' ref minColor);  #else                  float[] weights = new float[16]{1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1' 1};                  Vector3[] cluster = new Vector3[4];                  int count = Fitting.Compute4Means(16' block' weights' Vector3.one' cluster);                    Vector3 maxColor' minColor;                  float bestError = FLT_MAX;                    for (int i = 1; i < 4; i++)                  {                          for (int j = 0; j < i; j++)                          {                          uint16 color0 = roundAndExpand(&cluster[i]);                          uint16 color1 = roundAndExpand(&cluster[j]);                                    float error = evaluatePaletteError4(block' cluster[i]' cluster[j]);                                  if (error < bestError) {                                          bestError = error;                                          maxColor = cluster[i];                                          minColor = cluster[j];                                  }                          }                  }  #endif                    ushort color0 = roundAndExpand(ref maxColor);                  ushort color1 = roundAndExpand(ref minColor);                    if (color0 < color1)                  {                          swap(ref maxColor' ref minColor);                          swap(ref color0' ref color1);                  }                    dxtBlock.col0 = new Color16(color0);                  dxtBlock.col1 = new Color16(color1);                  dxtBlock.indices = computeIndices4(block' maxColor' minColor);                    optimizeEndPoints4(block' dxtBlock);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT1a,The following statement contains a magic number: for (uint i = 0; i < 16; i++)          {                  if (rgba.color[i].a == 0) {                          hasAlpha = true;                          break;                  }          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT1a,The following statement contains a magic number: if (!hasAlpha)          {                  compressDXT1(rgba' dxtBlock);          }          // @@ Handle single RGB' with varying alpha? We need tables for single color compressor in 3 color mode.          //else if (rgba.isSingleColorNoAlpha()) { ... }          else           {                  // read block                  Vector3[] block = new Vector3[16];                  uint num = extractColorBlockRGBA(rgba' block);                                    // find min and max colors                  Vector3 maxColor = Vector3.zero' minColor = Vector3.zero;                  findMinMaxColorsBox(block' num' ref maxColor' ref minColor);                                    selectDiagonal(block' num' ref maxColor' ref minColor);                                    insetBBox(ref maxColor' ref minColor);                                    ushort color0 = roundAndExpand(ref maxColor);                  ushort color1 = roundAndExpand(ref minColor);                                    if (color0 < color1)                  {                          swap(ref maxColor' ref minColor);                          swap(ref color0' ref color1);                  }                                    dxtBlock.col0 = new Color16(color1);                  dxtBlock.col1 = new Color16(color0);                  dxtBlock.indices = computeIndices3(block' maxColor' minColor);                                    //      optimizeEndPoints(block' dxtBlock);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT5A,The following statement contains a magic number: tmp.init(src' 3);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT5A,The following statement contains a magic number: byte alpha1 = 255;
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT5A,The following statement contains a magic number: for (uint i = 0; i < 16; i++)          {                  byte alpha = src.alpha[i];                  alpha0 = Math.Max(alpha0' alpha);                  alpha1 = Math.Min(alpha1' alpha);          }
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT5A,The following statement contains a magic number: block.alpha0 = (byte)(alpha0 - (alpha0 - alpha1) / 34);
Magic Number,NvidiaTextureTools,QuickCompress,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\QuickCompress.cs,compressDXT5A,The following statement contains a magic number: block.alpha1 = (byte)(alpha1 + (alpha0 - alpha1) / 34);
Magic Number,NvidiaTextureTools,Tex2dxt,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Tex2dxt.cs,dxt1,The following statement contains a magic number: return new byte[2];
Magic Number,NvidiaTextureTools,Tex2dxt,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\Tex2dxt.cs,dxt5,The following statement contains a magic number: return new byte[2];
Magic Number,NvidiaTextureTools,TextureToolsDXT,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\TextureTools.cs,GetDXT,The following statement contains a magic number: int blocksize = format == TextureFormat.DXT1 ? 8 : 16;
Magic Number,NvidiaTextureTools,TextureToolsDXT,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\TextureTools.cs,GetDXT,The following statement contains a magic number: int blocksize = format == TextureFormat.DXT1 ? 8 : 16;
Magic Number,NvidiaTextureTools,TextureToolsDXT,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\TextureTools.cs,GetDXT,The following statement contains a magic number: for (uint y = 0; y < h; y += 4) {  		        for (uint x = 0; x < w; x += 4) {  			        rgba.init(w' h' colors' x' y);                        if (format == TextureFormat.DXT1)                      {                          QuickCompress.compressDXT1(rgba' block1);                          block1.WriteBytes(bytes' index);                      }                      else                      {                          QuickCompress.compressDXT5(rgba' block5' 0);                          block5.WriteBytes(bytes' index);                      }                        index += blocksize;  		        }  	        }
Magic Number,NvidiaTextureTools,TextureToolsDXT,C:\repos\rbray89_ActiveTextureManagement\NvidiaTextureTools\TextureTools.cs,GetDXT,The following statement contains a magic number: for (uint y = 0; y < h; y += 4) {  		        for (uint x = 0; x < w; x += 4) {  			        rgba.init(w' h' colors' x' y);                        if (format == TextureFormat.DXT1)                      {                          QuickCompress.compressDXT1(rgba' block1);                          block1.WriteBytes(bytes' index);                      }                      else                      {                          QuickCompress.compressDXT5(rgba' block5' 0);                          block5.WriteBytes(bytes' index);                      }                        index += blocksize;  		        }  	        }
