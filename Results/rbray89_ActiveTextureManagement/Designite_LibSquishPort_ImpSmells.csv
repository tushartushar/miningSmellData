Implementation smell,Namespace,Class,File,Method,Description
Long Method,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,The method has 116 lines of code.
Long Method,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The method has 128 lines of code.
Complex Method,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,Cyclomatic complexity of the method is 12
Complex Method,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,Cyclomatic complexity of the method is 10
Complex Method,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,Cyclomatic complexity of the method is 12
Complex Method,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,Cyclomatic complexity of the method is 8
Long Parameter List,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImage,The method has 6 parameters. Parameters: rgba' width' height' blocks' flags' waitOnDone
Long Parameter List,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The method has 7 parameters. Parameters: width' height' flags' y' prgba' targetBlockPtr' bytesPerBlock
Long Parameter List,LibSquishPort,CompressImageBlockLineArgs,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLineArgs,The method has 8 parameters. Parameters: width' height' flags' y' prgba' targetBlock' bytesPerBlock' doneEvent
Long Statement,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,The length of the statement  "				Vector4 factor = ( alphabeta_sum.NegativeMultiplySubtract( alphabeta_sum' Vector4.Scale(alpha2_sum' beta2_sum ) ) ).Reciprocal(); " is 129.
Long Statement,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,The length of the statement  "				Vector4 a = Vector4.Scale( betax_sum.NegativeMultiplySubtract( alphabeta_sum' Vector4.Scale(alphax_sum'beta2_sum) )' factor); " is 125.
Long Statement,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,The length of the statement  "				Vector4 b = Vector4.Scale( alphax_sum.NegativeMultiplySubtract( alphabeta_sum' Vector4.Scale(betax_sum'alpha2_sum) )' factor); " is 126.
Long Statement,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The length of the statement  "					Vector4 factor = (alphabeta_sum.NegativeMultiplySubtract( alphabeta_sum' Vector4.Scale(alpha2_sum'beta2_sum)) ).Reciprocal(); " is 125.
Long Statement,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The length of the statement  "					Vector4 a = Vector4.Scale(betax_sum.NegativeMultiplySubtract( alphabeta_sum' Vector4.Scale(alphax_sum'beta2_sum ))'factor); " is 123.
Long Statement,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The length of the statement  "					Vector4 b = Vector4.Scale(alphax_sum.NegativeMultiplySubtract( alphabeta_sum' Vector4.Scale(betax_sum'alpha2_sum ))'factor); " is 124.
Long Statement,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,FixFlags,The length of the statement  "            SquishFlags fit = flags & (SquishFlags.kColourIterativeClusterFit | SquishFlags.kColourClusterFit | SquishFlags.kColourRangeFit); " is 129.
Long Statement,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImage,The length of the statement  "                    CompressImageBlockLineArgs args = new CompressImageBlockLineArgs(width' height' flags' y' prgba' targetBlock' bytesPerBlock' doneEvents[threadIdx]); " is 148.
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  float alpha1 = (float)rgba[8 * i + 3] * (15.0f / 255.0f);                  float alpha2 = (float)rgba[8 * i + 7] * (15.0f / 255.0f);                  int quant1 = FloatToInt(alpha1' 15);                  int quant2 = FloatToInt(alpha2' 15);                    // set alpha to zero where masked                  int bit1 = 1 << (2 * i);                  int bit2 = 1 << (2 * i + 1);                  if ((mask & bit1) == 0)                      quant1 = 0;                  if ((mask & bit2) == 0)                      quant2 = 0;                    // pack into the byte                  bytes[i] = (byte)(quant1 | (quant2 << 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  byte quant = bytes[i];                    // unpack the values                  byte lo = (byte)(quant & 0x0f);                  byte hi = (byte)(quant & 0xf0);                    // convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  byte quant = bytes[i];                    // unpack the values                  byte lo = (byte)(quant & 0x0f);                  byte hi = (byte)(quant & 0xf0);                    // convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  byte quant = bytes[i];                    // unpack the values                  byte lo = (byte)(quant & 0x0f);                  byte hi = (byte)(quant & 0xf0);                    // convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  byte quant = bytes[i];                    // unpack the values                  byte lo = (byte)(quant & 0x0f);                  byte hi = (byte)(quant & 0xf0);                    // convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  byte quant = bytes[i];                    // unpack the values                  byte lo = (byte)(quant & 0x0f);                  byte hi = (byte)(quant & 0xf0);                    // convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  byte quant = bytes[i];                    // unpack the values                  byte lo = (byte)(quant & 0x0f);                  byte hi = (byte)(quant & 0xf0);                    // convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt3,The following statement contains a magic number: for (int i = 0; i < 8; ++i)              {                  // quantise down to 4 bits                  byte quant = bytes[i];                    // unpack the values                  byte lo = (byte)(quant & 0x0f);                  byte hi = (byte)(quant & 0xf0);                    // convert back up to bytes                  rgba[8 * i + 3] = (byte)(lo | (lo << 4));                  rgba[8 * i + 7] = (byte)(hi | (hi >> 4));              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,FixRange,The following statement contains a magic number: if (max - min < steps)                  max = Math.Min(min + steps' 255);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,FitCodes,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is valid                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      // use the first code                      indices[i] = 0;                      continue;                  }                    // find the least error and corresponding index                  int value = rgba[4 * i + 3];                  int least = int.MaxValue;                  int index = 0;                  for (int j = 0; j < 8; ++j)                  {                      // get the squared error from this code                      int dist = (int)value - (int)codes[j];                      dist *= dist;                        // compare with the best so far                      if (dist < least)                      {                          least = dist;                          index = j;                      }                  }                    // save this index and accumulate the error                  indices[i] = (byte)index;                  err += least;              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,FitCodes,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is valid                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      // use the first code                      indices[i] = 0;                      continue;                  }                    // find the least error and corresponding index                  int value = rgba[4 * i + 3];                  int least = int.MaxValue;                  int index = 0;                  for (int j = 0; j < 8; ++j)                  {                      // get the squared error from this code                      int dist = (int)value - (int)codes[j];                      dist *= dist;                        // compare with the best so far                      if (dist < least)                      {                          least = dist;                          index = j;                      }                  }                    // save this index and accumulate the error                  indices[i] = (byte)index;                  err += least;              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,FitCodes,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is valid                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      // use the first code                      indices[i] = 0;                      continue;                  }                    // find the least error and corresponding index                  int value = rgba[4 * i + 3];                  int least = int.MaxValue;                  int index = 0;                  for (int j = 0; j < 8; ++j)                  {                      // get the squared error from this code                      int dist = (int)value - (int)codes[j];                      dist *= dist;                        // compare with the best so far                      if (dist < least)                      {                          least = dist;                          index = j;                      }                  }                    // save this index and accumulate the error                  indices[i] = (byte)index;                  err += least;              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,FitCodes,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is valid                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      // use the first code                      indices[i] = 0;                      continue;                  }                    // find the least error and corresponding index                  int value = rgba[4 * i + 3];                  int least = int.MaxValue;                  int index = 0;                  for (int j = 0; j < 8; ++j)                  {                      // get the squared error from this code                      int dist = (int)value - (int)codes[j];                      dist *= dist;                        // compare with the best so far                      if (dist < least)                      {                          least = dist;                          index = j;                      }                  }                    // save this index and accumulate the error                  indices[i] = (byte)index;                  err += least;              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock,The following statement contains a magic number: byte* dest = bytes + 2;
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // pack 8 3-bit values                  int value = 0;                  for (int j = 0; j < 8; ++j)                  {                      int index = indices[src++];                      value |= (index << 3 * j);                  }                    // store in 3 bytes                  for (int j = 0; j < 3; ++j)                  {                      int u8 = (value >> 8 * j) & 0xff;                      *dest++ = (byte)u8;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // pack 8 3-bit values                  int value = 0;                  for (int j = 0; j < 8; ++j)                  {                      int index = indices[src++];                      value |= (index << 3 * j);                  }                    // store in 3 bytes                  for (int j = 0; j < 3; ++j)                  {                      int u8 = (value >> 8 * j) & 0xff;                      *dest++ = (byte)u8;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // pack 8 3-bit values                  int value = 0;                  for (int j = 0; j < 8; ++j)                  {                      int index = indices[src++];                      value |= (index << 3 * j);                  }                    // store in 3 bytes                  for (int j = 0; j < 3; ++j)                  {                      int u8 = (value >> 8 * j) & 0xff;                      *dest++ = (byte)u8;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // pack 8 3-bit values                  int value = 0;                  for (int j = 0; j < 8; ++j)                  {                      int index = indices[src++];                      value |= (index << 3 * j);                  }                    // store in 3 bytes                  for (int j = 0; j < 3; ++j)                  {                      int u8 = (value >> 8 * j) & 0xff;                      *dest++ = (byte)u8;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // pack 8 3-bit values                  int value = 0;                  for (int j = 0; j < 8; ++j)                  {                      int index = indices[src++];                      value |= (index << 3 * j);                  }                    // store in 3 bytes                  for (int j = 0; j < 3; ++j)                  {                      int u8 = (value >> 8 * j) & 0xff;                      *dest++ = (byte)u8;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock5,The following statement contains a magic number: if (alpha0 > alpha1)              {                  // swap the indices                  byte[] swapped = new byte[16];                  for (int i = 0; i < 16; ++i)                  {                      byte index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else if (index <= 5)                          swapped[i] = (byte)(7 - index);                      else                          swapped[i] = index;                  }                    // write the block                  WriteAlphaBlock(alpha1' alpha0' swapped' block);              }              else              {                  // write the block                  WriteAlphaBlock(alpha0' alpha1' indices' block);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock5,The following statement contains a magic number: if (alpha0 > alpha1)              {                  // swap the indices                  byte[] swapped = new byte[16];                  for (int i = 0; i < 16; ++i)                  {                      byte index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else if (index <= 5)                          swapped[i] = (byte)(7 - index);                      else                          swapped[i] = index;                  }                    // write the block                  WriteAlphaBlock(alpha1' alpha0' swapped' block);              }              else              {                  // write the block                  WriteAlphaBlock(alpha0' alpha1' indices' block);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock5,The following statement contains a magic number: if (alpha0 > alpha1)              {                  // swap the indices                  byte[] swapped = new byte[16];                  for (int i = 0; i < 16; ++i)                  {                      byte index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else if (index <= 5)                          swapped[i] = (byte)(7 - index);                      else                          swapped[i] = index;                  }                    // write the block                  WriteAlphaBlock(alpha1' alpha0' swapped' block);              }              else              {                  // write the block                  WriteAlphaBlock(alpha0' alpha1' indices' block);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock5,The following statement contains a magic number: if (alpha0 > alpha1)              {                  // swap the indices                  byte[] swapped = new byte[16];                  for (int i = 0; i < 16; ++i)                  {                      byte index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else if (index <= 5)                          swapped[i] = (byte)(7 - index);                      else                          swapped[i] = index;                  }                    // write the block                  WriteAlphaBlock(alpha1' alpha0' swapped' block);              }              else              {                  // write the block                  WriteAlphaBlock(alpha0' alpha1' indices' block);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock7,The following statement contains a magic number: if (alpha0 < alpha1)              {                  // swap the indices                  byte[] swapped = new byte[16];                  for (int i = 0; i < 16; ++i)                  {                      byte index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else                          swapped[i] = (byte)(9 - index);                  }                    // write the block                  WriteAlphaBlock(alpha1' alpha0' swapped' block);              }              else              {                  // write the block                  WriteAlphaBlock(alpha0' alpha1' indices' block);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock7,The following statement contains a magic number: if (alpha0 < alpha1)              {                  // swap the indices                  byte[] swapped = new byte[16];                  for (int i = 0; i < 16; ++i)                  {                      byte index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else                          swapped[i] = (byte)(9 - index);                  }                    // write the block                  WriteAlphaBlock(alpha1' alpha0' swapped' block);              }              else              {                  // write the block                  WriteAlphaBlock(alpha0' alpha1' indices' block);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,WriteAlphaBlock7,The following statement contains a magic number: if (alpha0 < alpha1)              {                  // swap the indices                  byte[] swapped = new byte[16];                  for (int i = 0; i < 16; ++i)                  {                      byte index = indices[i];                      if (index == 0)                          swapped[i] = 1;                      else if (index == 1)                          swapped[i] = 0;                      else                          swapped[i] = (byte)(9 - index);                  }                    // write the block                  WriteAlphaBlock(alpha1' alpha0' swapped' block);              }              else              {                  // write the block                  WriteAlphaBlock(alpha0' alpha1' indices' block);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: int min5 = 255;
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: int min7 = 255;
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is valid                  int bit = 1 << i;                  if ((mask & bit) == 0)                      continue;                    // incorporate into the min/max                  int value = rgba[4 * i + 3];                  if (value < min7)                      min7 = value;                  if (value > max7)                      max7 = value;                  if (value != 0 && value < min5)                      min5 = value;                  if (value != 255 && value > max5)                      max5 = value;              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is valid                  int bit = 1 << i;                  if ((mask & bit) == 0)                      continue;                    // incorporate into the min/max                  int value = rgba[4 * i + 3];                  if (value < min7)                      min7 = value;                  if (value > max7)                      max7 = value;                  if (value != 0 && value < min5)                      min5 = value;                  if (value != 255 && value > max5)                      max5 = value;              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is valid                  int bit = 1 << i;                  if ((mask & bit) == 0)                      continue;                    // incorporate into the min/max                  int value = rgba[4 * i + 3];                  if (value < min7)                      min7 = value;                  if (value > max7)                      max7 = value;                  if (value != 0 && value < min5)                      min5 = value;                  if (value != 255 && value > max5)                      max5 = value;              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is valid                  int bit = 1 << i;                  if ((mask & bit) == 0)                      continue;                    // incorporate into the min/max                  int value = rgba[4 * i + 3];                  if (value < min7)                      min7 = value;                  if (value > max7)                      max7 = value;                  if (value != 0 && value < min5)                      min5 = value;                  if (value != 255 && value > max5)                      max5 = value;              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: FixRange(ref min5' ref max5' 5);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: FixRange(ref min7' ref max7' 7);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: byte[] codes5 = new byte[8];
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 5; ++i)                  codes5[1 + i] = (byte)(((5 - i) * min5 + i * max5) / 5);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 5; ++i)                  codes5[1 + i] = (byte)(((5 - i) * min5 + i * max5) / 5);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 5; ++i)                  codes5[1 + i] = (byte)(((5 - i) * min5 + i * max5) / 5);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: codes5[6] = 0;
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: codes5[7] = 255;
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: codes5[7] = 255;
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: byte[] codes7 = new byte[8];
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 7; ++i)                  codes7[1 + i] = (byte)(((7 - i) * min7 + i * max7) / 7);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 7; ++i)                  codes7[1 + i] = (byte)(((7 - i) * min7 + i * max7) / 7);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: for (int i = 1; i < 7; ++i)                  codes7[1 + i] = (byte)(((7 - i) * min7 + i * max7) / 7);
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: byte[] indices5 = new byte[16];
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,CompressAlphaDxt5,The following statement contains a magic number: byte[] indices7 = new byte[16];
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: byte[] codes = new byte[8];
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: if (alpha0 <= alpha1)              {                  // use 5-alpha codebook                  for (int i = 1; i < 5; ++i)                      codes[1 + i] = (byte)(((5 - i) * alpha0 + i * alpha1) / 5);                  codes[6] = 0;                  codes[7] = 255;              }              else              {                  // use 7-alpha codebook                  for (int i = 1; i < 7; ++i)                      codes[1 + i] = (byte)(((7 - i) * alpha0 + i * alpha1) / 7);              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: byte[] indices = new byte[16];
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: byte* src = bytes + 2;
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j)                  {                      int u8 = *src++;                      value |= (u8 << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j)                  {                      int index = (value >> 3 * j) & 0x7;                      indices[dest++] = (byte)index;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j)                  {                      int u8 = *src++;                      value |= (u8 << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j)                  {                      int index = (value >> 3 * j) & 0x7;                      indices[dest++] = (byte)index;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j)                  {                      int u8 = *src++;                      value |= (u8 << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j)                  {                      int index = (value >> 3 * j) & 0x7;                      indices[dest++] = (byte)index;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j)                  {                      int u8 = *src++;                      value |= (u8 << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j)                  {                      int index = (value >> 3 * j) & 0x7;                      indices[dest++] = (byte)index;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 2; ++i)              {                  // grab 3 bytes                  int value = 0;                  for (int j = 0; j < 3; ++j)                  {                      int u8 = *src++;                      value |= (u8 << 8 * j);                  }                    // unpack 8 3-bit values from it                  for (int j = 0; j < 8; ++j)                  {                      int index = (value >> 3 * j) & 0x7;                      indices[dest++] = (byte)index;                  }              }
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)                  rgba[4 * i + 3] = codes[indices[i]];
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)                  rgba[4 * i + 3] = codes[indices[i]];
Magic Number,LibSquishPort,alpha,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\alpha.cs,DecompressAlphaDxt5,The following statement contains a magic number: for (int i = 0; i < 16; ++i)                  rgba[4 * i + 3] = codes[indices[i]];
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,ructOrdering,The following statement contains a magic number: float[] dps = new float[16];
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,ructOrdering,The following statement contains a magic number: fixed( byte* porder = m_order)      {  	    byte* order = porder + 16*iteration;  	    for( int i = 0; i < count; ++i )  	    {  		    dps[i] = Vector3.Dot( values[i]' axis );  		    order[i] = ( byte )i;  	    }  		  	    // stable sort using them  	    for( int i = 0; i < count; ++i )  	    {  		    for( int j = i; j > 0 && dps[j] < dps[j - 1]; --j )  		    {  			    swap( ref dps[j]' ref dps[j - 1] );  			    swap( ref order[j]' ref order[j - 1] );  		    }  	    }  	  	    // check this ordering is unique  	    for( int it = 0; it < iteration; ++it )  	    {  		    byte* prev = porder + 16*it;  		    bool same = true;  		    for( int i = 0; i < count; ++i )  		    {  			    if( order[i] != prev[i] )  			    {  				    same = false;  				    break;  			    }  		    }                		    if( same )  			    return false;  	    }  	  	    // copy the ordering and weight all the points  	    Vector3[] unweighted = m_colours.GetPoints();  	    float[] weights = m_colours.GetWeights();  	    m_xsum_wsum = Vector4.zero;  	    for( int i = 0; i < count; ++i )  	    {  		    int j = order[i];  		    Vector4 p = new Vector4( unweighted[j].x' unweighted[j].y' unweighted[j].z' 1.0f );  		    Vector4 x = p*weights[j];  		    m_points_weights[i] = x;  		    m_xsum_wsum += x;  	    }      }
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,ructOrdering,The following statement contains a magic number: fixed( byte* porder = m_order)      {  	    byte* order = porder + 16*iteration;  	    for( int i = 0; i < count; ++i )  	    {  		    dps[i] = Vector3.Dot( values[i]' axis );  		    order[i] = ( byte )i;  	    }  		  	    // stable sort using them  	    for( int i = 0; i < count; ++i )  	    {  		    for( int j = i; j > 0 && dps[j] < dps[j - 1]; --j )  		    {  			    swap( ref dps[j]' ref dps[j - 1] );  			    swap( ref order[j]' ref order[j - 1] );  		    }  	    }  	  	    // check this ordering is unique  	    for( int it = 0; it < iteration; ++it )  	    {  		    byte* prev = porder + 16*it;  		    bool same = true;  		    for( int i = 0; i < count; ++i )  		    {  			    if( order[i] != prev[i] )  			    {  				    same = false;  				    break;  			    }  		    }                		    if( same )  			    return false;  	    }  	  	    // copy the ordering and weight all the points  	    Vector3[] unweighted = m_colours.GetPoints();  	    float[] weights = m_colours.GetWeights();  	    m_xsum_wsum = Vector4.zero;  	    for( int i = 0; i < count; ++i )  	    {  		    int j = order[i];  		    Vector4 p = new Vector4( unweighted[j].x' unweighted[j].y' unweighted[j].z' 1.0f );  		    Vector4 x = p*weights[j];  		    m_points_weights[i] = x;  		    m_xsum_wsum += x;  	    }      }
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,The following statement contains a magic number: byte[] bestindices = new byte[16];
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,The following statement contains a magic number: if( math.CompareAnyLessThan( besterror' m_besterror ) )  	{  		// remap the indices          fixed(byte* p_order = m_order)          {  		byte * order = p_order + 16*bestiteration;    		byte[] unordered = new byte[16];  		for( int m = 0; m < besti; ++m )  			unordered[order[m]] = 0;  		for( int m = besti; m < bestj; ++m )  			unordered[order[m]] = 2;  		for( int m = bestj; m < count; ++m )  			unordered[order[m]] = 1;            		m_colours.RemapIndices( unordered' bestindices );  		  		// save the block  		colorblock.WriteColourBlock3( beststart' bestend' bestindices' block );          }  		// save the error  		m_besterror = besterror;  	}
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,The following statement contains a magic number: if( math.CompareAnyLessThan( besterror' m_besterror ) )  	{  		// remap the indices          fixed(byte* p_order = m_order)          {  		byte * order = p_order + 16*bestiteration;    		byte[] unordered = new byte[16];  		for( int m = 0; m < besti; ++m )  			unordered[order[m]] = 0;  		for( int m = besti; m < bestj; ++m )  			unordered[order[m]] = 2;  		for( int m = bestj; m < count; ++m )  			unordered[order[m]] = 1;            		m_colours.RemapIndices( unordered' bestindices );  		  		// save the block  		colorblock.WriteColourBlock3( beststart' bestend' bestindices' block );          }  		// save the error  		m_besterror = besterror;  	}
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress3,The following statement contains a magic number: if( math.CompareAnyLessThan( besterror' m_besterror ) )  	{  		// remap the indices          fixed(byte* p_order = m_order)          {  		byte * order = p_order + 16*bestiteration;    		byte[] unordered = new byte[16];  		for( int m = 0; m < besti; ++m )  			unordered[order[m]] = 0;  		for( int m = besti; m < bestj; ++m )  			unordered[order[m]] = 2;  		for( int m = bestj; m < count; ++m )  			unordered[order[m]] = 1;            		m_colours.RemapIndices( unordered' bestindices );  		  		// save the block  		colorblock.WriteColourBlock3( beststart' bestend' bestindices' block );          }  		// save the error  		m_besterror = besterror;  	}
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The following statement contains a magic number: byte[] bestindices = new byte[16];
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The following statement contains a magic number: if( math.CompareAnyLessThan( besterror' m_besterror ) )  	{  		// remap the indices          fixed (byte* p_order = m_order)          {              byte* order = p_order + 16 * bestiteration;                byte[] unordered = new byte[16];              for (int m = 0; m < besti; ++m)                  unordered[order[m]] = 0;              for (int m = besti; m < bestj; ++m)                  unordered[order[m]] = 2;              for (int m = bestj; m < bestk; ++m)                  unordered[order[m]] = 3;              for (int m = bestk; m < count; ++m)                  unordered[order[m]] = 1;                m_colours.RemapIndices(unordered' bestindices);                // save the block              colorblock.WriteColourBlock4(beststart' bestend' bestindices' block);          }  		// save the error  		m_besterror = besterror;  	}
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The following statement contains a magic number: if( math.CompareAnyLessThan( besterror' m_besterror ) )  	{  		// remap the indices          fixed (byte* p_order = m_order)          {              byte* order = p_order + 16 * bestiteration;                byte[] unordered = new byte[16];              for (int m = 0; m < besti; ++m)                  unordered[order[m]] = 0;              for (int m = besti; m < bestj; ++m)                  unordered[order[m]] = 2;              for (int m = bestj; m < bestk; ++m)                  unordered[order[m]] = 3;              for (int m = bestk; m < count; ++m)                  unordered[order[m]] = 1;                m_colours.RemapIndices(unordered' bestindices);                // save the block              colorblock.WriteColourBlock4(beststart' bestend' bestindices' block);          }  		// save the error  		m_besterror = besterror;  	}
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The following statement contains a magic number: if( math.CompareAnyLessThan( besterror' m_besterror ) )  	{  		// remap the indices          fixed (byte* p_order = m_order)          {              byte* order = p_order + 16 * bestiteration;                byte[] unordered = new byte[16];              for (int m = 0; m < besti; ++m)                  unordered[order[m]] = 0;              for (int m = besti; m < bestj; ++m)                  unordered[order[m]] = 2;              for (int m = bestj; m < bestk; ++m)                  unordered[order[m]] = 3;              for (int m = bestk; m < count; ++m)                  unordered[order[m]] = 1;                m_colours.RemapIndices(unordered' bestindices);                // save the block              colorblock.WriteColourBlock4(beststart' bestend' bestindices' block);          }  		// save the error  		m_besterror = besterror;  	}
Magic Number,LibSquishPort,ClusterFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\clusterfit.cs,Compress4,The following statement contains a magic number: if( math.CompareAnyLessThan( besterror' m_besterror ) )  	{  		// remap the indices          fixed (byte* p_order = m_order)          {              byte* order = p_order + 16 * bestiteration;                byte[] unordered = new byte[16];              for (int m = 0; m < besti; ++m)                  unordered[order[m]] = 0;              for (int m = besti; m < bestj; ++m)                  unordered[order[m]] = 2;              for (int m = bestj; m < bestk; ++m)                  unordered[order[m]] = 3;              for (int m = bestk; m < count; ++m)                  unordered[order[m]] = 1;                m_colours.RemapIndices(unordered' bestindices);                // save the block              colorblock.WriteColourBlock4(beststart' bestend' bestindices' block);          }  		// save the error  		m_besterror = besterror;  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,FloatTo565,The following statement contains a magic number: int r = FloatToInt( 31.0f*colour.x' 31 );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,FloatTo565,The following statement contains a magic number: int g = FloatToInt( 63.0f*colour.y' 63 );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,FloatTo565,The following statement contains a magic number: int b = FloatToInt( 31.0f*colour.z' 31 );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,FloatTo565,The following statement contains a magic number: return ( r << 11 ) | ( g << 5 ) | b;
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,FloatTo565,The following statement contains a magic number: return ( r << 11 ) | ( g << 5 ) | b;
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: bytes[1] = ( byte )( a >> 8 );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: bytes[2] = ( byte )( b & 0xff );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: bytes[3] = ( byte )( b >> 8 );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: bytes[3] = ( byte )( b >> 8 );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices= indices)          {  		    byte * ind = pindices + 4*i;  		    bytes[4 + i] = (byte)(ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 ));          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices= indices)          {  		    byte * ind = pindices + 4*i;  		    bytes[4 + i] = (byte)(ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 ));          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices= indices)          {  		    byte * ind = pindices + 4*i;  		    bytes[4 + i] = (byte)(ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 ));          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices= indices)          {  		    byte * ind = pindices + 4*i;  		    bytes[4 + i] = (byte)(ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 ));          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices= indices)          {  		    byte * ind = pindices + 4*i;  		    bytes[4 + i] = (byte)(ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 ));          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices= indices)          {  		    byte * ind = pindices + 4*i;  		    bytes[4 + i] = (byte)(ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 ));          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices= indices)          {  		    byte * ind = pindices + 4*i;  		    bytes[4 + i] = (byte)(ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 ));          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices= indices)          {  		    byte * ind = pindices + 4*i;  		    bytes[4 + i] = (byte)(ind[0] | ( ind[1] << 2 ) | ( ind[2] << 4 ) | ( ind[3] << 6 ));          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock3,The following statement contains a magic number: byte[] remapped = new byte[16];
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock3,The following statement contains a magic number: if( a <= b )  	{  		// use the indices directly  		for( int i = 0; i < 16; ++i )  			remapped[i] = indices[i];  	}  	else  	{  		// swap a and b  		swap( ref a' ref b );  		for( int i = 0; i < 16; ++i )  		{  			if( indices[i] == 0 )  				remapped[i] = 1;  			else if( indices[i] == 1 )  				remapped[i] = 0;  			else  				remapped[i] = indices[i];  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock3,The following statement contains a magic number: if( a <= b )  	{  		// use the indices directly  		for( int i = 0; i < 16; ++i )  			remapped[i] = indices[i];  	}  	else  	{  		// swap a and b  		swap( ref a' ref b );  		for( int i = 0; i < 16; ++i )  		{  			if( indices[i] == 0 )  				remapped[i] = 1;  			else if( indices[i] == 1 )  				remapped[i] = 0;  			else  				remapped[i] = indices[i];  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock4,The following statement contains a magic number: byte[] remapped = new byte[16];
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock4,The following statement contains a magic number: if( a < b )  	{  		// swap a and b  		swap( ref a' ref b );  		for( int i = 0; i < 16; ++i )  			remapped[i] = (byte)(( indices[i] ^ 0x1 ) & 0x3);  	}  	else if( a == b )  	{  		// use index 0  		for( int i = 0; i < 16; ++i )  			remapped[i] = 0;  	}  	else  	{  		// use the indices directly  		for( int i = 0; i < 16; ++i )  			remapped[i] = indices[i];  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock4,The following statement contains a magic number: if( a < b )  	{  		// swap a and b  		swap( ref a' ref b );  		for( int i = 0; i < 16; ++i )  			remapped[i] = (byte)(( indices[i] ^ 0x1 ) & 0x3);  	}  	else if( a == b )  	{  		// use index 0  		for( int i = 0; i < 16; ++i )  			remapped[i] = 0;  	}  	else  	{  		// use the indices directly  		for( int i = 0; i < 16; ++i )  			remapped[i] = indices[i];  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,WriteColourBlock4,The following statement contains a magic number: if( a < b )  	{  		// swap a and b  		swap( ref a' ref b );  		for( int i = 0; i < 16; ++i )  			remapped[i] = (byte)(( indices[i] ^ 0x1 ) & 0x3);  	}  	else if( a == b )  	{  		// use index 0  		for( int i = 0; i < 16; ++i )  			remapped[i] = 0;  	}  	else  	{  		// use the indices directly  		for( int i = 0; i < 16; ++i )  			remapped[i] = indices[i];  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: int value = ( int )packed[0] | ( ( int )packed[1] << 8 );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: byte red = ( byte )( ( value >> 11 ) & 0x1f );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: byte green = ( byte )( ( value >> 5 ) & 0x3f );
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[0] = (byte)(( red << 3 ) | ( red >> 2 ));
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[0] = (byte)(( red << 3 ) | ( red >> 2 ));
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[1] = (byte)(( green << 2 ) | ( green >> 4 ));
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[1] = (byte)(( green << 2 ) | ( green >> 4 ));
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[2] = (byte)(( blue << 3 ) | ( blue >> 2 ));
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[2] = (byte)(( blue << 3 ) | ( blue >> 2 ));
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[2] = (byte)(( blue << 3 ) | ( blue >> 2 ));
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[3] = 255;
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,Unpack565,The following statement contains a magic number: colour[3] = 255;
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: byte[] codes = new byte[16];
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: fixed (byte* bytes = block' pcodes = codes )          {  	  	a = Unpack565( bytes' pcodes );  	 b = Unpack565( bytes + 2' pcodes + 4 );  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: fixed (byte* bytes = block' pcodes = codes )          {  	  	a = Unpack565( bytes' pcodes );  	 b = Unpack565( bytes + 2' pcodes + 4 );  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 3; ++i )  	{  		int c = codes[i];  		int d = codes[4 + i];    		if( isDxt1 && a <= b )  		{  			codes[8 + i] = ( byte )( ( c + d )/2 );  			codes[12 + i] = 0;  		}  		else  		{  			codes[8 + i] = ( byte )( ( 2*c + d )/3 );  			codes[12 + i] = ( byte )( ( c + 2*d )/3 );  		}  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: codes[8 + 3] = 255;
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: codes[12 + 3] = (byte)(( isDxt1 && a <= b ) ? 0 : 255);
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: codes[12 + 3] = (byte)(( isDxt1 && a <= b ) ? 0 : 255);
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: codes[12 + 3] = (byte)(( isDxt1 && a <= b ) ? 0 : 255);
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: byte[] indices = new byte[16];
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices = indices)          {              byte* ind = pindices + 4 * i;              byte packed = block[4 + i];                ind[0] = (byte)(packed & 0x3);              ind[1] = (byte)((packed >> 2) & 0x3);              ind[2] = (byte)((packed >> 4) & 0x3);              ind[3] = (byte)((packed >> 6) & 0x3);          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices = indices)          {              byte* ind = pindices + 4 * i;              byte packed = block[4 + i];                ind[0] = (byte)(packed & 0x3);              ind[1] = (byte)((packed >> 2) & 0x3);              ind[2] = (byte)((packed >> 4) & 0x3);              ind[3] = (byte)((packed >> 6) & 0x3);          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices = indices)          {              byte* ind = pindices + 4 * i;              byte packed = block[4 + i];                ind[0] = (byte)(packed & 0x3);              ind[1] = (byte)((packed >> 2) & 0x3);              ind[2] = (byte)((packed >> 4) & 0x3);              ind[3] = (byte)((packed >> 6) & 0x3);          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices = indices)          {              byte* ind = pindices + 4 * i;              byte packed = block[4 + i];                ind[0] = (byte)(packed & 0x3);              ind[1] = (byte)((packed >> 2) & 0x3);              ind[2] = (byte)((packed >> 4) & 0x3);              ind[3] = (byte)((packed >> 6) & 0x3);          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices = indices)          {              byte* ind = pindices + 4 * i;              byte packed = block[4 + i];                ind[0] = (byte)(packed & 0x3);              ind[1] = (byte)((packed >> 2) & 0x3);              ind[2] = (byte)((packed >> 4) & 0x3);              ind[3] = (byte)((packed >> 6) & 0x3);          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices = indices)          {              byte* ind = pindices + 4 * i;              byte packed = block[4 + i];                ind[0] = (byte)(packed & 0x3);              ind[1] = (byte)((packed >> 2) & 0x3);              ind[2] = (byte)((packed >> 4) & 0x3);              ind[3] = (byte)((packed >> 6) & 0x3);          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices = indices)          {              byte* ind = pindices + 4 * i;              byte packed = block[4 + i];                ind[0] = (byte)(packed & 0x3);              ind[1] = (byte)((packed >> 2) & 0x3);              ind[2] = (byte)((packed >> 4) & 0x3);              ind[3] = (byte)((packed >> 6) & 0x3);          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 4; ++i )  	{          fixed (byte* pindices = indices)          {              byte* ind = pindices + 4 * i;              byte packed = block[4 + i];                ind[0] = (byte)(packed & 0x3);              ind[1] = (byte)((packed >> 2) & 0x3);              ind[2] = (byte)((packed >> 4) & 0x3);              ind[3] = (byte)((packed >> 6) & 0x3);          }  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 16; ++i )  	{  		byte offset = (byte)(4*indices[i]);  		for( int j = 0; j < 4; ++j )  			rgba[4*i + j] = codes[offset + j];  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 16; ++i )  	{  		byte offset = (byte)(4*indices[i]);  		for( int j = 0; j < 4; ++j )  			rgba[4*i + j] = codes[offset + j];  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 16; ++i )  	{  		byte offset = (byte)(4*indices[i]);  		for( int j = 0; j < 4; ++j )  			rgba[4*i + j] = codes[offset + j];  	}
Magic Number,LibSquishPort,colorblock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colorblock.cs,DecompressColour,The following statement contains a magic number: for( int i = 0; i < 16; ++i )  	{  		byte offset = (byte)(4*indices[i]);  		for( int j = 0; j < 4; ++j )  			rgba[4*i + j] = codes[offset + j];  	}
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,ColourSet,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  // check this pixel is enabled                  int bit = 1 << i;                  if ((mask & bit) == 0)                  {                      m_remap[i] = -1;                      continue;                  }                    // check for transparent pixels when using dxt1                  if (isDxt1 && rgba[4 * i + 3] < 128)                  {                      m_remap[i] = -1;                      m_transparent = true;                      continue;                  }                    // loop over previous points for a match                  for (int j = 0; ; ++j)                  {                      // allocate a new point                      if (j == i)                      {                          // normalise coordinates to [0'1]                          float x = (float)rgba[4 * i] / 255.0f;                          float y = (float)rgba[4 * i + 1] / 255.0f;                          float z = (float)rgba[4 * i + 2] / 255.0f;                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // add the point                          m_points[m_count] = new Vector3(x' y' z);                          m_weights[m_count] = (weightByAlpha ? w : 1.0f);                          m_remap[i] = m_count;                            // advance                          ++m_count;                          break;                      }                        // check for a match                      int oldbit = 1 << j;                      bool match = ((mask & oldbit) != 0)                          && (rgba[4 * i] == rgba[4 * j])                          && (rgba[4 * i + 1] == rgba[4 * j + 1])                          && (rgba[4 * i + 2] == rgba[4 * j + 2])                          && (rgba[4 * j + 3] >= 128 || !isDxt1);                      if (match)                      {                          // get the index of the match                          int index = m_remap[j];                            // ensure there is always non-zero weight even for zero alpha                          float w = (float)(rgba[4 * i + 3] + 1) / 256.0f;                            // map to this point and increase the weight                          m_weights[index] += (weightByAlpha ? w : 1.0f);                          m_remap[i] = index;                          break;                      }                  }              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,RemapIndices,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  int j = m_remap[i];                  if (j == -1)                      target[i] = 3;                  else                      target[i] = source[j];              }
Magic Number,LibSquishPort,ColourSet,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\colourset.cs,RemapIndices,The following statement contains a magic number: for (int i = 0; i < 16; ++i)              {                  int j = m_remap[i];                  if (j == -1)                      target[i] = 3;                  else                      target[i] = source[j];              }
Magic Number,LibSquishPort,Sym3x3,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,Sym3x3,The following statement contains a magic number: for (int i = 0; i < 6; ++i)                  m_x[i] = s;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputeWeightedCovariance,The following statement contains a magic number: for (int i = 0; i < n; ++i)              {                  Vector3 a = points[i] - centroid;                  Vector3 b = weights[i] * a;                    covariance[0] += a.x * b.x;                  covariance[1] += a.x * b.y;                  covariance[2] += a.x * b.z;                  covariance[3] += a.y * b.y;                  covariance[4] += a.y * b.z;                  covariance[5] += a.z * b.z;              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputeWeightedCovariance,The following statement contains a magic number: for (int i = 0; i < n; ++i)              {                  Vector3 a = points[i] - centroid;                  Vector3 b = weights[i] * a;                    covariance[0] += a.x * b.x;                  covariance[1] += a.x * b.y;                  covariance[2] += a.x * b.z;                  covariance[3] += a.y * b.y;                  covariance[4] += a.y * b.z;                  covariance[5] += a.z * b.z;              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputeWeightedCovariance,The following statement contains a magic number: for (int i = 0; i < n; ++i)              {                  Vector3 a = points[i] - centroid;                  Vector3 b = weights[i] * a;                    covariance[0] += a.x * b.x;                  covariance[1] += a.x * b.y;                  covariance[2] += a.x * b.z;                  covariance[3] += a.y * b.y;                  covariance[4] += a.y * b.z;                  covariance[5] += a.z * b.z;              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputeWeightedCovariance,The following statement contains a magic number: for (int i = 0; i < n; ++i)              {                  Vector3 a = points[i] - centroid;                  Vector3 b = weights[i] * a;                    covariance[0] += a.x * b.x;                  covariance[1] += a.x * b.y;                  covariance[2] += a.x * b.z;                  covariance[3] += a.y * b.y;                  covariance[4] += a.y * b.z;                  covariance[5] += a.z * b.z;              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[2] = matrix[2];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[2] = matrix[2];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[3] = matrix[3] - evalue;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[3] = matrix[3] - evalue;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[4] = matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[4] = matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[5] = matrix[5] - evalue;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: m[5] = matrix[5] - evalue;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[0] = m[3] * m[5] - m[4] * m[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[0] = m[3] * m[5] - m[4] * m[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[0] = m[3] * m[5] - m[4] * m[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[0] = m[3] * m[5] - m[4] * m[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[1] = m[2] * m[4] - m[1] * m[5];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[1] = m[2] * m[4] - m[1] * m[5];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[1] = m[2] * m[4] - m[1] * m[5];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[2] = m[1] * m[4] - m[2] * m[3];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[2] = m[1] * m[4] - m[2] * m[3];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[2] = m[1] * m[4] - m[2] * m[3];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[2] = m[1] * m[4] - m[2] * m[3];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[3] = m[0] * m[5] - m[2] * m[2];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[3] = m[0] * m[5] - m[2] * m[2];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[3] = m[0] * m[5] - m[2] * m[2];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[3] = m[0] * m[5] - m[2] * m[2];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[4] = m[1] * m[2] - m[4] * m[0];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[4] = m[1] * m[2] - m[4] * m[0];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[4] = m[1] * m[2] - m[4] * m[0];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[5] = m[0] * m[3] - m[1] * m[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: u[5] = m[0] * m[3] - m[1] * m[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: for (int i = 1; i < 6; ++i)              {                  float c = Mathf.Abs(u[i]);                  if (c > mc)                  {                      mc = c;                      mi = i;                  }              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                    case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                    default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                    case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                    default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                    case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                    default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                    case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                    default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                    case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                    default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                    case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                    default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity1Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                      return new Vector3(u[0]' u[1]' u[2]);                    case 1:                  case 3:                      return new Vector3(u[1]' u[3]' u[4]);                    default:                      return new Vector3(u[2]' u[4]' u[5]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[2] = matrix[2];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[2] = matrix[2];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[3] = matrix[3] - evalue;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[3] = matrix[3] - evalue;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[4] = matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[4] = matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[5] = matrix[5] - evalue;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: m[5] = matrix[5] - evalue;
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: for (int i = 1; i < 6; ++i)              {                  float c = Mathf.Abs(m[i]);                  if (c > mc)                  {                      mc = c;                      mi = i;                  }              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,GetMultiplicity2Evector,The following statement contains a magic number: switch (mi)              {                  case 0:                  case 1:                      return new Vector3(-m[1]' m[0]' 0.0f);                    case 2:                      return new Vector3(m[2]' 0.0f' -m[0]);                    case 3:                  case 4:                      return new Vector3(0.0f' -m[4]' m[3]);                    default:                      return new Vector3(0.0f' -m[5]' m[4]);              }
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c0 = matrix[0] * matrix[3] * matrix[5]                  + 2.0f * matrix[1] * matrix[2] * matrix[4]                  - matrix[0] * matrix[4] * matrix[4]                  - matrix[3] * matrix[2] * matrix[2]                  - matrix[5] * matrix[1] * matrix[1];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c1 = matrix[0] * matrix[3] + matrix[0] * matrix[5] + matrix[3] * matrix[5]                  - matrix[1] * matrix[1] - matrix[2] * matrix[2] - matrix[4] * matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c1 = matrix[0] * matrix[3] + matrix[0] * matrix[5] + matrix[3] * matrix[5]                  - matrix[1] * matrix[1] - matrix[2] * matrix[2] - matrix[4] * matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c1 = matrix[0] * matrix[3] + matrix[0] * matrix[5] + matrix[3] * matrix[5]                  - matrix[1] * matrix[1] - matrix[2] * matrix[2] - matrix[4] * matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c1 = matrix[0] * matrix[3] + matrix[0] * matrix[5] + matrix[3] * matrix[5]                  - matrix[1] * matrix[1] - matrix[2] * matrix[2] - matrix[4] * matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c1 = matrix[0] * matrix[3] + matrix[0] * matrix[5] + matrix[3] * matrix[5]                  - matrix[1] * matrix[1] - matrix[2] * matrix[2] - matrix[4] * matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c1 = matrix[0] * matrix[3] + matrix[0] * matrix[5] + matrix[3] * matrix[5]                  - matrix[1] * matrix[1] - matrix[2] * matrix[2] - matrix[4] * matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c1 = matrix[0] * matrix[3] + matrix[0] * matrix[5] + matrix[3] * matrix[5]                  - matrix[1] * matrix[1] - matrix[2] * matrix[2] - matrix[4] * matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c1 = matrix[0] * matrix[3] + matrix[0] * matrix[5] + matrix[3] * matrix[5]                  - matrix[1] * matrix[1] - matrix[2] * matrix[2] - matrix[4] * matrix[4];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c2 = matrix[0] + matrix[3] + matrix[5];
Magic Number,LibSquishPort,math,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\math.cs,ComputePrincipleComponent,The following statement contains a magic number: float c2 = matrix[0] + matrix[3] + matrix[5];
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress3,The following statement contains a magic number: Vector3[] codes = new Vector3[3];
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress3,The following statement contains a magic number: codes[2] = 0.5f*m_start + 0.5f*m_end;
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress3,The following statement contains a magic number: byte[] closest = new byte[16];
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress3,The following statement contains a magic number: for( int i = 0; i < count; ++i )  	{  		// find the closest code  		float dist = float.MaxValue;  		int idx = 0;  		for( int j = 0; j < 3; ++j )  		{  			float d = Vector3.Scale( m_metric'( values[i] - codes[j] ) ).sqrMagnitude;  			if( d < dist )  			{  				dist = d;  				idx = j;  			}  		}  		  		// save the index  		closest[i] = ( byte )idx;  		  		// accumulate the error  		error += dist;  	}
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress3,The following statement contains a magic number: if( error < m_besterror )  	{  		// remap the indices  		byte[] indices = new byte[16];  		m_colours.RemapIndices( closest' indices );  		  		// save the block  		colorblock.WriteColourBlock3( m_start' m_end' indices' block );  		  		// save the error  		m_besterror = error;  	}
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress4,The following statement contains a magic number: Vector3[] codes = new Vector3[4];
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress4,The following statement contains a magic number: codes[2] = ( 2.0f/3.0f )*m_start + ( 1.0f/3.0f )*m_end;
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress4,The following statement contains a magic number: codes[3] = ( 1.0f/3.0f )*m_start + ( 2.0f/3.0f )*m_end;
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress4,The following statement contains a magic number: byte[] closest = new byte[16];
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress4,The following statement contains a magic number: for( int i = 0; i < count; ++i )  	{  		// find the closest code  		float dist = float.MaxValue;  		int idx = 0;  		for( int j = 0; j < 4; ++j )  		{  			float d = Vector3.Scale( m_metric'( values[i] - codes[j] ) ).sqrMagnitude;  			if( d < dist )  			{  				dist = d;  				idx = j;  			}  		}  		  		// save the index  		closest[i] = ( byte )idx;  		  		// accumulate the error  		error += dist;  	}
Magic Number,LibSquishPort,RangeFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\rangefit.cs,Compress4,The following statement contains a magic number: if( error < m_besterror )  	{  		// remap the indices  		byte[] indices = new byte[16];  		m_colours.RemapIndices( closest' indices );  		  		// save the block          colorblock.WriteColourBlock4(m_start' m_end' indices' block);    		// save the error  		m_besterror = error;  	}
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,SingleColourFit,The following statement contains a magic number: m_colour[0] = ( byte )FloatToInt( 255.0f*values[0].x' 255 );
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,SingleColourFit,The following statement contains a magic number: m_colour[1] = ( byte )FloatToInt( 255.0f*values[0].y' 255 );
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,SingleColourFit,The following statement contains a magic number: m_colour[2] = ( byte )FloatToInt( 255.0f*values[0].z' 255 );
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,SingleColourFit,The following statement contains a magic number: m_colour[2] = ( byte )FloatToInt( 255.0f*values[0].z' 255 );
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,Compress3,The following statement contains a magic number: if( m_error < m_besterror )  	{  		// remap the indices  		byte[] indices = new byte[16];  		m_colours.RemapIndices( m_index' indices );  		  		// save the block  		colorblock.WriteColourBlock3( m_start' m_end' indices' block );    		// save the error  		m_besterror = m_error;  	}
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,Compress4,The following statement contains a magic number: if( m_error < m_besterror )  	{  		// remap the indices  		byte[] indices = new byte[16];  		m_colours.RemapIndices( m_index' indices );  		  		// save the block  		colorblock.WriteColourBlock4( m_start' m_end' indices' block );    		// save the error  		m_besterror = m_error;  	}
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,ComputeEndPoints,The following statement contains a magic number: for( int index = 0; index < 2; ++index )  	{  		// check the error for this codebook index  		SourceBlock[] sources = new SourceBlock[3];  		int error = 0;  		for( int channel = 0; channel < 3; ++channel )  		{  			// grab the lookup table and index for this channel  			SingleColourLookup[] lookup = lookups[channel];  			int target = m_colour[channel];  			  			// store a pointer to the source for this channel              sources[channel] = lookup[target].sources[index];  			  			// accumulate the error  			int diff = sources[channel].error;  			error += diff*diff;			  		}  		  		// keep it if the error is lower  		if( error < m_error )  		{  			m_start = new Vector3(  				( float )sources[0].start/31.0f'   				( float )sources[1].start/63.0f'   				( float )sources[2].start/31.0f  			);  			m_end = new Vector3(  				( float )sources[0].end/31.0f'   				( float )sources[1].end/63.0f'   				( float )sources[2].end/31.0f  			);  			m_index[0] = ( byte )( 2*index );  			m_error = error;  		}  	}
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,ComputeEndPoints,The following statement contains a magic number: for( int index = 0; index < 2; ++index )  	{  		// check the error for this codebook index  		SourceBlock[] sources = new SourceBlock[3];  		int error = 0;  		for( int channel = 0; channel < 3; ++channel )  		{  			// grab the lookup table and index for this channel  			SingleColourLookup[] lookup = lookups[channel];  			int target = m_colour[channel];  			  			// store a pointer to the source for this channel              sources[channel] = lookup[target].sources[index];  			  			// accumulate the error  			int diff = sources[channel].error;  			error += diff*diff;			  		}  		  		// keep it if the error is lower  		if( error < m_error )  		{  			m_start = new Vector3(  				( float )sources[0].start/31.0f'   				( float )sources[1].start/63.0f'   				( float )sources[2].start/31.0f  			);  			m_end = new Vector3(  				( float )sources[0].end/31.0f'   				( float )sources[1].end/63.0f'   				( float )sources[2].end/31.0f  			);  			m_index[0] = ( byte )( 2*index );  			m_error = error;  		}  	}
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,ComputeEndPoints,The following statement contains a magic number: for( int index = 0; index < 2; ++index )  	{  		// check the error for this codebook index  		SourceBlock[] sources = new SourceBlock[3];  		int error = 0;  		for( int channel = 0; channel < 3; ++channel )  		{  			// grab the lookup table and index for this channel  			SingleColourLookup[] lookup = lookups[channel];  			int target = m_colour[channel];  			  			// store a pointer to the source for this channel              sources[channel] = lookup[target].sources[index];  			  			// accumulate the error  			int diff = sources[channel].error;  			error += diff*diff;			  		}  		  		// keep it if the error is lower  		if( error < m_error )  		{  			m_start = new Vector3(  				( float )sources[0].start/31.0f'   				( float )sources[1].start/63.0f'   				( float )sources[2].start/31.0f  			);  			m_end = new Vector3(  				( float )sources[0].end/31.0f'   				( float )sources[1].end/63.0f'   				( float )sources[2].end/31.0f  			);  			m_index[0] = ( byte )( 2*index );  			m_error = error;  		}  	}
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,ComputeEndPoints,The following statement contains a magic number: for( int index = 0; index < 2; ++index )  	{  		// check the error for this codebook index  		SourceBlock[] sources = new SourceBlock[3];  		int error = 0;  		for( int channel = 0; channel < 3; ++channel )  		{  			// grab the lookup table and index for this channel  			SingleColourLookup[] lookup = lookups[channel];  			int target = m_colour[channel];  			  			// store a pointer to the source for this channel              sources[channel] = lookup[target].sources[index];  			  			// accumulate the error  			int diff = sources[channel].error;  			error += diff*diff;			  		}  		  		// keep it if the error is lower  		if( error < m_error )  		{  			m_start = new Vector3(  				( float )sources[0].start/31.0f'   				( float )sources[1].start/63.0f'   				( float )sources[2].start/31.0f  			);  			m_end = new Vector3(  				( float )sources[0].end/31.0f'   				( float )sources[1].end/63.0f'   				( float )sources[2].end/31.0f  			);  			m_index[0] = ( byte )( 2*index );  			m_error = error;  		}  	}
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,ComputeEndPoints,The following statement contains a magic number: for( int index = 0; index < 2; ++index )  	{  		// check the error for this codebook index  		SourceBlock[] sources = new SourceBlock[3];  		int error = 0;  		for( int channel = 0; channel < 3; ++channel )  		{  			// grab the lookup table and index for this channel  			SingleColourLookup[] lookup = lookups[channel];  			int target = m_colour[channel];  			  			// store a pointer to the source for this channel              sources[channel] = lookup[target].sources[index];  			  			// accumulate the error  			int diff = sources[channel].error;  			error += diff*diff;			  		}  		  		// keep it if the error is lower  		if( error < m_error )  		{  			m_start = new Vector3(  				( float )sources[0].start/31.0f'   				( float )sources[1].start/63.0f'   				( float )sources[2].start/31.0f  			);  			m_end = new Vector3(  				( float )sources[0].end/31.0f'   				( float )sources[1].end/63.0f'   				( float )sources[2].end/31.0f  			);  			m_index[0] = ( byte )( 2*index );  			m_error = error;  		}  	}
Magic Number,LibSquishPort,SingleColourFit,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,ComputeEndPoints,The following statement contains a magic number: for( int index = 0; index < 2; ++index )  	{  		// check the error for this codebook index  		SourceBlock[] sources = new SourceBlock[3];  		int error = 0;  		for( int channel = 0; channel < 3; ++channel )  		{  			// grab the lookup table and index for this channel  			SingleColourLookup[] lookup = lookups[channel];  			int target = m_colour[channel];  			  			// store a pointer to the source for this channel              sources[channel] = lookup[target].sources[index];  			  			// accumulate the error  			int diff = sources[channel].error;  			error += diff*diff;			  		}  		  		// keep it if the error is lower  		if( error < m_error )  		{  			m_start = new Vector3(  				( float )sources[0].start/31.0f'   				( float )sources[1].start/63.0f'   				( float )sources[2].start/31.0f  			);  			m_end = new Vector3(  				( float )sources[0].end/31.0f'   				( float )sources[1].end/63.0f'   				( float )sources[2].end/31.0f  			);  			m_index[0] = ( byte )( 2*index );  			m_error = error;  		}  	}
Magic Number,LibSquishPort,SourceBlock,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\singlecolourfit.cs,SourceBlock,The following statement contains a magic number: error = array[2];
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressMasked,The following statement contains a magic number: if ((flags & (SquishFlags.kDxt3 | SquishFlags.kDxt5)) != 0)                  colourBlock = pBlock + 8;
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,GetStorageRequirements,The following statement contains a magic number: int blockcount = ((width + 3) / 4) * ((height + 3) / 4);
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,GetStorageRequirements,The following statement contains a magic number: int blockcount = ((width + 3) / 4) * ((height + 3) / 4);
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,GetStorageRequirements,The following statement contains a magic number: int blockcount = ((width + 3) / 4) * ((height + 3) / 4);
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,GetStorageRequirements,The following statement contains a magic number: int blockcount = ((width + 3) / 4) * ((height + 3) / 4);
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,GetStorageRequirements,The following statement contains a magic number: int blocksize = ((flags & SquishFlags.kDxt1) != 0) ? 8 : 16;
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,GetStorageRequirements,The following statement contains a magic number: int blocksize = ((flags & SquishFlags.kDxt1) != 0) ? 8 : 16;
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImage,The following statement contains a magic number: fixed (byte* pblocks = blocks' prgba = rgba)              {                  int bytesPerBlock = ((flags & SquishFlags.kDxt1) != 0) ? 8 : 16;                  byte* targetBlock = pblocks;                    // loop over blocks                  for (int y = 0; y < height; y += 4)                  {                      int threadIdx = GetFreeThreadIdx(doneEvents);                      doneEvents[threadIdx] = new ManualResetEvent(false);                        CompressImageBlockLineArgs args = new CompressImageBlockLineArgs(width' height' flags' y' prgba' targetBlock' bytesPerBlock' doneEvents[threadIdx]);                      targetBlock += bytesPerBlock * ((width >> 2) + ((width & 0x3) != 0 ? 1 : 0));                        // To debug un comment this line and comment the next one                      // Threads catch the exceptions (add a try catch ? )                      //CompressImageBlockLineThread(args);                      if (waitOnDone && y > (4*Environment.ProcessorCount))                      {                          WaitHandle.WaitAny(doneEvents);                      }                      ThreadPool.QueueUserWorkItem(CompressImageBlockLineThread' args);                  }                  WaitHandle.WaitAll(doneEvents);              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImage,The following statement contains a magic number: fixed (byte* pblocks = blocks' prgba = rgba)              {                  int bytesPerBlock = ((flags & SquishFlags.kDxt1) != 0) ? 8 : 16;                  byte* targetBlock = pblocks;                    // loop over blocks                  for (int y = 0; y < height; y += 4)                  {                      int threadIdx = GetFreeThreadIdx(doneEvents);                      doneEvents[threadIdx] = new ManualResetEvent(false);                        CompressImageBlockLineArgs args = new CompressImageBlockLineArgs(width' height' flags' y' prgba' targetBlock' bytesPerBlock' doneEvents[threadIdx]);                      targetBlock += bytesPerBlock * ((width >> 2) + ((width & 0x3) != 0 ? 1 : 0));                        // To debug un comment this line and comment the next one                      // Threads catch the exceptions (add a try catch ? )                      //CompressImageBlockLineThread(args);                      if (waitOnDone && y > (4*Environment.ProcessorCount))                      {                          WaitHandle.WaitAny(doneEvents);                      }                      ThreadPool.QueueUserWorkItem(CompressImageBlockLineThread' args);                  }                  WaitHandle.WaitAll(doneEvents);              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImage,The following statement contains a magic number: fixed (byte* pblocks = blocks' prgba = rgba)              {                  int bytesPerBlock = ((flags & SquishFlags.kDxt1) != 0) ? 8 : 16;                  byte* targetBlock = pblocks;                    // loop over blocks                  for (int y = 0; y < height; y += 4)                  {                      int threadIdx = GetFreeThreadIdx(doneEvents);                      doneEvents[threadIdx] = new ManualResetEvent(false);                        CompressImageBlockLineArgs args = new CompressImageBlockLineArgs(width' height' flags' y' prgba' targetBlock' bytesPerBlock' doneEvents[threadIdx]);                      targetBlock += bytesPerBlock * ((width >> 2) + ((width & 0x3) != 0 ? 1 : 0));                        // To debug un comment this line and comment the next one                      // Threads catch the exceptions (add a try catch ? )                      //CompressImageBlockLineThread(args);                      if (waitOnDone && y > (4*Environment.ProcessorCount))                      {                          WaitHandle.WaitAny(doneEvents);                      }                      ThreadPool.QueueUserWorkItem(CompressImageBlockLineThread' args);                  }                  WaitHandle.WaitAll(doneEvents);              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImage,The following statement contains a magic number: fixed (byte* pblocks = blocks' prgba = rgba)              {                  int bytesPerBlock = ((flags & SquishFlags.kDxt1) != 0) ? 8 : 16;                  byte* targetBlock = pblocks;                    // loop over blocks                  for (int y = 0; y < height; y += 4)                  {                      int threadIdx = GetFreeThreadIdx(doneEvents);                      doneEvents[threadIdx] = new ManualResetEvent(false);                        CompressImageBlockLineArgs args = new CompressImageBlockLineArgs(width' height' flags' y' prgba' targetBlock' bytesPerBlock' doneEvents[threadIdx]);                      targetBlock += bytesPerBlock * ((width >> 2) + ((width & 0x3) != 0 ? 1 : 0));                        // To debug un comment this line and comment the next one                      // Threads catch the exceptions (add a try catch ? )                      //CompressImageBlockLineThread(args);                      if (waitOnDone && y > (4*Environment.ProcessorCount))                      {                          WaitHandle.WaitAny(doneEvents);                      }                      ThreadPool.QueueUserWorkItem(CompressImageBlockLineThread' args);                  }                  WaitHandle.WaitAll(doneEvents);              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImage,The following statement contains a magic number: fixed (byte* pblocks = blocks' prgba = rgba)              {                  int bytesPerBlock = ((flags & SquishFlags.kDxt1) != 0) ? 8 : 16;                  byte* targetBlock = pblocks;                    // loop over blocks                  for (int y = 0; y < height; y += 4)                  {                      int threadIdx = GetFreeThreadIdx(doneEvents);                      doneEvents[threadIdx] = new ManualResetEvent(false);                        CompressImageBlockLineArgs args = new CompressImageBlockLineArgs(width' height' flags' y' prgba' targetBlock' bytesPerBlock' doneEvents[threadIdx]);                      targetBlock += bytesPerBlock * ((width >> 2) + ((width & 0x3) != 0 ? 1 : 0));                        // To debug un comment this line and comment the next one                      // Threads catch the exceptions (add a try catch ? )                      //CompressImageBlockLineThread(args);                      if (waitOnDone && y > (4*Environment.ProcessorCount))                      {                          WaitHandle.WaitAny(doneEvents);                      }                      ThreadPool.QueueUserWorkItem(CompressImageBlockLineThread' args);                  }                  WaitHandle.WaitAll(doneEvents);              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
Magic Number,LibSquishPort,squish,C:\repos\rbray89_ActiveTextureManagement\LibSquishPort\squish.cs,CompressImageBlockLine,The following statement contains a magic number: for (int x = 0; x < width; x += 4)              {                  // build the 4x4 block of pixels                  byte[] sourceRgba = new byte[16 * 4];                  fixed (byte* psourceRgba = sourceRgba)                  {                      byte* targetPixel = psourceRgba;                      int mask = 0;                      for (int py = 0; py < 4; ++py)                      {                          for (int px = 0; px < 4; ++px)                          {                              // get the source pixel in the image                              int sx = x + px;                              int sy = y + py;                                // enable if we're in the image                              if (sx < width && sy < height)                              {                                  // copy the rgba value                                  byte* sourcePixel = prgba + 4 * (width * sy + sx);                                  for (int i = 0; i < 4; ++i)                                  {                                      *targetPixel++ = *sourcePixel++;                                  }                                    // enable this pixel                                  mask |= (1 << (4 * py + px));                              }                              else                              {                                  // skip this pixel as its outside the image                                  targetPixel += 4;                              }                          }                      }                        // compress it into the output                      CompressMasked(sourceRgba' mask' targetBlock' flags);                  }                  // advance                  targetBlock += bytesPerBlock;              }
