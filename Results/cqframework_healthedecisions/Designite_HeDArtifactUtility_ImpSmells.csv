Implementation smell,Namespace,Class,File,Method,Description
Complex Method,HeDArtifactUtility,ArtifactUtility,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\ArtifactUtility.cs,Run,Cyclomatic complexity of the method is 11
Complex Method,HeDArtifactUtility,ArtifactUtility,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\ArtifactUtility.cs,LoadMaps,Cyclomatic complexity of the method is 27
Complex Method,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,Parser,Cyclomatic complexity of the method is 10
Complex Method,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ParseArgumentList,Cyclomatic complexity of the method is 24
Complex Method,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,GetUsageString,Cyclomatic complexity of the method is 11
Complex Method,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,LexFileArguments,Cyclomatic complexity of the method is 15
Long Identifier,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,GetUsageString,The length of the parameter minimumNumberOfCharsForHelpText is 31.
Long Statement,HeDArtifactUtility,ArtifactUtility,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\ArtifactUtility.cs,GetOutputFileName,The length of the statement  "		OutputFileName = String.Format ("{0}.{1}{2}"' Path.GetFileNameWithoutExtension (InputFileName)' TargetFormat' targetExtension); " is 127.
Long Statement,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,IsValidElementType,The length of the statement  "	return type != null && (type == typeof(int) || type == typeof(uint) || type == typeof(string) || type == typeof(bool) || type.IsEnum); " is 134.
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ArgumentsUsage,The following statement contains a magic number: if (screenWidth == 0)  	screenWidth = 80;  
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ArgumentsUsage,The following statement contains a magic number: screenWidth = 80;  
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ParseArgumentList,The following statement contains a magic number: if (args != null) {  	foreach (string argument in args) {  		if (argument.Length > 0) {  			switch (argument [0]) {  			case '-':  			case '/':  				int endIndex = argument.IndexOfAny (new char[] {  					':''  					'+''  					'-'  				}' 1);  				string option = argument.Substring (1' endIndex == -1 ? argument.Length - 1 : endIndex - 1);  				string optionArgument;  				if (option.Length + 1 == argument.Length) {  					optionArgument = null;  				}  				else if (argument.Length > 1 + option.Length && argument [1 + option.Length] == ':') {  					optionArgument = argument.Substring (option.Length + 2);  				}  				else {  					optionArgument = argument.Substring (option.Length + 1);  				}  				Argument arg = (Argument)this.argumentMap [option];  				if (arg == null) {  					ReportUnrecognizedArgument (argument);  					hadError = true;  				}  				else {  					hadError |= !arg.SetValue (optionArgument' destination);  				}  				break;  			case '@':  				string[] nestedArguments;  				hadError |= LexFileArguments (argument.Substring (1)' out nestedArguments);  				hadError |= ParseArgumentList (nestedArguments' destination);  				break;  			default:  				if (this.defaultArgument != null) {  					hadError |= !this.defaultArgument.SetValue (argument' destination);  				}  				else {  					ReportUnrecognizedArgument (argument);  					hadError = true;  				}  				break;  			}  		}  	}  }  
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ParseArgumentList,The following statement contains a magic number: foreach (string argument in args) {  	if (argument.Length > 0) {  		switch (argument [0]) {  		case '-':  		case '/':  			int endIndex = argument.IndexOfAny (new char[] {  				':''  				'+''  				'-'  			}' 1);  			string option = argument.Substring (1' endIndex == -1 ? argument.Length - 1 : endIndex - 1);  			string optionArgument;  			if (option.Length + 1 == argument.Length) {  				optionArgument = null;  			}  			else if (argument.Length > 1 + option.Length && argument [1 + option.Length] == ':') {  				optionArgument = argument.Substring (option.Length + 2);  			}  			else {  				optionArgument = argument.Substring (option.Length + 1);  			}  			Argument arg = (Argument)this.argumentMap [option];  			if (arg == null) {  				ReportUnrecognizedArgument (argument);  				hadError = true;  			}  			else {  				hadError |= !arg.SetValue (optionArgument' destination);  			}  			break;  		case '@':  			string[] nestedArguments;  			hadError |= LexFileArguments (argument.Substring (1)' out nestedArguments);  			hadError |= ParseArgumentList (nestedArguments' destination);  			break;  		default:  			if (this.defaultArgument != null) {  				hadError |= !this.defaultArgument.SetValue (argument' destination);  			}  			else {  				ReportUnrecognizedArgument (argument);  				hadError = true;  			}  			break;  		}  	}  }  
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ParseArgumentList,The following statement contains a magic number: if (argument.Length > 0) {  	switch (argument [0]) {  	case '-':  	case '/':  		int endIndex = argument.IndexOfAny (new char[] {  			':''  			'+''  			'-'  		}' 1);  		string option = argument.Substring (1' endIndex == -1 ? argument.Length - 1 : endIndex - 1);  		string optionArgument;  		if (option.Length + 1 == argument.Length) {  			optionArgument = null;  		}  		else if (argument.Length > 1 + option.Length && argument [1 + option.Length] == ':') {  			optionArgument = argument.Substring (option.Length + 2);  		}  		else {  			optionArgument = argument.Substring (option.Length + 1);  		}  		Argument arg = (Argument)this.argumentMap [option];  		if (arg == null) {  			ReportUnrecognizedArgument (argument);  			hadError = true;  		}  		else {  			hadError |= !arg.SetValue (optionArgument' destination);  		}  		break;  	case '@':  		string[] nestedArguments;  		hadError |= LexFileArguments (argument.Substring (1)' out nestedArguments);  		hadError |= ParseArgumentList (nestedArguments' destination);  		break;  	default:  		if (this.defaultArgument != null) {  			hadError |= !this.defaultArgument.SetValue (argument' destination);  		}  		else {  			ReportUnrecognizedArgument (argument);  			hadError = true;  		}  		break;  	}  }  
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ParseArgumentList,The following statement contains a magic number: switch (argument [0]) {  case '-':  case '/':  	int endIndex = argument.IndexOfAny (new char[] {  		':''  		'+''  		'-'  	}' 1);  	string option = argument.Substring (1' endIndex == -1 ? argument.Length - 1 : endIndex - 1);  	string optionArgument;  	if (option.Length + 1 == argument.Length) {  		optionArgument = null;  	}  	else if (argument.Length > 1 + option.Length && argument [1 + option.Length] == ':') {  		optionArgument = argument.Substring (option.Length + 2);  	}  	else {  		optionArgument = argument.Substring (option.Length + 1);  	}  	Argument arg = (Argument)this.argumentMap [option];  	if (arg == null) {  		ReportUnrecognizedArgument (argument);  		hadError = true;  	}  	else {  		hadError |= !arg.SetValue (optionArgument' destination);  	}  	break;  case '@':  	string[] nestedArguments;  	hadError |= LexFileArguments (argument.Substring (1)' out nestedArguments);  	hadError |= ParseArgumentList (nestedArguments' destination);  	break;  default:  	if (this.defaultArgument != null) {  		hadError |= !this.defaultArgument.SetValue (argument' destination);  	}  	else {  		ReportUnrecognizedArgument (argument);  		hadError = true;  	}  	break;  }  
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ParseArgumentList,The following statement contains a magic number: if (option.Length + 1 == argument.Length) {  	optionArgument = null;  }  else if (argument.Length > 1 + option.Length && argument [1 + option.Length] == ':') {  	optionArgument = argument.Substring (option.Length + 2);  }  else {  	optionArgument = argument.Substring (option.Length + 1);  }  
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ParseArgumentList,The following statement contains a magic number: if (argument.Length > 1 + option.Length && argument [1 + option.Length] == ':') {  	optionArgument = argument.Substring (option.Length + 2);  }  else {  	optionArgument = argument.Substring (option.Length + 1);  }  
Magic Number,CommandLine,Parser,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\CommandLineArguments.cs,ParseArgumentList,The following statement contains a magic number: optionArgument = argument.Substring (option.Length + 2);  
Missing Default,HeDArtifactUtility,ArtifactUtility,C:\repos\cqframework_healthedecisions\tooling\framework\HeDArtifactUtility\ArtifactUtility.cs,LoadMaps,The following switch statement is missing a default case: switch (MapReader.ReadHandlerType (mapDocument)) {  case HandlerType.ModuleRegistration:  	ModuleRegistrarFactory.LoadMap (MapReader.ReadMap (mapDocument));  	break;  case HandlerType.TypeResolution:  	TypeResolverFactory.LoadMap (MapReader.ReadMap (mapDocument));  	break;  case HandlerType.LibraryReader:  	LibraryReaderFactory.LoadMap (MapReader.ReadMap (mapDocument));  	break;  case HandlerType.Verification:  	NodeVerifierFactory.LoadMap (MapReader.ReadMap (mapDocument));  	break;  case HandlerType.Translation:  	ArtifactTranslatorFactory.LoadMap (MapReader.ReadMap (mapDocument));  	break;  case HandlerType.NodeTranslation:  	NodeTranslatorFactory.LoadMap (MapReader.ReadMap (mapDocument));  	break;  case HandlerType.ModelTranslation:  	ModelTranslatorFactory.LoadMap (MapReader.ReadMap (mapDocument));  	break;  case HandlerType.Writing:  	ArtifactWriterFactory.LoadMap (MapReader.ReadMap (mapDocument));  	break;  }  
