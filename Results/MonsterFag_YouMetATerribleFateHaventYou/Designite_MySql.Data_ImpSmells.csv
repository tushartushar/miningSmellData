Implementation smell,Namespace,Class,File,Method,Description
Long Method,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,ExecuteReader,The method has 130 lines of code.
Long Method,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetRestrictions,The method has 127 lines of code.
Long Method,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetRestrictions,The method has 179 lines of code.
Long Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The method has 114 lines of code.
Long Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The method has 132 lines of code.
Long Method,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The method has 470 lines of code.
Long Method,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The method has 344 lines of code.
Long Method,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The method has 243 lines of code.
Long Method,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The method has 169 lines of code.
Long Method,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The method has 228 lines of code.
Complex Method,MySql.Data.MySqlClient.Authentication,MySqlAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\MySQLAuthenticationPlugin.cs,Authenticate,Cyclomatic complexity of the method is 8
Complex Method,MySql.Data.MySqlClient,MySqlBulkLoader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\BulkLoader.cs,BuildSqlCommand,Cyclomatic complexity of the method is 22
Complex Method,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,GetCommandTextForBatching,Cyclomatic complexity of the method is 11
Complex Method,MySql.Data.MySqlClient,MySqlCommandBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CommandBuilder.cs,DeriveParameters,Cyclomatic complexity of the method is 10
Complex Method,MySql.Data.MySqlClient,MySqlCommandBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CommandBuilder.cs,GetPossibleValues,Cyclomatic complexity of the method is 8
Complex Method,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,Read,Cyclomatic complexity of the method is 8
Complex Method,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,BeginTransaction,Cyclomatic complexity of the method is 20
Complex Method,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,Open,Cyclomatic complexity of the method is 10
Complex Method,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,XorScramble,Cyclomatic complexity of the method is 11
Complex Method,MySql.Data.MySqlClient,MySqlDataAdapter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\dataadapter.cs,OpenConnectionIfClosed,Cyclomatic complexity of the method is 11
Complex Method,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,GetBytes,Cyclomatic complexity of the method is 8
Complex Method,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,NextResult,Cyclomatic complexity of the method is 11
Complex Method,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,Configure,Cyclomatic complexity of the method is 8
Complex Method,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,Cyclomatic complexity of the method is 29
Complex Method,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,GetIMySqlValue,Cyclomatic complexity of the method is 41
Complex Method,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetProcedureParameterLine,Cyclomatic complexity of the method is 9
Complex Method,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseProcedureBody,Cyclomatic complexity of the method is 9
Complex Method,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseDataType,Cyclomatic complexity of the method is 12
Complex Method,MySql.Data.MySqlClient,MySqlConnectionStringBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlConnectionStringBuilder.cs,AddKeywordFromProperty,Cyclomatic complexity of the method is 9
Complex Method,MySql.Data.MySqlClient,MySqlScript,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlScript.cs,BreakIntoStatements,Cyclomatic complexity of the method is 11
Complex Method,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,Cyclomatic complexity of the method is 13
Complex Method,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SetConnectionFlags,Cyclomatic complexity of the method is 12
Complex Method,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,SetMySqlDbType,Cyclomatic complexity of the method is 68
Complex Method,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,SetDbType,Cyclomatic complexity of the method is 61
Complex Method,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,SetTypeFromValue,Cyclomatic complexity of the method is 46
Complex Method,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,Cyclomatic complexity of the method is 9
Complex Method,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeysOnTable,Cyclomatic complexity of the method is 8
Complex Method,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,Cyclomatic complexity of the method is 8
Complex Method,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetSchemaInternal,Cyclomatic complexity of the method is 15
Complex Method,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,ReportUsageAdvisorWarnings,Cyclomatic complexity of the method is 12
Complex Method,MySql.Data.Common,ContextString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\ContextString.cs,Split,Cyclomatic complexity of the method is 12
Complex Method,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,CollapseValueList,Cyclomatic complexity of the method is 12
Complex Method,MySql.Data.Common,SharedMemoryStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\SharedMemoryStream.cs,Read,Cyclomatic complexity of the method is 9
Complex Method,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,IsNumericType,Cyclomatic complexity of the method is 14
Complex Method,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,IsTextType,Cyclomatic complexity of the method is 10
Complex Method,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,NameToType,Cyclomatic complexity of the method is 36
Complex Method,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,Cyclomatic complexity of the method is 9
Complex Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,Cyclomatic complexity of the method is 11
Complex Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,fill_window,Cyclomatic complexity of the method is 8
Complex Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_fast,Cyclomatic complexity of the method is 12
Complex Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,Cyclomatic complexity of the method is 16
Complex Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,Cyclomatic complexity of the method is 8
Complex Method,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,Cyclomatic complexity of the method is 32
Complex Method,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,Cyclomatic complexity of the method is 126
Complex Method,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,Cyclomatic complexity of the method is 126
Complex Method,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,Cyclomatic complexity of the method is 22
Complex Method,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,Cyclomatic complexity of the method is 111
Complex Method,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 29
Complex Method,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 15
Complex Method,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,Cyclomatic complexity of the method is 8
Complex Method,zlib,ZInputStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\ZInputStream.cs,read,Cyclomatic complexity of the method is 9
Long Parameter List,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,AcquireCredentialsHandle,The method has 9 parameters.
Long Parameter List,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,InitializeSecurityContext,The method has 12 parameters.
Long Parameter List,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,InitializeSecurityContext,The method has 12 parameters.
Long Parameter List,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,XorScramble,The method has 6 parameters.
Long Parameter List,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,GetBytes,The method has 5 parameters.
Long Parameter List,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,GetChars,The method has 5 parameters.
Long Parameter List,MySql.Data.MySqlClient,MySqlHelper,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlHelper.cs,ExecuteReader,The method has 5 parameters.
Long Parameter List,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,MySqlParameter,The method has 6 parameters.
Long Parameter List,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,MySqlParameter,The method has 10 parameters.
Long Parameter List,MySql.Data.Common,NativeMethods,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NativeMethods.cs,CreateFile,The method has 7 parameters.
Long Parameter List,MySql.Data.Common,NativeMethods,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NativeMethods.cs,PeekNamedPipe,The method has 6 parameters.
Long Parameter List,MySql.Data.Common,NativeMethods,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NativeMethods.cs,ReadFile,The method has 5 parameters.
Long Parameter List,MySql.Data.Common,NativeMethods,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NativeMethods.cs,WriteFile,The method has 5 parameters.
Long Parameter List,MySql.Data.Common,NativeMethods,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NativeMethods.cs,MapViewOfFile,The method has 5 parameters.
Long Parameter List,MySql.Data.Common,NativeMethods,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NativeMethods.cs,WSAIoctl,The method has 9 parameters.
Long Parameter List,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,StreamCreator,The method has 5 parameters.
Long Parameter List,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,MySqlDateTime,The method has 7 parameters.
Long Parameter List,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,MySqlDateTime,The method has 8 parameters.
Long Parameter List,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The method has 6 parameters.
Long Parameter List,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,InfCodes,The method has 7 parameters.
Long Parameter List,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,InfCodes,The method has 5 parameters.
Long Parameter List,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The method has 8 parameters.
Long Parameter List,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The method has 11 parameters.
Long Parameter List,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters.
Long Parameter List,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters.
Long Parameter List,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters.
Long Parameter List,zlib,StaticTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\StaticTree.cs,StaticTree,The method has 5 parameters.
Long Statement,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,InitializeClient,The length of the statement  "			ss = InitializeSecurityContext (ref outboundCredentials' IntPtr.Zero' targetName' STANDARD_CONTEXT_ATTRIBUTES' 0' SECURITY_NETWORK_DREP' IntPtr.Zero' /* always zero first time around */0' out clientContext' out clientBufferDesc' out ContextAttributes' out initLifetime); " is 270.
Long Statement,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,InitializeClient,The length of the statement  "				ss = InitializeSecurityContext (ref outboundCredentials' ref clientContext' targetName' STANDARD_CONTEXT_ATTRIBUTES' 0' SECURITY_NETWORK_DREP' ref serverBufferDesc' 0' out clientContext' out clientBufferDesc' out ContextAttributes' out initLifetime); " is 250.
Long Statement,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,InitializeClient,The length of the statement  "		if (ss != SEC_E_OK && ss != SEC_I_CONTINUE_NEEDED && ss != SEC_I_COMPLETE_NEEDED && ss != SEC_I_COMPLETE_AND_CONTINUE) { " is 120.
Long Statement,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,AcquireCredentials,The length of the statement  "	var ss = AcquireCredentialsHandle (null' "Negotiate"' SECPKG_CRED_OUTBOUND' IntPtr.Zero' IntPtr.Zero' 0' IntPtr.Zero' ref outboundCredentials' ref lifetime); " is 157.
Long Statement,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,CheckState,The length of the statement  "		Throw (new MySqlException ("There is already an open DataReader associated with this Connection which must be closed first.")); " is 127.
Long Statement,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,ExecuteNonQuery,The length of the statement  "	if (connection != null && connection.commandInterceptor != null && connection.commandInterceptor.ExecuteNonQuery (CommandText' ref records)) " is 140.
Long Statement,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,ExecuteReader,The length of the statement  "	if (connection != null && connection.commandInterceptor != null && connection.commandInterceptor.ExecuteReader (CommandText' behavior' ref interceptedReader)) " is 158.
Long Statement,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,Abort,The length of the statement  "		MySqlTrace.LogWarning (ServerThread' String.Concat ("Error occurred aborting the connection. Exception was: "' ex.Message)); " is 124.
Long Statement,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,NextResult,The length of the statement  "	var isCaching = command.CommandType == CommandType.TableDirect && command.EnableCaching && (commandBehavior & CommandBehavior.SequentialAccess) == 0; " is 149.
Long Statement,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,Configure,The length of the statement  "	if ((clientCharSet != null && clientCharSet.ToString () != charSet) || (connCharSet != null && connCharSet.ToString () != charSet)) { " is 133.
Long Statement,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,LoadCharacterSets,The length of the statement  "				charSets [Convert.ToInt32 (reader ["id"]' NumberFormatInfo.InvariantInfo)] = reader.GetString (reader.GetOrdinal ("charset")); " is 126.
Long Statement,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The length of the statement  "	if (String.IsNullOrEmpty (TableName) && String.IsNullOrEmpty (RealTableName) && IsBinary && driver.Settings.FunctionsReturnString) { " is 132.
Long Statement,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The length of the statement  "		var showCreateSql = String.Format ("SHOW CREATE {0} `{1}`.`{2}`"' routine ["ROUTINE_TYPE"]' routine ["ROUTINE_SCHEMA"]' routine ["ROUTINE_NAME"]); " is 146.
Long Statement,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The length of the statement  "			throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex); " is 123.
Long Statement,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseDataType,The length of the statement  "	while (token != ")" && token != "'" && String.Compare (token' "begin"' true) != 0 && String.Compare (token' "return"' true) != 0) { " is 131.
Long Statement,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseDataType,The length of the statement  "		row ["CHARACTER_OCTET_LENGTH"] = CharSetMap.GetMaxLength (row ["CHARACTER_SET_NAME"].ToString ()' connection) * (int)row ["CHARACTER_MAXIMUM_LENGTH"]; " is 150.
Long Statement,MySql.Data.MySqlClient,MySqlConnectionStringBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlConnectionStringBuilder.cs,NormalizeValue,The length of the statement  "	if (keyword == "Integrated Security" && value is string && ((string)value).ToLower (CultureInfo.InvariantCulture) == "sspi") { " is 126.
Long Statement,MySql.Data.MySqlClient,MySqlConnectionStringBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlConnectionStringBuilder.cs,ValidateKeyword,The length of the statement  "	            if (validKeywords[key] == "Certificate File" || validKeywords[key] == "Certificate Password" || validKeywords[key] == "SSL Mode" " is 128.
Long Statement,MySql.Data.MySqlClient,MySqlConnectionStringBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlConnectionStringBuilder.cs,ValidateKeyword,The length of the statement  "                || validKeywords[key] == "Encrypt" || validKeywords[key] == "Certificate Store Location" || validKeywords[key] == "Certificate Thumbprint")" is 139.
Long Statement,MySql.Data.MySqlClient,MySqlConnectionStringBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlConnectionStringBuilder.cs,Initialize,The length of the statement  "	var encrypt = typeof(MySqlConnectionStringBuilder).GetProperty ("Encrypt"' BindingFlags.Instance | BindingFlags.NonPublic); " is 123.
Long Statement,MySql.Data.MySqlClient,MySqlConnectionStringBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlConnectionStringBuilder.cs,AddKeywordFromProperty,The length of the statement  "			defaultValues [displayName] = new PropertyDefaultValue (pi.PropertyType' Convert.ChangeType ((a as DefaultValueAttribute).Value' pi.PropertyType' CultureInfo.CurrentCulture)); " is 175.
Long Statement,MySql.Data.MySqlClient,MySqlTrace,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlTrace.cs,EnableQueryAnalyzer,The length of the statement  "	var l = (TraceListener)Activator.CreateInstance ("MySql.EMTrace"' "MySql.EMTrace.EMTraceListener"' false' BindingFlags.CreateInstance' null' new object[] { " is 155.
Long Statement,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The length of the statement  "	/* New protocol with 16 bytes to describe server characteristics */owner.ConnectionCharSetIndex = (int)packet.ReadByte (); " is 122.
Long Statement,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetClientCertificates,The length of the statement  "	var location = (Settings.CertificateStoreLocation == MySqlCertificateStoreLocation.CurrentUser) ? StoreLocation.CurrentUser : StoreLocation.LocalMachine; " is 153.
Long Statement,MySql.Data.MySqlClient,MySqlParameterCollection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter_collection.cs,GetParameter,The length of the statement  "		if (parameterName.StartsWith ("@"' StringComparison.Ordinal) || parameterName.StartsWith ("?"' StringComparison.Ordinal)) { " is 123.
Long Statement,MySql.Data.MySqlClient,MySqlParameterCollection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter_collection.cs,InternalAdd,The length of the statement  "		throw new ArgumentException ("The MySqlParameterCollection only accepts non-null MySqlParameter type objects."' "value"); " is 121.
Long Statement,MySql.Data.MySqlClient,MySqlParameterCollection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter_collection.cs,GetParameterFlexible,The length of the statement  "	if (parameterName.StartsWith ("@"' StringComparison.Ordinal) || parameterName.StartsWith ("?"' StringComparison.Ordinal)) " is 121.
Long Statement,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The length of the statement  "		var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' MySqlHelper.DoubleQuoteString ((string)table ["TABLE_SCHEMA"])' MySqlHelper.DoubleQuoteString ((string)table ["TABLE_NAME"])); " is 182.
Long Statement,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The length of the statement  "			if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3])) " is 130.
Long Statement,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The length of the statement  "			row ["DTD_IDENTIFIER"] = routineType.ToLower (CultureInfo.InvariantCulture) == "function" ? (object)reader.GetString ("returns") : DBNull.Value; " is 144.
Long Statement,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetDataSourceInformation,The length of the statement  "	row ["IdentifierPattern"] = @"(^\`\p{Lo}\p{Lu}\p{Ll}_@#][\p{Lo}\p{Lu}\p{Ll}\p{Nd}@$#_]*$)|(^\`[^\`\0]|\`\`+\`$)|(^\"" + [^\""\0]|\""\""+\""$)"; " is 143.
Long Statement,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetReservedWords,The length of the statement  "	var str = Assembly.GetExecutingAssembly ().GetManifestResourceStream ("MySql.Data.MySqlClient.Properties.ReservedWords.txt"); " is 125.
Long Statement,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetSchemaInternal,The length of the statement  "	if (connection != null && connection.Database != null && connection.Database.Length > 0 && restrictions.Length > 1 && restrictions [1] == null) " is 143.
Long Statement,MySql.Data.MySqlClient,StoredProcedure,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\StoredProcedure.cs,CreateOutputSelect,The length of the statement  "		if ((p.Direction == ParameterDirection.InputOutput || p.Direction == ParameterDirection.Output) && serverProvidingOutputParameters) " is 131.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,Open,The length of the statement  "	MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.ConnectionOpened' Resources.TraceOpenConnection' driverId' Settings.ConnectionString' ThreadID); " is 167.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,Close,The length of the statement  "	MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.ConnectionClosed' Resources.TraceCloseConnection' driverId); " is 131.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,SendQuery,The length of the statement  "	MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.QueryOpened' Resources.TraceQueryOpened' driverId' ThreadID' cmdText); " is 141.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,SendQuery,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.QueryNormalized' Resources.TraceQueryNormalized' driverId' ThreadID' normalized_query); " is 158.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,GetResult,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.ResultOpened' Resources.TraceResult' driverId' fieldCount' affectedRows' insertedId); " is 156.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,GetResult,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.Error' Resources.TraceOpenResultError' driverId' ex.Number' ex.Message); " is 143.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,NextResult,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.ResultClosed' Resources.TraceResultClosed' driverId' activeResult.TotalRows' activeResult.SkippedRows' rowSizeInBytes); " is 190.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,PrepareStatement,The length of the statement  "	MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.StatementPrepared' Resources.TraceStatementPrepared' driverId' sql' statementId); " is 152.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,CloseStatement,The length of the statement  "	MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.StatementClosed' Resources.TraceStatementClosed' driverId' id); " is 134.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,SetDatabase,The length of the statement  "	MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.NonQuery' Resources.TraceSetDatabase' driverId' dbName); " is 127.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,ExecuteStatement,The length of the statement  "	MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.StatementExecuted' Resources.TraceStatementExecuted' driverId' statementId' ThreadID); " is 157.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,FetchDataRow,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Error' MySqlTraceEventType.Error' Resources.TraceFetchError' driverId' ex.Number' ex.Message); " is 132.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,CloseQuery,The length of the statement  "	MySqlTrace.TraceEvent (TraceEventType.Information' MySqlTraceEventType.QueryClosed' Resources.TraceQueryDone' driverId); " is 120.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,ReportWarnings,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Warning' MySqlTraceEventType.Warning' Resources.TraceWarning' driverId' warning.Level' warning.Code' warning.Message); " is 156.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,ReportUsageAdvisorWarnings,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Warning' MySqlTraceEventType.UsageAdvisorWarning' Resources.TraceUAWarningNoIndex' driverId' UsageAdvisorWarningFlags.NoIndex); " is 165.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,ReportUsageAdvisorWarnings,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Warning' MySqlTraceEventType.UsageAdvisorWarning' Resources.TraceUAWarningBadIndex' driverId' UsageAdvisorWarningFlags.BadIndex); " is 167.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,ReportUsageAdvisorWarnings,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Warning' MySqlTraceEventType.UsageAdvisorWarning' Resources.TraceUAWarningSkippedRows' driverId' UsageAdvisorWarningFlags.SkippedRows' rs.SkippedRows); " is 189.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,ReportUsageAdvisorWarnings,The length of the statement  "		MySqlTrace.TraceEvent (TraceEventType.Warning' MySqlTraceEventType.UsageAdvisorWarning' Resources.TraceUAWarningSkippedColumns' driverId' UsageAdvisorWarningFlags.SkippedColumns' notAccessed.ToString ()); " is 204.
Long Statement,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,ReportUsageAdvisorWarnings,The length of the statement  "				MySqlTrace.TraceEvent (TraceEventType.Warning' MySqlTraceEventType.UsageAdvisorWarning' Resources.TraceUAWarningFieldConversion' driverId' UsageAdvisorWarningFlags.FieldConversion' f.ColumnName' s.ToString ()); " is 210.
Long Statement,MySql.Data.Common,NamedPipeStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NamedPipeStream.cs,Open,The length of the statement  "		nativeHandle = NativeMethods.CreateFile (path' NativeMethods.GENERIC_READ | NativeMethods.GENERIC_WRITE' 0' security' NativeMethods.OPEN_EXISTING' NativeMethods.FILE_FLAG_OVERLAPPED' 0); " is 186.
Long Statement,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,ProcessMathSymbols,The length of the statement  "			if (lastToken != null && lastToken.Type != TokenType.Number && lastToken.Type != TokenType.Identifier && (lastToken.Type != TokenType.Symbol || lastToken.Text != ")")) " is 167.
Long Statement,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetDnsHostEntry,The length of the statement  "		var message = String.Format (Resources.GetHostEntryFailed' stopwatch.Elapsed' hostname' ex.SocketErrorCode' ex.ErrorCode' ex.NativeErrorCode); " is 142.
Long Statement,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,CreateUnixEndPoint,The length of the statement  "	var ep = (EndPoint)a.CreateInstance ("Mono.Posix.UnixEndPoint"' false' BindingFlags.CreateInstance' null' new object[1] { " is 121.
Long Statement,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,CreateSocketStream,The length of the statement  "	var socket = unix ? new Socket (AddressFamily.Unix' SocketType.Stream' ProtocolType.IP) : new Socket (ip.AddressFamily' SocketType.Stream' ProtocolType.Tcp); " is 157.
Long Statement,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,SerializeText,The length of the statement  "		val = value.Millisecond > 0 ? String.Format ("{0} {1:00}:{2:00}:{3:00}.{4:000}"' val' value.Hour' value.Minute' value.Second' value.Millisecond) : String.Format ("{0} {1:00}:{2:00}:{3:00} "' val' value.Hour' value.Minute' value.Second); " is 236.
Long Statement,MySql.Data.Types,MySqlInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt32.cs,ReadValue,The length of the statement  "		return new MySqlInt32 ((this as IMySqlValue).MySqlDbType' Int32.Parse (packet.ReadString (length)' CultureInfo.InvariantCulture)); " is 130.
Long Statement,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The length of the statement  "		var s = String.Format ("'{0}{1} {2:00}:{3:00}:{4:00}.{5}'"' negative ? "-" : ""' ts.Days' ts.Hours' ts.Minutes' ts.Seconds' ts.Milliseconds); " is 141.
Long Statement,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The length of the statement  "		mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000); " is 141.
Long Statement,MySql.Data.Types,MySqlUInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt32.cs,ReadValue,The length of the statement  "		return new MySqlUInt32 ((this as IMySqlValue).MySqlDbType' UInt32.Parse (packet.ReadString (length)' NumberStyles.Any' CultureInfo.InvariantCulture)); " is 150.
Long Statement,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,The length of the statement  "		if (window [match + best_len] != scan_end || window [match + best_len - 1] != scan_end1 || window [match] != window [scan] || window [++match] != window [scan + 1]) " is 164.
Long Statement,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,The length of the statement  "		while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend); " is 334.
Long Statement,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The length of the statement  "	if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) { " is 179.
Long Statement,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The length of the statement  "	if (strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)) { " is 125.
Long Statement,zlib,ZStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\ZStream.cs,flush_pending,The length of the statement  "	if (dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)) { " is 193.
Long Statement,zlib,ZStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\ZStream.cs,flush_pending,The length of the statement  "		Console.Out.WriteLine (dstate.pending_buf.Length + "' " + dstate.pending_out + "' " + next_out.Length + "' " + next_out_index + "' " + len); " is 140.
Complex Conditional,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,InitializeClient,The conditional expression  "ss != SEC_E_OK && ss != SEC_I_CONTINUE_NEEDED && ss != SEC_I_COMPLETE_NEEDED && ss != SEC_I_COMPLETE_AND_CONTINUE"  is complex.
Complex Conditional,MySql.Data.MySqlClient,MySqlTokenizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\MySqlTokenizer.cs,FindToken,The conditional expression  "c == '`' || c == '\'' || c == '"' || (c == '[' && SqlServerMode)"  is complex.
Complex Conditional,MySql.Data.MySqlClient,MySqlTokenizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\MySqlTokenizer.cs,ReadComment,The conditional expression  "c == '-' && ((pos + 1) >= sql.Length || sql [pos] != '-' || sql [pos + 1] != ' ')"  is complex.
Complex Conditional,MySql.Data.MySqlClient,MySqlTokenizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\MySqlTokenizer.cs,IsSpecialCharacter,The conditional expression  "Char.IsLetterOrDigit (c) || c == '$' || c == '_' || c == '.'"  is complex.
Complex Conditional,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,Configure,The conditional expression  "(clientCharSet != null && clientCharSet.ToString () != charSet) || (connCharSet != null && connCharSet.ToString () != charSet)"  is complex.
Complex Conditional,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The conditional expression  "String.IsNullOrEmpty (TableName) && String.IsNullOrEmpty (RealTableName) && IsBinary && driver.Settings.FunctionsReturnString"  is complex.
Complex Conditional,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The conditional expression  "restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3])"  is complex.
Complex Conditional,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetSchemaInternal,The conditional expression  "connection != null && connection.Database != null && connection.Database.Length > 0 && restrictions.Length > 1 && restrictions [1] == null"  is complex.
Complex Conditional,MySql.Data.MySqlClient,MySqlTransaction,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\transaction.cs,Dispose,The conditional expression  "(conn != null && conn.State == ConnectionState.Open || conn.SoftClosed) && open"  is complex.
Complex Conditional,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,ProcessMathSymbols,The conditional expression  "lastToken != null && lastToken.Type != TokenType.Number && lastToken.Type != TokenType.Identifier && (lastToken.Type != TokenType.Symbol || lastToken.Text != ")")"  is complex.
Complex Conditional,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,CollapseWhitespace,The conditional expression  "t.Output && t.Type == TokenType.Whitespace && lastToken != null && lastToken.Type == TokenType.Whitespace"  is complex.
Complex Conditional,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,IsSpecialCharacter,The conditional expression  "Char.IsLetterOrDigit (c) || c == '$' || c == '_' || c == '.'"  is complex.
Complex Conditional,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,ConsumeComment,The conditional expression  "c == '-' && ((pos + 2) >= fullSql.Length || fullSql [pos + 1] != '-' || fullSql [pos + 2] != ' ')"  is complex.
Complex Conditional,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,The conditional expression  "window [match + best_len] != scan_end || window [match + best_len - 1] != scan_end1 || window [match] != window [scan] || window [++match] != window [scan + 1]"  is complex.
Complex Conditional,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,The conditional expression  "window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend"  is complex.
Complex Conditional,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)"  is complex.
Complex Conditional,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)"  is complex.
Complex Conditional,zlib,ZStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\ZStream.cs,flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)"  is complex.
Empty Catch Block,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,ExecuteReader,The method has an empty catch block.
Empty Catch Block,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,Close,The method has an empty catch block.
Empty Catch Block,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Close,The method has an empty catch block.
Empty Catch Block,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Close,The method has an empty catch block.
Empty Catch Block,MySql.Data.MySqlClient,ResultSet,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ResultSet.cs,Close,The method has an empty catch block.
Empty Catch Block,MySql.Data.Common,NamedPipeStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NamedPipeStream.cs,Close,The method has an empty catch block.
Empty Catch Block,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,SetKeepAlive,The method has an empty catch block.
Empty Catch Block,zlib,ZOutputStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\ZOutputStream.cs,finish,The method has an empty catch block.
Empty Catch Block,zlib,ZOutputStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\MySQLAuthenticationPlugin.cs,Authenticate,The following statement contains a magic number: if (Settings.IntegratedSecurity) {  	if (reset)  		packet.WriteInteger (8' 2);  	if ((Flags & ClientFlags.PLUGIN_AUTH) != 0)  		packet.WriteString (PluginName);  }  
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\MySQLAuthenticationPlugin.cs,Authenticate,The following statement contains a magic number: if (Settings.IntegratedSecurity) {  	if (reset)  		packet.WriteInteger (8' 2);  	if ((Flags & ClientFlags.PLUGIN_AUTH) != 0)  		packet.WriteString (PluginName);  }  
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\MySQLAuthenticationPlugin.cs,Authenticate,The following statement contains a magic number: if (reset)  	packet.WriteInteger (8' 2);  
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\MySQLAuthenticationPlugin.cs,Authenticate,The following statement contains a magic number: if (reset)  	packet.WriteInteger (8' 2);  
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\MySQLAuthenticationPlugin.cs,Authenticate,The following statement contains a magic number: packet.WriteInteger (8' 2);  
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\MySQLAuthenticationPlugin.cs,Authenticate,The following statement contains a magic number: packet.WriteInteger (8' 2);  
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlNativePasswordPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\NativePasswordPlugins.cs,AuthenticationChange,The following statement contains a magic number: base.WritePacketData (Crypt.EncryptPassword (Settings.Password' base.EncryptionSeed.Substring (0' 8)' true));  
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,CheckConstraints,The following statement contains a magic number: if ((p == 4) || (p == 128))  	platform = "Unix";  else if (Environment.OSVersion.Platform == PlatformID.MacOSX)  	platform = "Mac OS/X";  
Magic Number,MySql.Data.MySqlClient.Authentication,MySqlWindowsAuthenticationPlugin,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Authentication\WindowsAuthenticationPlugin.cs,CheckConstraints,The following statement contains a magic number: if ((p == 4) || (p == 128))  	platform = "Unix";  else if (Environment.OSVersion.Platform == PlatformID.MacOSX)  	platform = "Mac OS/X";  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("big5"' new CharacterSet ("big5"' 2));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("ujis"' new CharacterSet ("EUC-JP"' 3));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("sjis"' new CharacterSet ("sjis"' 2));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("euckr"' new CharacterSet ("euc-kr"' 2));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("gb2312"' new CharacterSet ("gb2312"' 2));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("utf8"' new CharacterSet ("utf-8"' 3));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("ucs2"' new CharacterSet ("UTF-16BE"' 2));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("cp852"' new CharacterSet ("ibm852"' 2));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("utf8mb4"' new CharacterSet ("utf-8"' 4));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,LoadCharsetMap,The following statement contains a magic number: mapping.Add ("utf8mb3"' new CharacterSet ("utf-8"' 3));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,InitCollections,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		defaultCollations.Add (reader.GetString (0)' reader.GetString (2));  		maxLengths.Add (reader.GetString (0)' Convert.ToInt32 (reader.GetValue (3)));  	}  }  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,InitCollections,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		defaultCollations.Add (reader.GetString (0)' reader.GetString (2));  		maxLengths.Add (reader.GetString (0)' Convert.ToInt32 (reader.GetValue (3)));  	}  }  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,InitCollections,The following statement contains a magic number: while (reader.Read ()) {  	defaultCollations.Add (reader.GetString (0)' reader.GetString (2));  	maxLengths.Add (reader.GetString (0)' Convert.ToInt32 (reader.GetValue (3)));  }  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,InitCollections,The following statement contains a magic number: while (reader.Read ()) {  	defaultCollations.Add (reader.GetString (0)' reader.GetString (2));  	maxLengths.Add (reader.GetString (0)' Convert.ToInt32 (reader.GetValue (3)));  }  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,InitCollections,The following statement contains a magic number: defaultCollations.Add (reader.GetString (0)' reader.GetString (2));  
Magic Number,MySql.Data.MySqlClient,CharSetMap,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CharSetMap.cs,InitCollections,The following statement contains a magic number: maxLengths.Add (reader.GetString (0)' Convert.ToInt32 (reader.GetValue (3)));  
Magic Number,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,BeginExecuteNonQuery,The following statement contains a magic number: asyncResult = caller.BeginInvoke (2' CommandBehavior.Default' callback' stateObject);  
Magic Number,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,BeginExecuteNonQuery,The following statement contains a magic number: asyncResult = caller.BeginInvoke (2' CommandBehavior.Default' null' null);  
Magic Number,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,GetCommandTextForBatching,The following statement contains a magic number: if (batchableCommandText == null) {  	// if the command starts with insert and is "simple" enough' then  	// we can use the multi-value form of insert  	if (String.Compare (CommandText.Substring (0' 6)' "INSERT"' true) == 0) {  		var cmd = new MySqlCommand ("SELECT @@sql_mode"' Connection);  		var sql_mode = cmd.ExecuteScalar ().ToString ().ToUpper (CultureInfo.InvariantCulture);  		var tokenizer = new MySqlTokenizer (CommandText);  		tokenizer.AnsiQuotes = sql_mode.IndexOf ("ANSI_QUOTES") != -1;  		tokenizer.BackslashEscapes = sql_mode.IndexOf ("NO_BACKSLASH_ESCAPES") == -1;  		var token = tokenizer.NextToken ().ToLower (CultureInfo.InvariantCulture);  		while (token != null) {  			if (token.ToUpper (CultureInfo.InvariantCulture) == "VALUES" && !tokenizer.Quoted) {  				token = tokenizer.NextToken ();  				Debug.Assert (token == "(");  				// find matching right paren' and ensure that parens   				// are balanced.  				var openParenCount = 1;  				while (token != null) {  					batchableCommandText += token;  					token = tokenizer.NextToken ();  					if (token == "(")  						openParenCount++;  					else if (token == ")")  						openParenCount--;  					if (openParenCount == 0)  						break;  				}  				if (token != null)  					batchableCommandText += token;  				token = tokenizer.NextToken ();  				if (token != null && (token == "'" || token.ToUpper (CultureInfo.InvariantCulture) == "ON")) {  					batchableCommandText = null;  					break;  				}  			}  			token = tokenizer.NextToken ();  		}  	}  	// Otherwise use the command verbatim  	else  		batchableCommandText = CommandText;  }  
Magic Number,MySql.Data.MySqlClient,MySqlCommand,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\command.cs,GetCommandTextForBatching,The following statement contains a magic number: if (String.Compare (CommandText.Substring (0' 6)' "INSERT"' true) == 0) {  	var cmd = new MySqlCommand ("SELECT @@sql_mode"' Connection);  	var sql_mode = cmd.ExecuteScalar ().ToString ().ToUpper (CultureInfo.InvariantCulture);  	var tokenizer = new MySqlTokenizer (CommandText);  	tokenizer.AnsiQuotes = sql_mode.IndexOf ("ANSI_QUOTES") != -1;  	tokenizer.BackslashEscapes = sql_mode.IndexOf ("NO_BACKSLASH_ESCAPES") == -1;  	var token = tokenizer.NextToken ().ToLower (CultureInfo.InvariantCulture);  	while (token != null) {  		if (token.ToUpper (CultureInfo.InvariantCulture) == "VALUES" && !tokenizer.Quoted) {  			token = tokenizer.NextToken ();  			Debug.Assert (token == "(");  			// find matching right paren' and ensure that parens   			// are balanced.  			var openParenCount = 1;  			while (token != null) {  				batchableCommandText += token;  				token = tokenizer.NextToken ();  				if (token == "(")  					openParenCount++;  				else if (token == ")")  					openParenCount--;  				if (openParenCount == 0)  					break;  			}  			if (token != null)  				batchableCommandText += token;  			token = tokenizer.NextToken ();  			if (token != null && (token == "'" || token.ToUpper (CultureInfo.InvariantCulture) == "ON")) {  				batchableCommandText = null;  				break;  			}  		}  		token = tokenizer.NextToken ();  	}  }  // Otherwise use the command verbatim  else  	batchableCommandText = CommandText;  
Magic Number,MySql.Data.MySqlClient,MySqlCommandBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CommandBuilder.cs,GetPossibleValues,The following statement contains a magic number: for (; index < 2; index++)  	if (dtdIdentifier.StartsWith (types [index]' StringComparison.OrdinalIgnoreCase))  		break;  
Magic Number,MySql.Data.MySqlClient,MySqlCommandBuilder,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CommandBuilder.cs,GetPossibleValues,The following statement contains a magic number: if (index == 2)  	return null;  
Magic Number,MySql.Data.MySqlClient,MySqlTokenizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\MySqlTokenizer.cs,NextParameter,The following statement contains a magic number: while (FindToken ()) {  	if ((stopIndex - startIndex) < 2)  		continue;  	var c1 = sql [startIndex];  	var c2 = sql [startIndex + 1];  	if (c1 == '?' || (c1 == '@' && c2 != '@'))  		return sql.Substring (startIndex' stopIndex - startIndex);  }  
Magic Number,MySql.Data.MySqlClient,MySqlTokenizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\MySqlTokenizer.cs,NextParameter,The following statement contains a magic number: if ((stopIndex - startIndex) < 2)  	continue;  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressedStream,The following statement contains a magic number: lengthBytes = new byte[7];  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,PrepareNextPacket,The following statement contains a magic number: MySqlStream.ReadFully (baseStream' lengthBytes' 0' 7);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressCache,The following statement contains a magic number: if (cache.Length < 50)  	return null;  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: cacheBuffer [3] = 0;  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: Array.Copy (buffer' 0' buffer' 7' (int)dataLength);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [1] = (byte)((compressedLength >> 8) & 0xff);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [2] = (byte)((compressedLength >> 16) & 0xff);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [2] = (byte)((compressedLength >> 16) & 0xff);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [3] = seq;  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [4] = (byte)(uncompressedLength & 0xff);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [5] = (byte)((uncompressedLength >> 8) & 0xff);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [5] = (byte)((uncompressedLength >> 8) & 0xff);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [6] = (byte)((uncompressedLength >> 16) & 0xff);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,CompressAndSendCache,The following statement contains a magic number: buffer [6] = (byte)((uncompressedLength >> 16) & 0xff);  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,InputDone,The following statement contains a magic number: if (cache.Length < 4)  	return false;  
Magic Number,MySql.Data.MySqlClient,CompressedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\CompressedStream.cs,InputDone,The following statement contains a magic number: if (cache.Length < (expectedLen + 4))  	return false;  
Magic Number,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,HandleTimeoutOrThreadAbort,The following statement contains a magic number: try {  	// Do a fast cancel.The reason behind small values for connection  	// and command timeout is that we do not want user to wait longer  	// after command has already expired.  	// Microsoft's SqlClient seems to be using 5 seconds timeouts   	// here as well.  	// Read the  error packet with "interrupted" message.  	CancelQuery (5);  	driver.ResetTimeout (5000);  	if (Reader != null) {  		Reader.Close ();  		Reader = null;  	}  }  catch (Exception ex2) {  	MySqlTrace.LogWarning (ServerThread' "Could not kill query' " + " aborting connection. Exception was " + ex2.Message);  	Abort ();  	isFatal = true;  }  
Magic Number,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,HandleTimeoutOrThreadAbort,The following statement contains a magic number: try {  	// Do a fast cancel.The reason behind small values for connection  	// and command timeout is that we do not want user to wait longer  	// after command has already expired.  	// Microsoft's SqlClient seems to be using 5 seconds timeouts   	// here as well.  	// Read the  error packet with "interrupted" message.  	CancelQuery (5);  	driver.ResetTimeout (5000);  	if (Reader != null) {  		Reader.Close ();  		Reader = null;  	}  }  catch (Exception ex2) {  	MySqlTrace.LogWarning (ServerThread' "Could not kill query' " + " aborting connection. Exception was " + ex2.Message);  	Abort ();  	isFatal = true;  }  
Magic Number,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,HandleTimeoutOrThreadAbort,The following statement contains a magic number: CancelQuery (5);  
Magic Number,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,HandleTimeoutOrThreadAbort,The following statement contains a magic number: driver.ResetTimeout (5000);  
Magic Number,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,SetCommandTimeout,The following statement contains a magic number: driver.ResetTimeout (commandTimeout * 1000);  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,rand,The following statement contains a magic number: seed1 = (seed1 * 3) + seed2;  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,rand,The following statement contains a magic number: seed2 = (seed1 + seed2 + 33) % max;  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,EncryptPassword,The following statement contains a magic number: if (!new_ver)  	seed2 = seed1 / 2;  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,EncryptPassword,The following statement contains a magic number: seed2 = seed1 / 2;  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,EncryptPassword,The following statement contains a magic number: for (var x = 0; x < seed.Length; x++) {  	var r = rand (ref seed1' ref seed2' max);  	scrambled [x] = (char)(Math.Floor (r * 31) + 64);  }  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,EncryptPassword,The following statement contains a magic number: for (var x = 0; x < seed.Length; x++) {  	var r = rand (ref seed1' ref seed2' max);  	scrambled [x] = (char)(Math.Floor (r * 31) + 64);  }  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,EncryptPassword,The following statement contains a magic number: scrambled [x] = (char)(Math.Floor (r * 31) + 64);  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,EncryptPassword,The following statement contains a magic number: scrambled [x] = (char)(Math.Floor (r * 31) + 64);  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,EncryptPassword,The following statement contains a magic number: if (new_ver) {  	/* Make it harder to break */var extra = (char)Math.Floor (rand (ref seed1' ref seed2' max) * 31);  	for (var x = 0; x < scrambled.Length; x++)  		scrambled [x] ^= extra;  }  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,Hash,The following statement contains a magic number: for (var i = 0; i < P.Length; i++) {  	if (P [i] == ' ' || P [i] == '\t')  		continue;  	long temp = (0xff & P [i]);  	val1 ^= (((val1 & 63) + inc) * temp) + (val1 << 8);  	val2 += (val2 << 8) ^ val1;  	inc += temp;  }  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,Hash,The following statement contains a magic number: for (var i = 0; i < P.Length; i++) {  	if (P [i] == ' ' || P [i] == '\t')  		continue;  	long temp = (0xff & P [i]);  	val1 ^= (((val1 & 63) + inc) * temp) + (val1 << 8);  	val2 += (val2 << 8) ^ val1;  	inc += temp;  }  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,Hash,The following statement contains a magic number: for (var i = 0; i < P.Length; i++) {  	if (P [i] == ' ' || P [i] == '\t')  		continue;  	long temp = (0xff & P [i]);  	val1 ^= (((val1 & 63) + inc) * temp) + (val1 << 8);  	val2 += (val2 << 8) ^ val1;  	inc += temp;  }  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,Hash,The following statement contains a magic number: val1 ^= (((val1 & 63) + inc) * temp) + (val1 << 8);  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,Hash,The following statement contains a magic number: val1 ^= (((val1 & 63) + inc) * temp) + (val1 << 8);  
Magic Number,MySql.Data.MySqlClient,Crypt,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Crypt.cs,Hash,The following statement contains a magic number: val2 += (val2 << 8) ^ val1;  
Magic Number,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,Close,The following statement contains a magic number: if (command.Canceled && connection.driver.Version.isAtLeast (5' 1' 0)) {  	// Issue dummy command to clear kill flag  	ClearKillFlag ();  }  
Magic Number,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,GetGuid,The following statement contains a magic number: if (v is byte[]) {  	var bytes = (byte[])v;  	if (bytes.Length == 16)  		return new Guid (bytes);  }  
Magic Number,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,GetGuid,The following statement contains a magic number: if (bytes.Length == 16)  	return new Guid (bytes);  
Magic Number,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,GetSchemaTable,The following statement contains a magic number: for (var i = 0; i < FieldCount; i++) {  	var f = resultSet.Fields [i];  	var r = dataTableSchema.NewRow ();  	r ["ColumnName"] = f.ColumnName;  	r ["ColumnOrdinal"] = ord++;  	r ["ColumnSize"] = f.IsTextField ? f.ColumnLength / f.MaxLength : f.ColumnLength;  	int prec = f.Precision;  	int pscale = f.Scale;  	if (prec != -1)  		r ["NumericPrecision"] = (short)prec;  	if (pscale != -1)  		r ["NumericScale"] = (short)pscale;  	r ["DataType"] = GetFieldType (i);  	r ["ProviderType"] = (int)f.Type;  	r ["IsLong"] = f.IsBlob && f.ColumnLength > 255;  	r ["AllowDBNull"] = f.AllowsNull;  	r ["IsReadOnly"] = false;  	r ["IsRowVersion"] = false;  	r ["IsUnique"] = f.IsUnique;  	r ["IsKey"] = f.IsPrimaryKey;  	r ["IsAutoIncrement"] = f.IsAutoIncrement;  	r ["BaseSchemaName"] = f.DatabaseName;  	r ["BaseCatalogName"] = null;  	r ["BaseTableName"] = f.RealTableName;  	r ["BaseColumnName"] = f.OriginalColumnName;  	dataTableSchema.Rows.Add (r);  }  
Magic Number,MySql.Data.MySqlClient,MySqlDataReader,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\datareader.cs,GetSchemaTable,The following statement contains a magic number: r ["IsLong"] = f.IsBlob && f.ColumnLength > 255;  
Magic Number,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,Driver,The following statement contains a magic number: encoding = Encoding.GetEncoding (1252);  
Magic Number,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,Driver,The following statement contains a magic number: maxPacketSize = 1024;  
Magic Number,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,ReportWarnings,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		warnings.Add (new MySqlError (reader.GetString (0)' reader.GetInt32 (1)' reader.GetString (2)));  	}  }  
Magic Number,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,ReportWarnings,The following statement contains a magic number: while (reader.Read ()) {  	warnings.Add (new MySqlError (reader.GetString (0)' reader.GetInt32 (1)' reader.GetString (2)));  }  
Magic Number,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,ReportWarnings,The following statement contains a magic number: warnings.Add (new MySqlError (reader.GetString (0)' reader.GetInt32 (1)' reader.GetString (2)));  
Magic Number,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,Dispose,The following statement contains a magic number: try {  	ResetTimeout (1000);  	if (disposing)  		handler.Close (isOpen);  	// if we are pooling' then release ourselves  	if (connectionString.Pooling)  		MySqlPoolManager.RemoveConnection (this);  }  catch (Exception) {  	if (disposing)  		throw;  }  finally {  	reader = null;  	isOpen = false;  	disposeInProgress = false;  }  
Magic Number,MySql.Data.MySqlClient,Driver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Driver.cs,Dispose,The following statement contains a magic number: ResetTimeout (1000);  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The following statement contains a magic number: if (IsBlob) {  	// handle blob to UTF8 conversion if requested.  This is only activated  	// on binary blobs  	if (IsBinary && driver.Settings.TreatBlobsAsUTF8) {  		var convertBlob = false;  		var includeRegex = driver.Settings.GetBlobAsUTF8IncludeRegex ();  		var excludeRegex = driver.Settings.GetBlobAsUTF8ExcludeRegex ();  		if (includeRegex != null && includeRegex.IsMatch (ColumnName))  			convertBlob = true;  		else if (includeRegex == null && excludeRegex != null && !excludeRegex.IsMatch (ColumnName))  			convertBlob = true;  		if (convertBlob) {  			binaryOk = false;  			Encoding = Encoding.GetEncoding ("UTF-8");  			charSetIndex = -1;  			// lets driver know we are in charge of encoding  			maxLength = 4;  		}  	}  	if (!IsBinary) {  		if (type == MySqlDbType.TinyBlob)  			mySqlDbType = MySqlDbType.TinyText;  		else if (type == MySqlDbType.MediumBlob)  			mySqlDbType = MySqlDbType.MediumText;  		else if (type == MySqlDbType.Blob)  			mySqlDbType = MySqlDbType.Text;  		else if (type == MySqlDbType.LongBlob)  			mySqlDbType = MySqlDbType.LongText;  	}  }  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The following statement contains a magic number: if (IsBinary && driver.Settings.TreatBlobsAsUTF8) {  	var convertBlob = false;  	var includeRegex = driver.Settings.GetBlobAsUTF8IncludeRegex ();  	var excludeRegex = driver.Settings.GetBlobAsUTF8ExcludeRegex ();  	if (includeRegex != null && includeRegex.IsMatch (ColumnName))  		convertBlob = true;  	else if (includeRegex == null && excludeRegex != null && !excludeRegex.IsMatch (ColumnName))  		convertBlob = true;  	if (convertBlob) {  		binaryOk = false;  		Encoding = Encoding.GetEncoding ("UTF-8");  		charSetIndex = -1;  		// lets driver know we are in charge of encoding  		maxLength = 4;  	}  }  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The following statement contains a magic number: if (convertBlob) {  	binaryOk = false;  	Encoding = Encoding.GetEncoding ("UTF-8");  	charSetIndex = -1;  	// lets driver know we are in charge of encoding  	maxLength = 4;  }  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The following statement contains a magic number: maxLength = 4;  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The following statement contains a magic number: if (Type == MySqlDbType.String && CharacterLength == 36 && !driver.Settings.OldGuids)  	mySqlDbType = MySqlDbType.Guid;  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The following statement contains a magic number: if (CharacterSetIndex == 63)  	CharacterSetIndex = driver.ConnectionCharSetIndex;  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The following statement contains a magic number: if (Type == MySqlDbType.Binary && ColumnLength == 16 && driver.Settings.OldGuids)  	mySqlDbType = MySqlDbType.Guid;  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetFieldEncoding,The following statement contains a magic number: if (cs.name.ToLower (CultureInfo.InvariantCulture) == "utf-8" && version.Major >= 6)  	MaxLength = 4;  else  	MaxLength = cs.byteCount;  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetFieldEncoding,The following statement contains a magic number: if (cs.name.ToLower (CultureInfo.InvariantCulture) == "utf-8" && version.Major >= 6)  	MaxLength = 4;  else  	MaxLength = cs.byteCount;  
Magic Number,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetFieldEncoding,The following statement contains a magic number: MaxLength = 4;  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetTables,The following statement contains a magic number: keys [2] = "TABLE_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetTables,The following statement contains a magic number: keys [3] = "TABLE_TYPE";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetColumns,The following statement contains a magic number: keys [2] = "TABLE_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetColumns,The following statement contains a magic number: keys [3] = "COLUMN_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViews,The following statement contains a magic number: keys [2] = "TABLE_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 2 && restrictions [1] != null)  	where.AppendFormat (CultureInfo.InvariantCulture' "C.table_schema='{0}' "' restrictions [1]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 3 && restrictions [2] != null) {  	if (where.Length > 0)  		where.Append ("AND ");  	where.AppendFormat (CultureInfo.InvariantCulture' "C.table_name='{0}' "' restrictions [2]);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 3 && restrictions [2] != null) {  	if (where.Length > 0)  		where.Append ("AND ");  	where.AppendFormat (CultureInfo.InvariantCulture' "C.table_name='{0}' "' restrictions [2]);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 3 && restrictions [2] != null) {  	if (where.Length > 0)  		where.Append ("AND ");  	where.AppendFormat (CultureInfo.InvariantCulture' "C.table_name='{0}' "' restrictions [2]);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: where.AppendFormat (CultureInfo.InvariantCulture' "C.table_name='{0}' "' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null) {  	if (where.Length > 0)  		where.Append ("AND ");  	where.AppendFormat (CultureInfo.InvariantCulture' "C.column_name='{0}' "' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null) {  	if (where.Length > 0)  		where.Append ("AND ");  	where.AppendFormat (CultureInfo.InvariantCulture' "C.column_name='{0}' "' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null) {  	if (where.Length > 0)  		where.Append ("AND ");  	where.AppendFormat (CultureInfo.InvariantCulture' "C.column_name='{0}' "' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: where.AppendFormat (CultureInfo.InvariantCulture' "C.column_name='{0}' "' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetViewColumns,The following statement contains a magic number: dt.Columns [2].ColumnName = "VIEW_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetTriggers,The following statement contains a magic number: keys [2] = "EVENT_OBJECT_TABLE";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetTriggers,The following statement contains a magic number: keys [3] = "TRIGGER_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetProcedures,The following statement contains a magic number: keys [2] = "ROUTINE_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetProcedures,The following statement contains a magic number: keys [3] = "ROUTINE_TYPE";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetProcedureParameterLine,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	reader.Read ();  	// if we are not the owner of this proc or have permissions  	// then we will get null for the body  	if (reader.IsDBNull (2))  		return null;  	var sql_mode = reader.GetString (1);  	var body = reader.GetString (2);  	var tokenizer = new MySqlTokenizer (body);  	tokenizer.AnsiQuotes = sql_mode.IndexOf ("ANSI_QUOTES") != -1;  	tokenizer.BackslashEscapes = sql_mode.IndexOf ("NO_BACKSLASH_ESCAPES") == -1;  	var token = tokenizer.NextToken ();  	while (token != "(")  		token = tokenizer.NextToken ();  	var start = tokenizer.StartIndex + 1;  	token = tokenizer.NextToken ();  	while (token != ")" || tokenizer.Quoted) {  		token = tokenizer.NextToken ();  		// if we see another ( and we are not quoted then we  		// are in a size element and we need to look for the closing paren  		if (token == "(" && !tokenizer.Quoted) {  			while (token != ")" || tokenizer.Quoted)  				token = tokenizer.NextToken ();  			token = tokenizer.NextToken ();  		}  	}  	return body.Substring (start' tokenizer.StartIndex - start);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetProcedureParameterLine,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	reader.Read ();  	// if we are not the owner of this proc or have permissions  	// then we will get null for the body  	if (reader.IsDBNull (2))  		return null;  	var sql_mode = reader.GetString (1);  	var body = reader.GetString (2);  	var tokenizer = new MySqlTokenizer (body);  	tokenizer.AnsiQuotes = sql_mode.IndexOf ("ANSI_QUOTES") != -1;  	tokenizer.BackslashEscapes = sql_mode.IndexOf ("NO_BACKSLASH_ESCAPES") == -1;  	var token = tokenizer.NextToken ();  	while (token != "(")  		token = tokenizer.NextToken ();  	var start = tokenizer.StartIndex + 1;  	token = tokenizer.NextToken ();  	while (token != ")" || tokenizer.Quoted) {  		token = tokenizer.NextToken ();  		// if we see another ( and we are not quoted then we  		// are in a size element and we need to look for the closing paren  		if (token == "(" && !tokenizer.Quoted) {  			while (token != ")" || tokenizer.Quoted)  				token = tokenizer.NextToken ();  			token = tokenizer.NextToken ();  		}  	}  	return body.Substring (start' tokenizer.StartIndex - start);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetProcedureParameterLine,The following statement contains a magic number: if (reader.IsDBNull (2))  	return null;  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersForRoutineFromIS,The following statement contains a magic number: keys [2] = "SPECIFIC_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersForRoutineFromIS,The following statement contains a magic number: keys [3] = "ROUTINE_TYPE";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersForRoutineFromIS,The following statement contains a magic number: keys [4] = "PARAMETER_NAME";  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromIS,The following statement contains a magic number: if (routines == null || routines.Rows.Count == 0) {  	if (restrictions == null) {  		// first fill our table with the proper structure  		var da = new MySqlDataAdapter ("SELECT * FROM INFORMATION_SCHEMA.PARAMETERS WHERE 1=2"' connection);  		da.Fill (parms);  	}  	else  		GetParametersForRoutineFromIS (parms' restrictions);  }  else  	foreach (DataRow routine in routines.Rows) {  		if (restrictions != null && restrictions.Length >= 3)  			restrictions [2] = routine ["ROUTINE_NAME"].ToString ();  		GetParametersForRoutineFromIS (parms' restrictions);  	}  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromIS,The following statement contains a magic number: if (routines == null || routines.Rows.Count == 0) {  	if (restrictions == null) {  		// first fill our table with the proper structure  		var da = new MySqlDataAdapter ("SELECT * FROM INFORMATION_SCHEMA.PARAMETERS WHERE 1=2"' connection);  		da.Fill (parms);  	}  	else  		GetParametersForRoutineFromIS (parms' restrictions);  }  else  	foreach (DataRow routine in routines.Rows) {  		if (restrictions != null && restrictions.Length >= 3)  			restrictions [2] = routine ["ROUTINE_NAME"].ToString ();  		GetParametersForRoutineFromIS (parms' restrictions);  	}  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromIS,The following statement contains a magic number: foreach (DataRow routine in routines.Rows) {  	if (restrictions != null && restrictions.Length >= 3)  		restrictions [2] = routine ["ROUTINE_NAME"].ToString ();  	GetParametersForRoutineFromIS (parms' restrictions);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromIS,The following statement contains a magic number: foreach (DataRow routine in routines.Rows) {  	if (restrictions != null && restrictions.Length >= 3)  		restrictions [2] = routine ["ROUTINE_NAME"].ToString ();  	GetParametersForRoutineFromIS (parms' restrictions);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromIS,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 3)  	restrictions [2] = routine ["ROUTINE_NAME"].ToString ();  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromIS,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 3)  	restrictions [2] = routine ["ROUTINE_NAME"].ToString ();  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromIS,The following statement contains a magic number: restrictions [2] = routine ["ROUTINE_NAME"].ToString ();  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (!connection.driver.Version.isAtLeast (5' 1' 16))  	return base.GetForeignKeys (restrictions);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (!connection.driver.Version.isAtLeast (5' 1' 16))  	return base.GetForeignKeys (restrictions);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions.Length >= 2 && !String.IsNullOrEmpty (restrictions [1]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.constraint_schema LIKE '{0}'"' restrictions [1]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions.Length >= 3 && !String.IsNullOrEmpty (restrictions [2]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.table_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions.Length >= 3 && !String.IsNullOrEmpty (restrictions [2]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.table_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions.Length >= 3 && !String.IsNullOrEmpty (restrictions [2]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.table_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.table_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions.Length >= 4 && !String.IsNullOrEmpty (restrictions [3]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.constraint_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions.Length >= 4 && !String.IsNullOrEmpty (restrictions [3]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.constraint_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions.Length >= 4 && !String.IsNullOrEmpty (restrictions [3]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.constraint_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: where.AppendFormat (CultureInfo.InvariantCulture' " AND rc.constraint_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (!connection.driver.Version.isAtLeast (5' 0' 6))  	return base.GetForeignKeyColumns (restrictions);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (!connection.driver.Version.isAtLeast (5' 0' 6))  	return base.GetForeignKeyColumns (restrictions);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions.Length >= 2 && !String.IsNullOrEmpty (restrictions [1]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.constraint_schema LIKE '{0}'"' restrictions [1]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions.Length >= 3 && !String.IsNullOrEmpty (restrictions [2]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.table_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions.Length >= 3 && !String.IsNullOrEmpty (restrictions [2]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.table_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions.Length >= 3 && !String.IsNullOrEmpty (restrictions [2]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.table_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.table_name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions.Length >= 4 && !String.IsNullOrEmpty (restrictions [3]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.constraint_name LIKE '{0}'"' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions.Length >= 4 && !String.IsNullOrEmpty (restrictions [3]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.constraint_name LIKE '{0}'"' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions.Length >= 4 && !String.IsNullOrEmpty (restrictions [3]))  	where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.constraint_name LIKE '{0}'"' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: where.AppendFormat (CultureInfo.InvariantCulture' " AND kcu.constraint_name LIKE '{0}'"' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: foreach (DataRow routine in routines.Rows) {  	var showCreateSql = String.Format ("SHOW CREATE {0} `{1}`.`{2}`"' routine ["ROUTINE_TYPE"]' routine ["ROUTINE_SCHEMA"]' routine ["ROUTINE_NAME"]);  	cmd.CommandText = showCreateSql;  	try {  		string nameToRestrict = null;  		if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  			nameToRestrict = restrictions [4];  		using (var reader = cmd.ExecuteReader ()) {  			reader.Read ();  			var body = reader.GetString (2);  			reader.Close ();  			ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  		}  	}  	catch (SqlNullValueException snex) {  		throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex);  	}  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: foreach (DataRow routine in routines.Rows) {  	var showCreateSql = String.Format ("SHOW CREATE {0} `{1}`.`{2}`"' routine ["ROUTINE_TYPE"]' routine ["ROUTINE_SCHEMA"]' routine ["ROUTINE_NAME"]);  	cmd.CommandText = showCreateSql;  	try {  		string nameToRestrict = null;  		if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  			nameToRestrict = restrictions [4];  		using (var reader = cmd.ExecuteReader ()) {  			reader.Read ();  			var body = reader.GetString (2);  			reader.Close ();  			ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  		}  	}  	catch (SqlNullValueException snex) {  		throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex);  	}  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: foreach (DataRow routine in routines.Rows) {  	var showCreateSql = String.Format ("SHOW CREATE {0} `{1}`.`{2}`"' routine ["ROUTINE_TYPE"]' routine ["ROUTINE_SCHEMA"]' routine ["ROUTINE_NAME"]);  	cmd.CommandText = showCreateSql;  	try {  		string nameToRestrict = null;  		if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  			nameToRestrict = restrictions [4];  		using (var reader = cmd.ExecuteReader ()) {  			reader.Read ();  			var body = reader.GetString (2);  			reader.Close ();  			ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  		}  	}  	catch (SqlNullValueException snex) {  		throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex);  	}  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: foreach (DataRow routine in routines.Rows) {  	var showCreateSql = String.Format ("SHOW CREATE {0} `{1}`.`{2}`"' routine ["ROUTINE_TYPE"]' routine ["ROUTINE_SCHEMA"]' routine ["ROUTINE_NAME"]);  	cmd.CommandText = showCreateSql;  	try {  		string nameToRestrict = null;  		if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  			nameToRestrict = restrictions [4];  		using (var reader = cmd.ExecuteReader ()) {  			reader.Read ();  			var body = reader.GetString (2);  			reader.Close ();  			ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  		}  	}  	catch (SqlNullValueException snex) {  		throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex);  	}  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: try {  	string nameToRestrict = null;  	if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  		nameToRestrict = restrictions [4];  	using (var reader = cmd.ExecuteReader ()) {  		reader.Read ();  		var body = reader.GetString (2);  		reader.Close ();  		ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  	}  }  catch (SqlNullValueException snex) {  	throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: try {  	string nameToRestrict = null;  	if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  		nameToRestrict = restrictions [4];  	using (var reader = cmd.ExecuteReader ()) {  		reader.Read ();  		var body = reader.GetString (2);  		reader.Close ();  		ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  	}  }  catch (SqlNullValueException snex) {  	throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: try {  	string nameToRestrict = null;  	if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  		nameToRestrict = restrictions [4];  	using (var reader = cmd.ExecuteReader ()) {  		reader.Read ();  		var body = reader.GetString (2);  		reader.Close ();  		ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  	}  }  catch (SqlNullValueException snex) {  	throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: try {  	string nameToRestrict = null;  	if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  		nameToRestrict = restrictions [4];  	using (var reader = cmd.ExecuteReader ()) {  		reader.Read ();  		var body = reader.GetString (2);  		reader.Close ();  		ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  	}  }  catch (SqlNullValueException snex) {  	throw new InvalidOperationException (String.Format (Resources.UnableToRetrieveParameters' routine ["ROUTINE_NAME"])' snex);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  	nameToRestrict = restrictions [4];  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  	nameToRestrict = restrictions [4];  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 5 && restrictions [4] != null)  	nameToRestrict = restrictions [4];  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: nameToRestrict = restrictions [4];  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetParametersFromShowCreate,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	reader.Read ();  	var body = reader.GetString (2);  	reader.Close ();  	ParseProcedureBody (parametersTable' body' routine' nameToRestrict);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseProcedureBody,The following statement contains a magic number: while (token != ")") {  	var parmRow = parametersTable.NewRow ();  	InitParameterRow (row' parmRow);  	parmRow ["ORDINAL_POSITION"] = pos++;  	// handle mode and name for the parameter  	var mode = token.ToUpper (CultureInfo.InvariantCulture);  	if (!tokenizer.Quoted && modes.Contains (mode)) {  		parmRow ["PARAMETER_MODE"] = mode;  		token = tokenizer.NextToken ();  	}  	if (tokenizer.Quoted)  		token = token.Substring (1' token.Length - 2);  	parmRow ["PARAMETER_NAME"] = token;  	// now parse data type  	token = ParseDataType (parmRow' tokenizer);  	if (token == "'")  		token = tokenizer.NextToken ();  	// now determine if we should include this row after all  	// we need to parse it before this check so we are correctly  	// positioned for the next parameter  	if (nameToRestrict == null || String.Compare (parmRow ["PARAMETER_NAME"].ToString ()' nameToRestrict' true) == 0)  		parametersTable.Rows.Add (parmRow);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseProcedureBody,The following statement contains a magic number: if (tokenizer.Quoted)  	token = token.Substring (1' token.Length - 2);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseProcedureBody,The following statement contains a magic number: token = token.Substring (1' token.Length - 2);  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetDataTypeDefaults,The following statement contains a magic number: if (MetaData.IsNumericType (type) && row ["NUMERIC_PRECISION"].ToString ().Length == 0) {  	row ["NUMERIC_PRECISION"] = 10;  	row ["NUMERIC_SCALE"] = 0;  	if (!MetaData.SupportScale (type))  		format = "({0})";  	return String.Format (format' row ["NUMERIC_PRECISION"]' row ["NUMERIC_SCALE"]);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetDataTypeDefaults,The following statement contains a magic number: row ["NUMERIC_PRECISION"] = 10;  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseDataTypeSize,The following statement contains a magic number: if (!MetaData.IsNumericType (row ["DATA_TYPE"].ToString ())) {  	row ["CHARACTER_MAXIMUM_LENGTH"] = Int32.Parse (parts [0]);  	// will set octet length in a minute  }  else {  	row ["NUMERIC_PRECISION"] = Int32.Parse (parts [0]);  	if (parts.Length == 2)  		row ["NUMERIC_SCALE"] = Int32.Parse (parts [1]);  }  
Magic Number,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,ParseDataTypeSize,The following statement contains a magic number: if (parts.Length == 2)  	row ["NUMERIC_SCALE"] = Int32.Parse (parts [1]);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,Clear,The following statement contains a magic number: Position = 4;  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadNBytes,The following statement contains a magic number: if (c < 1 || c > 4)  	throw new MySqlException (Resources.IncorrectTransmission);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadLong (8);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadLong (8);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadLong (8);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadLong (8);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadLong (8);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadLong (8);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadLong (8);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: return ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: return ReadInteger (3);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadFieldLength,The following statement contains a magic number: return ReadLong (8);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadBitValue,The following statement contains a magic number: for (var i = 0; i < numbytes; i++) {  	value <<= shift;  	value |= bits [pos++];  	shift = 8;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadBitValue,The following statement contains a magic number: shift = 8;  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadLong,The following statement contains a magic number: switch (numbytes) {  case 2:  	return BitConverter.ToUInt16 (bytes' pos);  case 4:  	return BitConverter.ToUInt32 (bytes' pos);  case 8:  	return BitConverter.ToInt64 (bytes' pos);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadLong,The following statement contains a magic number: switch (numbytes) {  case 2:  	return BitConverter.ToUInt16 (bytes' pos);  case 4:  	return BitConverter.ToUInt32 (bytes' pos);  case 8:  	return BitConverter.ToInt64 (bytes' pos);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadLong,The following statement contains a magic number: switch (numbytes) {  case 2:  	return BitConverter.ToUInt16 (bytes' pos);  case 4:  	return BitConverter.ToUInt32 (bytes' pos);  case 8:  	return BitConverter.ToInt64 (bytes' pos);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadULong,The following statement contains a magic number: switch (numbytes) {  case 2:  	return BitConverter.ToUInt16 (bytes' pos);  case 4:  	return BitConverter.ToUInt32 (bytes' pos);  case 8:  	return BitConverter.ToUInt64 (bytes' pos);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadULong,The following statement contains a magic number: switch (numbytes) {  case 2:  	return BitConverter.ToUInt16 (bytes' pos);  case 4:  	return BitConverter.ToUInt32 (bytes' pos);  case 8:  	return BitConverter.ToUInt64 (bytes' pos);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadULong,The following statement contains a magic number: switch (numbytes) {  case 2:  	return BitConverter.ToUInt16 (bytes' pos);  case 4:  	return BitConverter.ToUInt32 (bytes' pos);  case 8:  	return BitConverter.ToUInt64 (bytes' pos);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,Read3ByteInt,The following statement contains a magic number: for (var i = 0; i < 3; i++) {  	value |= (int)(bits [pos++] << shift);  	shift += 8;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,Read3ByteInt,The following statement contains a magic number: for (var i = 0; i < 3; i++) {  	value |= (int)(bits [pos++] << shift);  	shift += 8;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,Read3ByteInt,The following statement contains a magic number: shift += 8;  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,Read3ByteInt,The following statement contains a magic number: buffer.Position += 3;  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadInteger,The following statement contains a magic number: if (numbytes == 3)  	return Read3ByteInt ();  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadInteger,The following statement contains a magic number: Debug.Assert (numbytes <= 4);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteInteger,The following statement contains a magic number: Debug.Assert (numbytes > 0 && numbytes < 9);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteInteger,The following statement contains a magic number: for (var x = 0; x < numbytes; x++) {  	tempBuffer [x] = (byte)(val & 0xff);  	val >>= 8;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteInteger,The following statement contains a magic number: val >>= 8;  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadInteger (4);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadInteger (4);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadInteger (4);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadInteger (4);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadInteger (4);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadInteger (4);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: switch (c) {  case 251:  	return -1;  case 252:  	return ReadInteger (2);  case 253:  	return ReadInteger (3);  case 254:  	return ReadInteger (4);  default:  	return c;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: return ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: return ReadInteger (3);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadPackedInteger,The following statement contains a magic number: return ReadInteger (4);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 251)  	WriteByte ((byte)length);  else if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 251)  	WriteByte ((byte)length);  else if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 251)  	WriteByte ((byte)length);  else if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 251)  	WriteByte ((byte)length);  else if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 251)  	WriteByte ((byte)length);  else if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 251)  	WriteByte ((byte)length);  else if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 251)  	WriteByte ((byte)length);  else if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 65536L) {  	WriteByte (252);  	WriteInteger (length' 2);  }  else if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: WriteByte (252);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: WriteInteger (length' 2);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: if (length < 16777216L) {  	WriteByte (253);  	WriteInteger (length' 3);  }  else {  	WriteByte (254);  	WriteInteger (length' 4);  }  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: WriteByte (253);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: WriteInteger (length' 3);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: WriteByte (254);  
Magic Number,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,WriteLength,The following statement contains a magic number: WriteInteger (length' 4);  
Magic Number,MySql.Data.MySqlClient,MySqlPool,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPool.cs,GetPooledConnection,The following statement contains a magic number: if (driver != null) {  	try {  		driver.ResetTimeout ((int)Settings.ConnectionTimeout * 1000);  	}  	catch (Exception) {  		driver.Close ();  		driver = null;  	}  }  
Magic Number,MySql.Data.MySqlClient,MySqlPool,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPool.cs,GetPooledConnection,The following statement contains a magic number: try {  	driver.ResetTimeout ((int)Settings.ConnectionTimeout * 1000);  }  catch (Exception) {  	driver.Close ();  	driver = null;  }  
Magic Number,MySql.Data.MySqlClient,MySqlPool,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPool.cs,GetPooledConnection,The following statement contains a magic number: driver.ResetTimeout ((int)Settings.ConnectionTimeout * 1000);  
Magic Number,MySql.Data.MySqlClient,MySqlTransactionScope,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPromotableTransaction.cs,Rollback,The following statement contains a magic number: lock (driver) {  	rollbackThreadId = Thread.CurrentThread.ManagedThreadId;  	while (connection.Reader != null) {  		// wait for reader to finish. Maybe we should not wait   		// forever and cancel it after some time?  		Thread.Sleep (100);  	}  	simpleTransaction.Rollback ();  	singlePhaseEnlistment.Aborted ();  	DriverTransactionManager.RemoveDriverInTransaction (baseTransaction);  	driver.CurrentTransaction = null;  	if (connection.State == ConnectionState.Closed)  		connection.CloseFully ();  	rollbackThreadId = 0;  }  
Magic Number,MySql.Data.MySqlClient,MySqlTransactionScope,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPromotableTransaction.cs,Rollback,The following statement contains a magic number: while (connection.Reader != null) {  	// wait for reader to finish. Maybe we should not wait   	// forever and cancel it after some time?  	Thread.Sleep (100);  }  
Magic Number,MySql.Data.MySqlClient,MySqlTransactionScope,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPromotableTransaction.cs,Rollback,The following statement contains a magic number: Thread.Sleep (100);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (packet.Buffer [0] == 0xff) {  	packet.ReadByte ();  	// read off the 0xff  	var code = packet.ReadInteger (2);  	var msg = String.Empty;  	if (packet.Version.isAtLeast (5' 5' 0))  		msg = packet.ReadString (Encoding.UTF8);  	else  		msg = packet.ReadString ();  	if (msg.StartsWith ("#"' StringComparison.Ordinal)) {  		msg.Substring (1' 5);  		/* state code */msg = msg.Substring (6);  	}  	throw new MySqlException (msg' code);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (packet.Buffer [0] == 0xff) {  	packet.ReadByte ();  	// read off the 0xff  	var code = packet.ReadInteger (2);  	var msg = String.Empty;  	if (packet.Version.isAtLeast (5' 5' 0))  		msg = packet.ReadString (Encoding.UTF8);  	else  		msg = packet.ReadString ();  	if (msg.StartsWith ("#"' StringComparison.Ordinal)) {  		msg.Substring (1' 5);  		/* state code */msg = msg.Substring (6);  	}  	throw new MySqlException (msg' code);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (packet.Buffer [0] == 0xff) {  	packet.ReadByte ();  	// read off the 0xff  	var code = packet.ReadInteger (2);  	var msg = String.Empty;  	if (packet.Version.isAtLeast (5' 5' 0))  		msg = packet.ReadString (Encoding.UTF8);  	else  		msg = packet.ReadString ();  	if (msg.StartsWith ("#"' StringComparison.Ordinal)) {  		msg.Substring (1' 5);  		/* state code */msg = msg.Substring (6);  	}  	throw new MySqlException (msg' code);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (packet.Buffer [0] == 0xff) {  	packet.ReadByte ();  	// read off the 0xff  	var code = packet.ReadInteger (2);  	var msg = String.Empty;  	if (packet.Version.isAtLeast (5' 5' 0))  		msg = packet.ReadString (Encoding.UTF8);  	else  		msg = packet.ReadString ();  	if (msg.StartsWith ("#"' StringComparison.Ordinal)) {  		msg.Substring (1' 5);  		/* state code */msg = msg.Substring (6);  	}  	throw new MySqlException (msg' code);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (packet.Buffer [0] == 0xff) {  	packet.ReadByte ();  	// read off the 0xff  	var code = packet.ReadInteger (2);  	var msg = String.Empty;  	if (packet.Version.isAtLeast (5' 5' 0))  		msg = packet.ReadString (Encoding.UTF8);  	else  		msg = packet.ReadString ();  	if (msg.StartsWith ("#"' StringComparison.Ordinal)) {  		msg.Substring (1' 5);  		/* state code */msg = msg.Substring (6);  	}  	throw new MySqlException (msg' code);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (packet.Version.isAtLeast (5' 5' 0))  	msg = packet.ReadString (Encoding.UTF8);  else  	msg = packet.ReadString ();  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (packet.Version.isAtLeast (5' 5' 0))  	msg = packet.ReadString (Encoding.UTF8);  else  	msg = packet.ReadString ();  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (msg.StartsWith ("#"' StringComparison.Ordinal)) {  	msg.Substring (1' 5);  	/* state code */msg = msg.Substring (6);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: if (msg.StartsWith ("#"' StringComparison.Ordinal)) {  	msg.Substring (1' 5);  	/* state code */msg = msg.Substring (6);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: msg.Substring (1' 5);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,ReadPacket,The following statement contains a magic number: msg = msg.Substring (6);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: try {  	packet.Length = 0;  	var offset = 0;  	while (true) {  		ReadFully (inStream' packetHeader' 0' 4);  		sequenceByte = (byte)(packetHeader [3] + 1);  		var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  		// make roo for the next block  		packet.Length += length;  		ReadFully (inStream' packet.Buffer' offset' length);  		offset += length;  		// if this block was < maxBlock then it's last one in a multipacket series  		if (length < maxBlockSize)  			break;  	}  	packet.Position = 0;  }  catch (IOException ioex) {  	throw new MySqlException (Resources.ReadFromStreamFailed' true' ioex);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: try {  	packet.Length = 0;  	var offset = 0;  	while (true) {  		ReadFully (inStream' packetHeader' 0' 4);  		sequenceByte = (byte)(packetHeader [3] + 1);  		var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  		// make roo for the next block  		packet.Length += length;  		ReadFully (inStream' packet.Buffer' offset' length);  		offset += length;  		// if this block was < maxBlock then it's last one in a multipacket series  		if (length < maxBlockSize)  			break;  	}  	packet.Position = 0;  }  catch (IOException ioex) {  	throw new MySqlException (Resources.ReadFromStreamFailed' true' ioex);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: try {  	packet.Length = 0;  	var offset = 0;  	while (true) {  		ReadFully (inStream' packetHeader' 0' 4);  		sequenceByte = (byte)(packetHeader [3] + 1);  		var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  		// make roo for the next block  		packet.Length += length;  		ReadFully (inStream' packet.Buffer' offset' length);  		offset += length;  		// if this block was < maxBlock then it's last one in a multipacket series  		if (length < maxBlockSize)  			break;  	}  	packet.Position = 0;  }  catch (IOException ioex) {  	throw new MySqlException (Resources.ReadFromStreamFailed' true' ioex);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: try {  	packet.Length = 0;  	var offset = 0;  	while (true) {  		ReadFully (inStream' packetHeader' 0' 4);  		sequenceByte = (byte)(packetHeader [3] + 1);  		var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  		// make roo for the next block  		packet.Length += length;  		ReadFully (inStream' packet.Buffer' offset' length);  		offset += length;  		// if this block was < maxBlock then it's last one in a multipacket series  		if (length < maxBlockSize)  			break;  	}  	packet.Position = 0;  }  catch (IOException ioex) {  	throw new MySqlException (Resources.ReadFromStreamFailed' true' ioex);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: try {  	packet.Length = 0;  	var offset = 0;  	while (true) {  		ReadFully (inStream' packetHeader' 0' 4);  		sequenceByte = (byte)(packetHeader [3] + 1);  		var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  		// make roo for the next block  		packet.Length += length;  		ReadFully (inStream' packet.Buffer' offset' length);  		offset += length;  		// if this block was < maxBlock then it's last one in a multipacket series  		if (length < maxBlockSize)  			break;  	}  	packet.Position = 0;  }  catch (IOException ioex) {  	throw new MySqlException (Resources.ReadFromStreamFailed' true' ioex);  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: while (true) {  	ReadFully (inStream' packetHeader' 0' 4);  	sequenceByte = (byte)(packetHeader [3] + 1);  	var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  	// make roo for the next block  	packet.Length += length;  	ReadFully (inStream' packet.Buffer' offset' length);  	offset += length;  	// if this block was < maxBlock then it's last one in a multipacket series  	if (length < maxBlockSize)  		break;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: while (true) {  	ReadFully (inStream' packetHeader' 0' 4);  	sequenceByte = (byte)(packetHeader [3] + 1);  	var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  	// make roo for the next block  	packet.Length += length;  	ReadFully (inStream' packet.Buffer' offset' length);  	offset += length;  	// if this block was < maxBlock then it's last one in a multipacket series  	if (length < maxBlockSize)  		break;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: while (true) {  	ReadFully (inStream' packetHeader' 0' 4);  	sequenceByte = (byte)(packetHeader [3] + 1);  	var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  	// make roo for the next block  	packet.Length += length;  	ReadFully (inStream' packet.Buffer' offset' length);  	offset += length;  	// if this block was < maxBlock then it's last one in a multipacket series  	if (length < maxBlockSize)  		break;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: while (true) {  	ReadFully (inStream' packetHeader' 0' 4);  	sequenceByte = (byte)(packetHeader [3] + 1);  	var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  	// make roo for the next block  	packet.Length += length;  	ReadFully (inStream' packet.Buffer' offset' length);  	offset += length;  	// if this block was < maxBlock then it's last one in a multipacket series  	if (length < maxBlockSize)  		break;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: while (true) {  	ReadFully (inStream' packetHeader' 0' 4);  	sequenceByte = (byte)(packetHeader [3] + 1);  	var length = (int)(packetHeader [0] + (packetHeader [1] << 8) + (packetHeader [2] << 16));  	// make roo for the next block  	packet.Length += length;  	ReadFully (inStream' packet.Buffer' offset' length);  	offset += length;  	// if this block was < maxBlock then it's last one in a multipacket series  	if (length < maxBlockSize)  		break;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: ReadFully (inStream' packetHeader' 0' 4);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,LoadPacket,The following statement contains a magic number: sequenceByte = (byte)(packetHeader [3] + 1);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: while (length > 0) {  	var lenToSend = length > maxBlockSize ? maxBlockSize : length;  	buffer [offset] = (byte)(lenToSend & 0xff);  	buffer [offset + 1] = (byte)((lenToSend >> 8) & 0xff);  	buffer [offset + 2] = (byte)((lenToSend >> 16) & 0xff);  	buffer [offset + 3] = sequenceByte++;  	outStream.Write (buffer' offset' lenToSend + 4);  	outStream.Flush ();  	length -= lenToSend;  	offset += lenToSend;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: while (length > 0) {  	var lenToSend = length > maxBlockSize ? maxBlockSize : length;  	buffer [offset] = (byte)(lenToSend & 0xff);  	buffer [offset + 1] = (byte)((lenToSend >> 8) & 0xff);  	buffer [offset + 2] = (byte)((lenToSend >> 16) & 0xff);  	buffer [offset + 3] = sequenceByte++;  	outStream.Write (buffer' offset' lenToSend + 4);  	outStream.Flush ();  	length -= lenToSend;  	offset += lenToSend;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: while (length > 0) {  	var lenToSend = length > maxBlockSize ? maxBlockSize : length;  	buffer [offset] = (byte)(lenToSend & 0xff);  	buffer [offset + 1] = (byte)((lenToSend >> 8) & 0xff);  	buffer [offset + 2] = (byte)((lenToSend >> 16) & 0xff);  	buffer [offset + 3] = sequenceByte++;  	outStream.Write (buffer' offset' lenToSend + 4);  	outStream.Flush ();  	length -= lenToSend;  	offset += lenToSend;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: while (length > 0) {  	var lenToSend = length > maxBlockSize ? maxBlockSize : length;  	buffer [offset] = (byte)(lenToSend & 0xff);  	buffer [offset + 1] = (byte)((lenToSend >> 8) & 0xff);  	buffer [offset + 2] = (byte)((lenToSend >> 16) & 0xff);  	buffer [offset + 3] = sequenceByte++;  	outStream.Write (buffer' offset' lenToSend + 4);  	outStream.Flush ();  	length -= lenToSend;  	offset += lenToSend;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: while (length > 0) {  	var lenToSend = length > maxBlockSize ? maxBlockSize : length;  	buffer [offset] = (byte)(lenToSend & 0xff);  	buffer [offset + 1] = (byte)((lenToSend >> 8) & 0xff);  	buffer [offset + 2] = (byte)((lenToSend >> 16) & 0xff);  	buffer [offset + 3] = sequenceByte++;  	outStream.Write (buffer' offset' lenToSend + 4);  	outStream.Flush ();  	length -= lenToSend;  	offset += lenToSend;  }  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: buffer [offset + 1] = (byte)((lenToSend >> 8) & 0xff);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: buffer [offset + 2] = (byte)((lenToSend >> 16) & 0xff);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: buffer [offset + 2] = (byte)((lenToSend >> 16) & 0xff);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: buffer [offset + 3] = sequenceByte++;  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendPacket,The following statement contains a magic number: outStream.Write (buffer' offset' lenToSend + 4);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendEntirePacketDirectly,The following statement contains a magic number: buffer [1] = (byte)((count >> 8) & 0xff);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendEntirePacketDirectly,The following statement contains a magic number: buffer [2] = (byte)((count >> 16) & 0xff);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendEntirePacketDirectly,The following statement contains a magic number: buffer [2] = (byte)((count >> 16) & 0xff);  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendEntirePacketDirectly,The following statement contains a magic number: buffer [3] = sequenceByte++;  
Magic Number,MySql.Data.MySqlClient,MySqlStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlStream.cs,SendEntirePacketDirectly,The following statement contains a magic number: outStream.Write (buffer' 0' count + 4);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ReadOk,The following statement contains a magic number: try {  	if (read)  		packet = stream.ReadPacket ();  	var marker = (byte)packet.ReadByte ();  	if (marker != 0) {  		throw new MySqlException ("Out of sync with server"' true' null);  	}  	packet.ReadFieldLength ();  	/* affected rows */packet.ReadFieldLength ();  	/* last insert id */if (packet.HasMoreData) {  		serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  		packet.ReadInteger (2);  		/* warning count */if (packet.HasMoreData) {  			packet.ReadLenString ();  			/* message */}  	}  }  catch (MySqlException ex) {  	HandleException (ex);  	throw;  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ReadOk,The following statement contains a magic number: try {  	if (read)  		packet = stream.ReadPacket ();  	var marker = (byte)packet.ReadByte ();  	if (marker != 0) {  		throw new MySqlException ("Out of sync with server"' true' null);  	}  	packet.ReadFieldLength ();  	/* affected rows */packet.ReadFieldLength ();  	/* last insert id */if (packet.HasMoreData) {  		serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  		packet.ReadInteger (2);  		/* warning count */if (packet.HasMoreData) {  			packet.ReadLenString ();  			/* message */}  	}  }  catch (MySqlException ex) {  	HandleException (ex);  	throw;  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ReadOk,The following statement contains a magic number: if (packet.HasMoreData) {  	serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  	packet.ReadInteger (2);  	/* warning count */if (packet.HasMoreData) {  		packet.ReadLenString ();  		/* message */}  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ReadOk,The following statement contains a magic number: if (packet.HasMoreData) {  	serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  	packet.ReadInteger (2);  	/* warning count */if (packet.HasMoreData) {  		packet.ReadLenString ();  		/* message */}  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ReadOk,The following statement contains a magic number: serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ReadOk,The following statement contains a magic number: packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: stream.ResetTimeout ((int)Settings.ConnectionTimeout * 1000);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: if (!version.isAtLeast (5' 0' 0))  	throw new NotSupportedException (Resources.ServerTooOld);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: threadId = packet.ReadInteger (4);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: maxSinglePacket = (256 * 256 * 256) - 1;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: maxSinglePacket = (256 * 256 * 256) - 1;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: maxSinglePacket = (256 * 256 * 256) - 1;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: if (packet.HasMoreData)  	serverCaps = (ClientFlags)packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: serverCaps = (ClientFlags)packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: serverCaps |= (ClientFlags)(serverCapsHigh << 16);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: packet.Position += 11;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: packet.WriteInteger ((int)connectionFlags' 4);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: if ((serverCaps & ClientFlags.SSL) == 0) {  	if ((Settings.SslMode != MySqlSslMode.None) && (Settings.SslMode != MySqlSslMode.Preferred)) {  		// Client requires SSL connections.  		var message = String.Format (Resources.NoServerSSLSupport' Settings.Server);  		throw new MySqlException (message);  	}  }  else if (Settings.SslMode != MySqlSslMode.None) {  	stream.SendPacket (packet);  	StartSSL ();  	packet.Clear ();  	packet.WriteInteger ((int)connectionFlags' 4);  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: if (Settings.SslMode != MySqlSslMode.None) {  	stream.SendPacket (packet);  	StartSSL ();  	packet.Clear ();  	packet.WriteInteger ((int)connectionFlags' 4);  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: packet.WriteInteger ((int)connectionFlags' 4);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: packet.WriteInteger (maxSinglePacket' 4);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: packet.WriteByte (8);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,Open,The following statement contains a magic number: packet.Write (new byte[23]);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetClientCertificates,The following statement contains a magic number: if (Settings.CertificateFile != null) {  	if (!Version.isAtLeast (5' 1' 0))  		throw new MySqlException (Resources.FileBasedCertificateNotSupported);  	var clientCert = new X509Certificate2 (Settings.CertificateFile' Settings.CertificatePassword);  	certs.Add (clientCert);  	return certs;  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetClientCertificates,The following statement contains a magic number: if (!Version.isAtLeast (5' 1' 0))  	throw new MySqlException (Resources.FileBasedCertificateNotSupported);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,StartSSL,The following statement contains a magic number: stream.SequenceByte = 2;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendQuery,The following statement contains a magic number: queryPacket.Buffer [4] = (byte)DBCmd.QUERY;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetResult,The following statement contains a magic number: if (-1 == fieldCount) {  	var filename = packet.ReadString ();  	SendFileToServer (filename);  	return GetResult (ref affectedRow' ref insertedId);  }  else if (fieldCount == 0) {  	// the code to read last packet will set these server status vars   	// again if necessary.  	serverStatus &= ~(ServerStatusFlags.AnotherQuery | ServerStatusFlags.MoreResults);  	affectedRow = (int)packet.ReadFieldLength ();  	insertedId = (int)packet.ReadFieldLength ();  	serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  	warnings += packet.ReadInteger (2);  	if (packet.HasMoreData) {  		packet.ReadLenString ();  		//TODO: server message  	}  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetResult,The following statement contains a magic number: if (-1 == fieldCount) {  	var filename = packet.ReadString ();  	SendFileToServer (filename);  	return GetResult (ref affectedRow' ref insertedId);  }  else if (fieldCount == 0) {  	// the code to read last packet will set these server status vars   	// again if necessary.  	serverStatus &= ~(ServerStatusFlags.AnotherQuery | ServerStatusFlags.MoreResults);  	affectedRow = (int)packet.ReadFieldLength ();  	insertedId = (int)packet.ReadFieldLength ();  	serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  	warnings += packet.ReadInteger (2);  	if (packet.HasMoreData) {  		packet.ReadLenString ();  		//TODO: server message  	}  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetResult,The following statement contains a magic number: if (fieldCount == 0) {  	// the code to read last packet will set these server status vars   	// again if necessary.  	serverStatus &= ~(ServerStatusFlags.AnotherQuery | ServerStatusFlags.MoreResults);  	affectedRow = (int)packet.ReadFieldLength ();  	insertedId = (int)packet.ReadFieldLength ();  	serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  	warnings += packet.ReadInteger (2);  	if (packet.HasMoreData) {  		packet.ReadLenString ();  		//TODO: server message  	}  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetResult,The following statement contains a magic number: if (fieldCount == 0) {  	// the code to read last packet will set these server status vars   	// again if necessary.  	serverStatus &= ~(ServerStatusFlags.AnotherQuery | ServerStatusFlags.MoreResults);  	affectedRow = (int)packet.ReadFieldLength ();  	insertedId = (int)packet.ReadFieldLength ();  	serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  	warnings += packet.ReadInteger (2);  	if (packet.HasMoreData) {  		packet.ReadLenString ();  		//TODO: server message  	}  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetResult,The following statement contains a magic number: serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetResult,The following statement contains a magic number: warnings += packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: try {  	using (var fs = new FileStream (filename' FileMode.Open' FileAccess.Read)) {  		len = fs.Length;  		while (len > 0) {  			var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  			stream.SendEntirePacketDirectly (buffer' count);  			len -= count;  		}  		stream.SendEntirePacketDirectly (buffer' 0);  	}  }  catch (Exception ex) {  	throw new MySqlException ("Error during LOAD DATA LOCAL INFILE"' ex);  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: try {  	using (var fs = new FileStream (filename' FileMode.Open' FileAccess.Read)) {  		len = fs.Length;  		while (len > 0) {  			var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  			stream.SendEntirePacketDirectly (buffer' count);  			len -= count;  		}  		stream.SendEntirePacketDirectly (buffer' 0);  	}  }  catch (Exception ex) {  	throw new MySqlException ("Error during LOAD DATA LOCAL INFILE"' ex);  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: try {  	using (var fs = new FileStream (filename' FileMode.Open' FileAccess.Read)) {  		len = fs.Length;  		while (len > 0) {  			var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  			stream.SendEntirePacketDirectly (buffer' count);  			len -= count;  		}  		stream.SendEntirePacketDirectly (buffer' 0);  	}  }  catch (Exception ex) {  	throw new MySqlException ("Error during LOAD DATA LOCAL INFILE"' ex);  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: using (var fs = new FileStream (filename' FileMode.Open' FileAccess.Read)) {  	len = fs.Length;  	while (len > 0) {  		var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  		stream.SendEntirePacketDirectly (buffer' count);  		len -= count;  	}  	stream.SendEntirePacketDirectly (buffer' 0);  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: using (var fs = new FileStream (filename' FileMode.Open' FileAccess.Read)) {  	len = fs.Length;  	while (len > 0) {  		var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  		stream.SendEntirePacketDirectly (buffer' count);  		len -= count;  	}  	stream.SendEntirePacketDirectly (buffer' 0);  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: using (var fs = new FileStream (filename' FileMode.Open' FileAccess.Read)) {  	len = fs.Length;  	while (len > 0) {  		var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  		stream.SendEntirePacketDirectly (buffer' count);  		len -= count;  	}  	stream.SendEntirePacketDirectly (buffer' 0);  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: while (len > 0) {  	var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  	stream.SendEntirePacketDirectly (buffer' count);  	len -= count;  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: while (len > 0) {  	var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  	stream.SendEntirePacketDirectly (buffer' count);  	len -= count;  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,SendFileToServer,The following statement contains a magic number: while (len > 0) {  	var count = fs.Read (buffer' 4' (int)(len > 8192 ? 8192 : len));  	stream.SendEntirePacketDirectly (buffer' count);  	len -= count;  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ReadColumnValue,The following statement contains a magic number: if (nullMap != null)  	isNull = nullMap [index + 2];  else {  	length = packet.ReadFieldLength ();  	isNull = length == -1;  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ReadColumnValue,The following statement contains a magic number: isNull = nullMap [index + 2];  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetColumnData,The following statement contains a magic number: field.CharacterSetIndex = packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetColumnData,The following statement contains a magic number: field.ColumnLength = packet.ReadInteger (4);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetColumnData,The following statement contains a magic number: if ((connectionFlags & ClientFlags.LONG_FLAG) != 0)  	colFlags = (ColumnFlags)packet.ReadInteger (2);  else  	colFlags = (ColumnFlags)packet.ReadByte ();  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetColumnData,The following statement contains a magic number: colFlags = (ColumnFlags)packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetColumnData,The following statement contains a magic number: if (packet.HasMoreData) {  	packet.ReadInteger (2);  	// reserved  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetColumnData,The following statement contains a magic number: packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetColumnData,The following statement contains a magic number: if (type == MySqlDbType.Decimal || type == MySqlDbType.NewDecimal) {  	field.Precision = (byte)(field.ColumnLength - 2);  	if ((colFlags & ColumnFlags.UNSIGNED) != 0)  		field.Precision++;  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,GetColumnData,The following statement contains a magic number: field.Precision = (byte)(field.ColumnLength - 2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,ExecuteStatement,The following statement contains a magic number: packetToExecute.Buffer [4] = (byte)DBCmd.EXECUTE;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,CheckEOF,The following statement contains a magic number: if (packet.HasMoreData) {  	warnings += packet.ReadInteger (2);  	serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  	// if we are at the end of this cursor based resultset' then we remove  	// the last row sent status flag so our next fetch doesn't abort early  	// and we remove this command result from our list of active CommandResult objects.  	//                if ((serverStatus & ServerStatusFlags.LastRowSent) != 0)  	//              {  	//                serverStatus &= ~ServerStatusFlags.LastRowSent;  	//              commandResults.Remove(lastCommandResult);  	//        }  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,CheckEOF,The following statement contains a magic number: if (packet.HasMoreData) {  	warnings += packet.ReadInteger (2);  	serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  	// if we are at the end of this cursor based resultset' then we remove  	// the last row sent status flag so our next fetch doesn't abort early  	// and we remove this command result from our list of active CommandResult objects.  	//                if ((serverStatus & ServerStatusFlags.LastRowSent) != 0)  	//              {  	//                serverStatus &= ~ServerStatusFlags.LastRowSent;  	//              commandResults.Remove(lastCommandResult);  	//        }  }  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,CheckEOF,The following statement contains a magic number: warnings += packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,CheckEOF,The following statement contains a magic number: serverStatus = (ServerStatusFlags)packet.ReadInteger (2);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,PrepareStatement,The following statement contains a magic number: packet.Length = sql.Length * 4 + 5;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,PrepareStatement,The following statement contains a magic number: packet.Length = sql.Length * 4 + 5;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,PrepareStatement,The following statement contains a magic number: packet.Position = len + 5;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,PrepareStatement,The following statement contains a magic number: buffer [4] = (byte)DBCmd.PREPARE;  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,PrepareStatement,The following statement contains a magic number: packet.ReadInteger (3);  
Magic Number,MySql.Data.MySqlClient,NativeDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\NativeDriver.cs,CloseStatement,The following statement contains a magic number: packet.WriteInteger ((long)statementId' 4);  
Magic Number,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,EstimatedSize,The following statement contains a magic number: if (Value == null || Value == DBNull.Value)  	return 4;  
Magic Number,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,EstimatedSize,The following statement contains a magic number: return 4;  
Magic Number,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,EstimatedSize,The following statement contains a magic number: if (Value is string)  	return (Value as string).Length * 4;  
Magic Number,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,EstimatedSize,The following statement contains a magic number: return (Value as string).Length * 4;  
Magic Number,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,EstimatedSize,The following statement contains a magic number: if (Value is decimal || Value is float)  	return 64;  
Magic Number,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,EstimatedSize,The following statement contains a magic number: return 64;  
Magic Number,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,EstimatedSize,The following statement contains a magic number: return 32;  
Magic Number,MySql.Data.MySqlClient,PreparableStatement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\PreparableStatement.cs,Prepare,The following statement contains a magic number: if (paramList != null && paramList.Length > 0) {  	nullMap = new BitArray (paramList.Length);  	numNullBytes = (nullMap.Count + 7) / 8;  }  
Magic Number,MySql.Data.MySqlClient,PreparableStatement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\PreparableStatement.cs,Prepare,The following statement contains a magic number: if (paramList != null && paramList.Length > 0) {  	nullMap = new BitArray (paramList.Length);  	numNullBytes = (nullMap.Count + 7) / 8;  }  
Magic Number,MySql.Data.MySqlClient,PreparableStatement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\PreparableStatement.cs,Prepare,The following statement contains a magic number: numNullBytes = (nullMap.Count + 7) / 8;  
Magic Number,MySql.Data.MySqlClient,PreparableStatement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\PreparableStatement.cs,Prepare,The following statement contains a magic number: numNullBytes = (nullMap.Count + 7) / 8;  
Magic Number,MySql.Data.MySqlClient,PreparableStatement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\PreparableStatement.cs,Prepare,The following statement contains a magic number: packet.WriteInteger (statementId' 4);  
Magic Number,MySql.Data.MySqlClient,PreparableStatement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\PreparableStatement.cs,Prepare,The following statement contains a magic number: packet.WriteInteger (1' 4);  
Magic Number,MySql.Data.MySqlClient,PreparableStatement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\PreparableStatement.cs,Prepare,The following statement contains a magic number: foreach (var p in parametersToSend)  	packet.WriteInteger (p.GetPSType ()' 2);  
Magic Number,MySql.Data.MySqlClient,PreparableStatement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\PreparableStatement.cs,Prepare,The following statement contains a magic number: packet.WriteInteger (p.GetPSType ()' 2);  
Magic Number,MySql.Data.MySqlClient,ProcedureCache,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ProcedureCache.cs,GetProcData,The following statement contains a magic number: restrictions [2] = name;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetTables,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 2)  	dbRestriction [0] = restrictions [1];  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4) {  	columnName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4) {  	columnName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4) {  	columnName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetColumns,The following statement contains a magic number: columnName = restrictions [3];  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetColumns,The following statement contains a magic number: restrictions [3] = null;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var colName = reader.GetString (0);  		if (columnRestriction != null && colName != columnRestriction)  			continue;  		var row = dt.NewRow ();  		row ["TABLE_CATALOG"] = DBNull.Value;  		row ["TABLE_SCHEMA"] = schema;  		row ["TABLE_NAME"] = tableName;  		row ["COLUMN_NAME"] = colName;  		row ["ORDINAL_POSITION"] = pos++;  		row ["COLUMN_DEFAULT"] = reader.GetValue (5);  		row ["IS_NULLABLE"] = reader.GetString (3);  		row ["DATA_TYPE"] = reader.GetString (1);  		row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  		row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  		row ["NUMERIC_PRECISION"] = DBNull.Value;  		row ["NUMERIC_SCALE"] = DBNull.Value;  		row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  		row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  		row ["COLUMN_TYPE"] = reader.GetString (1);  		row ["COLUMN_KEY"] = reader.GetString (4);  		row ["EXTRA"] = reader.GetString (6);  		row ["PRIVILEGES"] = reader.GetString (7);  		row ["COLUMN_COMMENT"] = reader.GetString (8);  		ParseColumnRow (row);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var colName = reader.GetString (0);  		if (columnRestriction != null && colName != columnRestriction)  			continue;  		var row = dt.NewRow ();  		row ["TABLE_CATALOG"] = DBNull.Value;  		row ["TABLE_SCHEMA"] = schema;  		row ["TABLE_NAME"] = tableName;  		row ["COLUMN_NAME"] = colName;  		row ["ORDINAL_POSITION"] = pos++;  		row ["COLUMN_DEFAULT"] = reader.GetValue (5);  		row ["IS_NULLABLE"] = reader.GetString (3);  		row ["DATA_TYPE"] = reader.GetString (1);  		row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  		row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  		row ["NUMERIC_PRECISION"] = DBNull.Value;  		row ["NUMERIC_SCALE"] = DBNull.Value;  		row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  		row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  		row ["COLUMN_TYPE"] = reader.GetString (1);  		row ["COLUMN_KEY"] = reader.GetString (4);  		row ["EXTRA"] = reader.GetString (6);  		row ["PRIVILEGES"] = reader.GetString (7);  		row ["COLUMN_COMMENT"] = reader.GetString (8);  		ParseColumnRow (row);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var colName = reader.GetString (0);  		if (columnRestriction != null && colName != columnRestriction)  			continue;  		var row = dt.NewRow ();  		row ["TABLE_CATALOG"] = DBNull.Value;  		row ["TABLE_SCHEMA"] = schema;  		row ["TABLE_NAME"] = tableName;  		row ["COLUMN_NAME"] = colName;  		row ["ORDINAL_POSITION"] = pos++;  		row ["COLUMN_DEFAULT"] = reader.GetValue (5);  		row ["IS_NULLABLE"] = reader.GetString (3);  		row ["DATA_TYPE"] = reader.GetString (1);  		row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  		row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  		row ["NUMERIC_PRECISION"] = DBNull.Value;  		row ["NUMERIC_SCALE"] = DBNull.Value;  		row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  		row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  		row ["COLUMN_TYPE"] = reader.GetString (1);  		row ["COLUMN_KEY"] = reader.GetString (4);  		row ["EXTRA"] = reader.GetString (6);  		row ["PRIVILEGES"] = reader.GetString (7);  		row ["COLUMN_COMMENT"] = reader.GetString (8);  		ParseColumnRow (row);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var colName = reader.GetString (0);  		if (columnRestriction != null && colName != columnRestriction)  			continue;  		var row = dt.NewRow ();  		row ["TABLE_CATALOG"] = DBNull.Value;  		row ["TABLE_SCHEMA"] = schema;  		row ["TABLE_NAME"] = tableName;  		row ["COLUMN_NAME"] = colName;  		row ["ORDINAL_POSITION"] = pos++;  		row ["COLUMN_DEFAULT"] = reader.GetValue (5);  		row ["IS_NULLABLE"] = reader.GetString (3);  		row ["DATA_TYPE"] = reader.GetString (1);  		row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  		row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  		row ["NUMERIC_PRECISION"] = DBNull.Value;  		row ["NUMERIC_SCALE"] = DBNull.Value;  		row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  		row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  		row ["COLUMN_TYPE"] = reader.GetString (1);  		row ["COLUMN_KEY"] = reader.GetString (4);  		row ["EXTRA"] = reader.GetString (6);  		row ["PRIVILEGES"] = reader.GetString (7);  		row ["COLUMN_COMMENT"] = reader.GetString (8);  		ParseColumnRow (row);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var colName = reader.GetString (0);  		if (columnRestriction != null && colName != columnRestriction)  			continue;  		var row = dt.NewRow ();  		row ["TABLE_CATALOG"] = DBNull.Value;  		row ["TABLE_SCHEMA"] = schema;  		row ["TABLE_NAME"] = tableName;  		row ["COLUMN_NAME"] = colName;  		row ["ORDINAL_POSITION"] = pos++;  		row ["COLUMN_DEFAULT"] = reader.GetValue (5);  		row ["IS_NULLABLE"] = reader.GetString (3);  		row ["DATA_TYPE"] = reader.GetString (1);  		row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  		row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  		row ["NUMERIC_PRECISION"] = DBNull.Value;  		row ["NUMERIC_SCALE"] = DBNull.Value;  		row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  		row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  		row ["COLUMN_TYPE"] = reader.GetString (1);  		row ["COLUMN_KEY"] = reader.GetString (4);  		row ["EXTRA"] = reader.GetString (6);  		row ["PRIVILEGES"] = reader.GetString (7);  		row ["COLUMN_COMMENT"] = reader.GetString (8);  		ParseColumnRow (row);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var colName = reader.GetString (0);  		if (columnRestriction != null && colName != columnRestriction)  			continue;  		var row = dt.NewRow ();  		row ["TABLE_CATALOG"] = DBNull.Value;  		row ["TABLE_SCHEMA"] = schema;  		row ["TABLE_NAME"] = tableName;  		row ["COLUMN_NAME"] = colName;  		row ["ORDINAL_POSITION"] = pos++;  		row ["COLUMN_DEFAULT"] = reader.GetValue (5);  		row ["IS_NULLABLE"] = reader.GetString (3);  		row ["DATA_TYPE"] = reader.GetString (1);  		row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  		row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  		row ["NUMERIC_PRECISION"] = DBNull.Value;  		row ["NUMERIC_SCALE"] = DBNull.Value;  		row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  		row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  		row ["COLUMN_TYPE"] = reader.GetString (1);  		row ["COLUMN_KEY"] = reader.GetString (4);  		row ["EXTRA"] = reader.GetString (6);  		row ["PRIVILEGES"] = reader.GetString (7);  		row ["COLUMN_COMMENT"] = reader.GetString (8);  		ParseColumnRow (row);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var colName = reader.GetString (0);  		if (columnRestriction != null && colName != columnRestriction)  			continue;  		var row = dt.NewRow ();  		row ["TABLE_CATALOG"] = DBNull.Value;  		row ["TABLE_SCHEMA"] = schema;  		row ["TABLE_NAME"] = tableName;  		row ["COLUMN_NAME"] = colName;  		row ["ORDINAL_POSITION"] = pos++;  		row ["COLUMN_DEFAULT"] = reader.GetValue (5);  		row ["IS_NULLABLE"] = reader.GetString (3);  		row ["DATA_TYPE"] = reader.GetString (1);  		row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  		row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  		row ["NUMERIC_PRECISION"] = DBNull.Value;  		row ["NUMERIC_SCALE"] = DBNull.Value;  		row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  		row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  		row ["COLUMN_TYPE"] = reader.GetString (1);  		row ["COLUMN_KEY"] = reader.GetString (4);  		row ["EXTRA"] = reader.GetString (6);  		row ["PRIVILEGES"] = reader.GetString (7);  		row ["COLUMN_COMMENT"] = reader.GetString (8);  		ParseColumnRow (row);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: while (reader.Read ()) {  	var colName = reader.GetString (0);  	if (columnRestriction != null && colName != columnRestriction)  		continue;  	var row = dt.NewRow ();  	row ["TABLE_CATALOG"] = DBNull.Value;  	row ["TABLE_SCHEMA"] = schema;  	row ["TABLE_NAME"] = tableName;  	row ["COLUMN_NAME"] = colName;  	row ["ORDINAL_POSITION"] = pos++;  	row ["COLUMN_DEFAULT"] = reader.GetValue (5);  	row ["IS_NULLABLE"] = reader.GetString (3);  	row ["DATA_TYPE"] = reader.GetString (1);  	row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  	row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  	row ["NUMERIC_PRECISION"] = DBNull.Value;  	row ["NUMERIC_SCALE"] = DBNull.Value;  	row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  	row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  	row ["COLUMN_TYPE"] = reader.GetString (1);  	row ["COLUMN_KEY"] = reader.GetString (4);  	row ["EXTRA"] = reader.GetString (6);  	row ["PRIVILEGES"] = reader.GetString (7);  	row ["COLUMN_COMMENT"] = reader.GetString (8);  	ParseColumnRow (row);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: while (reader.Read ()) {  	var colName = reader.GetString (0);  	if (columnRestriction != null && colName != columnRestriction)  		continue;  	var row = dt.NewRow ();  	row ["TABLE_CATALOG"] = DBNull.Value;  	row ["TABLE_SCHEMA"] = schema;  	row ["TABLE_NAME"] = tableName;  	row ["COLUMN_NAME"] = colName;  	row ["ORDINAL_POSITION"] = pos++;  	row ["COLUMN_DEFAULT"] = reader.GetValue (5);  	row ["IS_NULLABLE"] = reader.GetString (3);  	row ["DATA_TYPE"] = reader.GetString (1);  	row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  	row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  	row ["NUMERIC_PRECISION"] = DBNull.Value;  	row ["NUMERIC_SCALE"] = DBNull.Value;  	row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  	row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  	row ["COLUMN_TYPE"] = reader.GetString (1);  	row ["COLUMN_KEY"] = reader.GetString (4);  	row ["EXTRA"] = reader.GetString (6);  	row ["PRIVILEGES"] = reader.GetString (7);  	row ["COLUMN_COMMENT"] = reader.GetString (8);  	ParseColumnRow (row);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: while (reader.Read ()) {  	var colName = reader.GetString (0);  	if (columnRestriction != null && colName != columnRestriction)  		continue;  	var row = dt.NewRow ();  	row ["TABLE_CATALOG"] = DBNull.Value;  	row ["TABLE_SCHEMA"] = schema;  	row ["TABLE_NAME"] = tableName;  	row ["COLUMN_NAME"] = colName;  	row ["ORDINAL_POSITION"] = pos++;  	row ["COLUMN_DEFAULT"] = reader.GetValue (5);  	row ["IS_NULLABLE"] = reader.GetString (3);  	row ["DATA_TYPE"] = reader.GetString (1);  	row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  	row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  	row ["NUMERIC_PRECISION"] = DBNull.Value;  	row ["NUMERIC_SCALE"] = DBNull.Value;  	row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  	row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  	row ["COLUMN_TYPE"] = reader.GetString (1);  	row ["COLUMN_KEY"] = reader.GetString (4);  	row ["EXTRA"] = reader.GetString (6);  	row ["PRIVILEGES"] = reader.GetString (7);  	row ["COLUMN_COMMENT"] = reader.GetString (8);  	ParseColumnRow (row);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: while (reader.Read ()) {  	var colName = reader.GetString (0);  	if (columnRestriction != null && colName != columnRestriction)  		continue;  	var row = dt.NewRow ();  	row ["TABLE_CATALOG"] = DBNull.Value;  	row ["TABLE_SCHEMA"] = schema;  	row ["TABLE_NAME"] = tableName;  	row ["COLUMN_NAME"] = colName;  	row ["ORDINAL_POSITION"] = pos++;  	row ["COLUMN_DEFAULT"] = reader.GetValue (5);  	row ["IS_NULLABLE"] = reader.GetString (3);  	row ["DATA_TYPE"] = reader.GetString (1);  	row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  	row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  	row ["NUMERIC_PRECISION"] = DBNull.Value;  	row ["NUMERIC_SCALE"] = DBNull.Value;  	row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  	row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  	row ["COLUMN_TYPE"] = reader.GetString (1);  	row ["COLUMN_KEY"] = reader.GetString (4);  	row ["EXTRA"] = reader.GetString (6);  	row ["PRIVILEGES"] = reader.GetString (7);  	row ["COLUMN_COMMENT"] = reader.GetString (8);  	ParseColumnRow (row);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: while (reader.Read ()) {  	var colName = reader.GetString (0);  	if (columnRestriction != null && colName != columnRestriction)  		continue;  	var row = dt.NewRow ();  	row ["TABLE_CATALOG"] = DBNull.Value;  	row ["TABLE_SCHEMA"] = schema;  	row ["TABLE_NAME"] = tableName;  	row ["COLUMN_NAME"] = colName;  	row ["ORDINAL_POSITION"] = pos++;  	row ["COLUMN_DEFAULT"] = reader.GetValue (5);  	row ["IS_NULLABLE"] = reader.GetString (3);  	row ["DATA_TYPE"] = reader.GetString (1);  	row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  	row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  	row ["NUMERIC_PRECISION"] = DBNull.Value;  	row ["NUMERIC_SCALE"] = DBNull.Value;  	row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  	row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  	row ["COLUMN_TYPE"] = reader.GetString (1);  	row ["COLUMN_KEY"] = reader.GetString (4);  	row ["EXTRA"] = reader.GetString (6);  	row ["PRIVILEGES"] = reader.GetString (7);  	row ["COLUMN_COMMENT"] = reader.GetString (8);  	ParseColumnRow (row);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: while (reader.Read ()) {  	var colName = reader.GetString (0);  	if (columnRestriction != null && colName != columnRestriction)  		continue;  	var row = dt.NewRow ();  	row ["TABLE_CATALOG"] = DBNull.Value;  	row ["TABLE_SCHEMA"] = schema;  	row ["TABLE_NAME"] = tableName;  	row ["COLUMN_NAME"] = colName;  	row ["ORDINAL_POSITION"] = pos++;  	row ["COLUMN_DEFAULT"] = reader.GetValue (5);  	row ["IS_NULLABLE"] = reader.GetString (3);  	row ["DATA_TYPE"] = reader.GetString (1);  	row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  	row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  	row ["NUMERIC_PRECISION"] = DBNull.Value;  	row ["NUMERIC_SCALE"] = DBNull.Value;  	row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  	row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  	row ["COLUMN_TYPE"] = reader.GetString (1);  	row ["COLUMN_KEY"] = reader.GetString (4);  	row ["EXTRA"] = reader.GetString (6);  	row ["PRIVILEGES"] = reader.GetString (7);  	row ["COLUMN_COMMENT"] = reader.GetString (8);  	ParseColumnRow (row);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: while (reader.Read ()) {  	var colName = reader.GetString (0);  	if (columnRestriction != null && colName != columnRestriction)  		continue;  	var row = dt.NewRow ();  	row ["TABLE_CATALOG"] = DBNull.Value;  	row ["TABLE_SCHEMA"] = schema;  	row ["TABLE_NAME"] = tableName;  	row ["COLUMN_NAME"] = colName;  	row ["ORDINAL_POSITION"] = pos++;  	row ["COLUMN_DEFAULT"] = reader.GetValue (5);  	row ["IS_NULLABLE"] = reader.GetString (3);  	row ["DATA_TYPE"] = reader.GetString (1);  	row ["CHARACTER_MAXIMUM_LENGTH"] = DBNull.Value;  	row ["CHARACTER_OCTET_LENGTH"] = DBNull.Value;  	row ["NUMERIC_PRECISION"] = DBNull.Value;  	row ["NUMERIC_SCALE"] = DBNull.Value;  	row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  	row ["COLLATION_NAME"] = row ["CHARACTER_SET_NAME"];  	row ["COLUMN_TYPE"] = reader.GetString (1);  	row ["COLUMN_KEY"] = reader.GetString (4);  	row ["EXTRA"] = reader.GetString (6);  	row ["PRIVILEGES"] = reader.GetString (7);  	row ["COLUMN_COMMENT"] = reader.GetString (8);  	ParseColumnRow (row);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: row ["COLUMN_DEFAULT"] = reader.GetValue (5);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: row ["IS_NULLABLE"] = reader.GetString (3);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: row ["CHARACTER_SET_NAME"] = reader.GetValue (2);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: row ["COLUMN_KEY"] = reader.GetString (4);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: row ["EXTRA"] = reader.GetString (6);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: row ["PRIVILEGES"] = reader.GetString (7);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,LoadTableColumns,The following statement contains a magic number: row ["COLUMN_COMMENT"] = reader.GetString (8);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,ParseColumnRow,The following statement contains a magic number: if (lowerType == "char" || lowerType == "varchar")  	row ["CHARACTER_MAXIMUM_LENGTH"] = dataLen;  else if (lowerType == "real" || lowerType == "decimal") {  	var lenparts = dataLen.Split (new char[] {  		'''  	});  	row ["NUMERIC_PRECISION"] = lenparts [0];  	if (lenparts.Length == 2)  		row ["NUMERIC_SCALE"] = lenparts [1];  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,ParseColumnRow,The following statement contains a magic number: if (lowerType == "real" || lowerType == "decimal") {  	var lenparts = dataLen.Split (new char[] {  		'''  	});  	row ["NUMERIC_PRECISION"] = lenparts [0];  	if (lenparts.Length == 2)  		row ["NUMERIC_SCALE"] = lenparts [1];  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,ParseColumnRow,The following statement contains a magic number: if (lenparts.Length == 2)  	row ["NUMERIC_SCALE"] = lenparts [1];  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: tableRestrictions [3] = "BASE TABLE";  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' MySqlHelper.DoubleQuoteString ((string)table ["TABLE_SCHEMA"])' MySqlHelper.DoubleQuoteString ((string)table ["TABLE_NAME"]));  	var da = new MySqlDataAdapter (sql' connection);  	var indexes = new DataTable ();  	da.Fill (indexes);  	foreach (DataRow index in indexes.Rows) {  		var seq_index = (long)index ["SEQ_IN_INDEX"];  		if (seq_index != 1)  			continue;  		if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  			continue;  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = index ["KEY_NAME"];  		row ["TABLE_NAME"] = index ["TABLE"];  		row ["UNIQUE"] = (long)index ["NON_UNIQUE"] == 0;  		row ["PRIMARY"] = index ["KEY_NAME"].Equals ("PRIMARY");  		row ["TYPE"] = index ["INDEX_TYPE"];  		row ["COMMENT"] = index ["COMMENT"];  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' MySqlHelper.DoubleQuoteString ((string)table ["TABLE_SCHEMA"])' MySqlHelper.DoubleQuoteString ((string)table ["TABLE_NAME"]));  	var da = new MySqlDataAdapter (sql' connection);  	var indexes = new DataTable ();  	da.Fill (indexes);  	foreach (DataRow index in indexes.Rows) {  		var seq_index = (long)index ["SEQ_IN_INDEX"];  		if (seq_index != 1)  			continue;  		if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  			continue;  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = index ["KEY_NAME"];  		row ["TABLE_NAME"] = index ["TABLE"];  		row ["UNIQUE"] = (long)index ["NON_UNIQUE"] == 0;  		row ["PRIMARY"] = index ["KEY_NAME"].Equals ("PRIMARY");  		row ["TYPE"] = index ["INDEX_TYPE"];  		row ["COMMENT"] = index ["COMMENT"];  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' MySqlHelper.DoubleQuoteString ((string)table ["TABLE_SCHEMA"])' MySqlHelper.DoubleQuoteString ((string)table ["TABLE_NAME"]));  	var da = new MySqlDataAdapter (sql' connection);  	var indexes = new DataTable ();  	da.Fill (indexes);  	foreach (DataRow index in indexes.Rows) {  		var seq_index = (long)index ["SEQ_IN_INDEX"];  		if (seq_index != 1)  			continue;  		if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  			continue;  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = index ["KEY_NAME"];  		row ["TABLE_NAME"] = index ["TABLE"];  		row ["UNIQUE"] = (long)index ["NON_UNIQUE"] == 0;  		row ["PRIMARY"] = index ["KEY_NAME"].Equals ("PRIMARY");  		row ["TYPE"] = index ["INDEX_TYPE"];  		row ["COMMENT"] = index ["COMMENT"];  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: foreach (DataRow index in indexes.Rows) {  	var seq_index = (long)index ["SEQ_IN_INDEX"];  	if (seq_index != 1)  		continue;  	if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  		continue;  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = index ["KEY_NAME"];  	row ["TABLE_NAME"] = index ["TABLE"];  	row ["UNIQUE"] = (long)index ["NON_UNIQUE"] == 0;  	row ["PRIMARY"] = index ["KEY_NAME"].Equals ("PRIMARY");  	row ["TYPE"] = index ["INDEX_TYPE"];  	row ["COMMENT"] = index ["COMMENT"];  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: foreach (DataRow index in indexes.Rows) {  	var seq_index = (long)index ["SEQ_IN_INDEX"];  	if (seq_index != 1)  		continue;  	if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  		continue;  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = index ["KEY_NAME"];  	row ["TABLE_NAME"] = index ["TABLE"];  	row ["UNIQUE"] = (long)index ["NON_UNIQUE"] == 0;  	row ["PRIMARY"] = index ["KEY_NAME"].Equals ("PRIMARY");  	row ["TYPE"] = index ["INDEX_TYPE"];  	row ["COMMENT"] = index ["COMMENT"];  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: foreach (DataRow index in indexes.Rows) {  	var seq_index = (long)index ["SEQ_IN_INDEX"];  	if (seq_index != 1)  		continue;  	if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  		continue;  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = index ["KEY_NAME"];  	row ["TABLE_NAME"] = index ["TABLE"];  	row ["UNIQUE"] = (long)index ["NON_UNIQUE"] == 0;  	row ["PRIMARY"] = index ["KEY_NAME"].Equals ("PRIMARY");  	row ["TYPE"] = index ["INDEX_TYPE"];  	row ["COMMENT"] = index ["COMMENT"];  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexes,The following statement contains a magic number: if (restrictions != null && restrictions.Length == 4 && restrictions [3] != null && !index ["KEY_NAME"].Equals (restrictions [3]))  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: tableRestrictions [3] = "BASE TABLE";  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' table ["TABLE_SCHEMA"]' table ["TABLE_NAME"]);  	var cmd = new MySqlCommand (sql' connection);  	using (var reader = cmd.ExecuteReader ()) {  		while (reader.Read ()) {  			var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  			var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  			if (restrictions != null) {  				if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  					continue;  				if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  					continue;  			}  			var row = dt.NewRow ();  			row ["INDEX_CATALOG"] = null;  			row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  			row ["INDEX_NAME"] = key_name;  			row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  			row ["COLUMN_NAME"] = col_name;  			row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  			row ["SORT_ORDER"] = reader.GetString ("COLLATION");  			dt.Rows.Add (row);  		}  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' table ["TABLE_SCHEMA"]' table ["TABLE_NAME"]);  	var cmd = new MySqlCommand (sql' connection);  	using (var reader = cmd.ExecuteReader ()) {  		while (reader.Read ()) {  			var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  			var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  			if (restrictions != null) {  				if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  					continue;  				if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  					continue;  			}  			var row = dt.NewRow ();  			row ["INDEX_CATALOG"] = null;  			row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  			row ["INDEX_NAME"] = key_name;  			row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  			row ["COLUMN_NAME"] = col_name;  			row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  			row ["SORT_ORDER"] = reader.GetString ("COLLATION");  			dt.Rows.Add (row);  		}  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' table ["TABLE_SCHEMA"]' table ["TABLE_NAME"]);  	var cmd = new MySqlCommand (sql' connection);  	using (var reader = cmd.ExecuteReader ()) {  		while (reader.Read ()) {  			var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  			var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  			if (restrictions != null) {  				if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  					continue;  				if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  					continue;  			}  			var row = dt.NewRow ();  			row ["INDEX_CATALOG"] = null;  			row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  			row ["INDEX_NAME"] = key_name;  			row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  			row ["COLUMN_NAME"] = col_name;  			row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  			row ["SORT_ORDER"] = reader.GetString ("COLLATION");  			dt.Rows.Add (row);  		}  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' table ["TABLE_SCHEMA"]' table ["TABLE_NAME"]);  	var cmd = new MySqlCommand (sql' connection);  	using (var reader = cmd.ExecuteReader ()) {  		while (reader.Read ()) {  			var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  			var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  			if (restrictions != null) {  				if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  					continue;  				if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  					continue;  			}  			var row = dt.NewRow ();  			row ["INDEX_CATALOG"] = null;  			row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  			row ["INDEX_NAME"] = key_name;  			row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  			row ["COLUMN_NAME"] = col_name;  			row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  			row ["SORT_ORDER"] = reader.GetString ("COLLATION");  			dt.Rows.Add (row);  		}  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' table ["TABLE_SCHEMA"]' table ["TABLE_NAME"]);  	var cmd = new MySqlCommand (sql' connection);  	using (var reader = cmd.ExecuteReader ()) {  		while (reader.Read ()) {  			var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  			var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  			if (restrictions != null) {  				if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  					continue;  				if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  					continue;  			}  			var row = dt.NewRow ();  			row ["INDEX_CATALOG"] = null;  			row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  			row ["INDEX_NAME"] = key_name;  			row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  			row ["COLUMN_NAME"] = col_name;  			row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  			row ["SORT_ORDER"] = reader.GetString ("COLLATION");  			dt.Rows.Add (row);  		}  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: foreach (DataRow table in tables.Rows) {  	var sql = String.Format ("SHOW INDEX FROM `{0}`.`{1}`"' table ["TABLE_SCHEMA"]' table ["TABLE_NAME"]);  	var cmd = new MySqlCommand (sql' connection);  	using (var reader = cmd.ExecuteReader ()) {  		while (reader.Read ()) {  			var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  			var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  			if (restrictions != null) {  				if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  					continue;  				if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  					continue;  			}  			var row = dt.NewRow ();  			row ["INDEX_CATALOG"] = null;  			row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  			row ["INDEX_NAME"] = key_name;  			row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  			row ["COLUMN_NAME"] = col_name;  			row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  			row ["SORT_ORDER"] = reader.GetString ("COLLATION");  			dt.Rows.Add (row);  		}  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  		var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  		if (restrictions != null) {  			if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  				continue;  			if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  				continue;  		}  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = key_name;  		row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  		row ["COLUMN_NAME"] = col_name;  		row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  		row ["SORT_ORDER"] = reader.GetString ("COLLATION");  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  		var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  		if (restrictions != null) {  			if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  				continue;  			if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  				continue;  		}  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = key_name;  		row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  		row ["COLUMN_NAME"] = col_name;  		row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  		row ["SORT_ORDER"] = reader.GetString ("COLLATION");  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  		var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  		if (restrictions != null) {  			if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  				continue;  			if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  				continue;  		}  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = key_name;  		row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  		row ["COLUMN_NAME"] = col_name;  		row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  		row ["SORT_ORDER"] = reader.GetString ("COLLATION");  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  		var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  		if (restrictions != null) {  			if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  				continue;  			if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  				continue;  		}  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = key_name;  		row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  		row ["COLUMN_NAME"] = col_name;  		row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  		row ["SORT_ORDER"] = reader.GetString ("COLLATION");  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  		var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  		if (restrictions != null) {  			if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  				continue;  			if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  				continue;  		}  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = key_name;  		row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  		row ["COLUMN_NAME"] = col_name;  		row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  		row ["SORT_ORDER"] = reader.GetString ("COLLATION");  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  		var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  		if (restrictions != null) {  			if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  				continue;  			if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  				continue;  		}  		var row = dt.NewRow ();  		row ["INDEX_CATALOG"] = null;  		row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  		row ["INDEX_NAME"] = key_name;  		row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  		row ["COLUMN_NAME"] = col_name;  		row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  		row ["SORT_ORDER"] = reader.GetString ("COLLATION");  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: while (reader.Read ()) {  	var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  	var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  	if (restrictions != null) {  		if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  			continue;  		if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  			continue;  	}  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = key_name;  	row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  	row ["COLUMN_NAME"] = col_name;  	row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  	row ["SORT_ORDER"] = reader.GetString ("COLLATION");  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: while (reader.Read ()) {  	var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  	var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  	if (restrictions != null) {  		if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  			continue;  		if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  			continue;  	}  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = key_name;  	row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  	row ["COLUMN_NAME"] = col_name;  	row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  	row ["SORT_ORDER"] = reader.GetString ("COLLATION");  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: while (reader.Read ()) {  	var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  	var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  	if (restrictions != null) {  		if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  			continue;  		if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  			continue;  	}  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = key_name;  	row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  	row ["COLUMN_NAME"] = col_name;  	row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  	row ["SORT_ORDER"] = reader.GetString ("COLLATION");  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: while (reader.Read ()) {  	var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  	var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  	if (restrictions != null) {  		if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  			continue;  		if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  			continue;  	}  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = key_name;  	row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  	row ["COLUMN_NAME"] = col_name;  	row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  	row ["SORT_ORDER"] = reader.GetString ("COLLATION");  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: while (reader.Read ()) {  	var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  	var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  	if (restrictions != null) {  		if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  			continue;  		if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  			continue;  	}  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = key_name;  	row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  	row ["COLUMN_NAME"] = col_name;  	row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  	row ["SORT_ORDER"] = reader.GetString ("COLLATION");  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: while (reader.Read ()) {  	var key_name = GetString (reader' reader.GetOrdinal ("KEY_NAME"));  	var col_name = GetString (reader' reader.GetOrdinal ("COLUMN_NAME"));  	if (restrictions != null) {  		if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  			continue;  		if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  			continue;  	}  	var row = dt.NewRow ();  	row ["INDEX_CATALOG"] = null;  	row ["INDEX_SCHEMA"] = table ["TABLE_SCHEMA"];  	row ["INDEX_NAME"] = key_name;  	row ["TABLE_NAME"] = GetString (reader' reader.GetOrdinal ("TABLE"));  	row ["COLUMN_NAME"] = col_name;  	row ["ORDINAL_POSITION"] = reader.GetValue (reader.GetOrdinal ("SEQ_IN_INDEX"));  	row ["SORT_ORDER"] = reader.GetString ("COLLATION");  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  		continue;  	if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  		continue;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  		continue;  	if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  		continue;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  		continue;  	if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  		continue;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  		continue;  	if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  		continue;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  		continue;  	if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  		continue;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  		continue;  	if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  		continue;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions.Length >= 4 && restrictions [3] != null && key_name != restrictions [3])  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetIndexColumns,The following statement contains a magic number: if (restrictions.Length >= 5 && restrictions [4] != null && col_name != restrictions [4])  	continue;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 4) {  	keyName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 4) {  	keyName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 4) {  	keyName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: keyName = restrictions [3];  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeys,The following statement contains a magic number: restrictions [3] = null;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 4) {  	keyName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 4) {  	keyName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 4) {  	keyName = restrictions [3];  	restrictions [3] = null;  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: keyName = restrictions [3];  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetForeignKeyColumns,The following statement contains a magic number: restrictions [3] = null;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 2 && restrictions [1] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND db LIKE '{0}'"' restrictions [1]);  	if (restrictions.Length >= 3 && restrictions [2] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  	if (restrictions.Length >= 4 && restrictions [3] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 2 && restrictions [1] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND db LIKE '{0}'"' restrictions [1]);  	if (restrictions.Length >= 3 && restrictions [2] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  	if (restrictions.Length >= 4 && restrictions [3] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 2 && restrictions [1] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND db LIKE '{0}'"' restrictions [1]);  	if (restrictions.Length >= 3 && restrictions [2] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  	if (restrictions.Length >= 4 && restrictions [3] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 2 && restrictions [1] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND db LIKE '{0}'"' restrictions [1]);  	if (restrictions.Length >= 3 && restrictions [2] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  	if (restrictions.Length >= 4 && restrictions [3] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 2 && restrictions [1] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND db LIKE '{0}'"' restrictions [1]);  	if (restrictions.Length >= 3 && restrictions [2] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  	if (restrictions.Length >= 4 && restrictions [3] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 2 && restrictions [1] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND db LIKE '{0}'"' restrictions [1]);  	if (restrictions.Length >= 3 && restrictions [2] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  	if (restrictions.Length >= 4 && restrictions [3] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions != null) {  	if (restrictions.Length >= 2 && restrictions [1] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND db LIKE '{0}'"' restrictions [1]);  	if (restrictions.Length >= 3 && restrictions [2] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  	if (restrictions.Length >= 4 && restrictions [3] != null)  		sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions.Length >= 2 && restrictions [1] != null)  	sql.AppendFormat (CultureInfo.InvariantCulture' " AND db LIKE '{0}'"' restrictions [1]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions.Length >= 3 && restrictions [2] != null)  	sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions.Length >= 3 && restrictions [2] != null)  	sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions.Length >= 3 && restrictions [2] != null)  	sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: sql.AppendFormat (CultureInfo.InvariantCulture' " AND name LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions.Length >= 4 && restrictions [3] != null)  	sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions.Length >= 4 && restrictions [3] != null)  	sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: if (restrictions.Length >= 4 && restrictions [3] != null)  	sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetProcedures,The following statement contains a magic number: sql.AppendFormat (CultureInfo.InvariantCulture' " AND type LIKE '{0}'"' restrictions [3]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetDataSourceInformation,The following statement contains a magic number: row ["ParameterNameMaxLength"] = 128;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetDataSourceInformation,The following statement contains a magic number: row ["SupportedJoinOperators"] = 15;  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 3 && restrictions [2] != null)  	where.AppendFormat (CultureInfo.InvariantCulture' " LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 3 && restrictions [2] != null)  	where.AppendFormat (CultureInfo.InvariantCulture' " LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: if (restrictions != null && restrictions.Length >= 3 && restrictions [2] != null)  	where.AppendFormat (CultureInfo.InvariantCulture' " LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: where.AppendFormat (CultureInfo.InvariantCulture' " LIKE '{0}'"' restrictions [2]);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = schemaTable.NewRow ();  		row ["TABLE_CATALOG"] = null;  		row ["TABLE_SCHEMA"] = restrictions [1];  		row ["TABLE_NAME"] = reader.GetString (0);  		row ["TABLE_TYPE"] = table_type;  		row ["ENGINE"] = GetString (reader' 1);  		row ["VERSION"] = reader.GetValue (2);  		row ["ROW_FORMAT"] = GetString (reader' 3);  		row ["TABLE_ROWS"] = reader.GetValue (4);  		row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  		row ["DATA_LENGTH"] = reader.GetValue (6);  		row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  		row ["INDEX_LENGTH"] = reader.GetValue (8);  		row ["DATA_FREE"] = reader.GetValue (9);  		row ["AUTO_INCREMENT"] = reader.GetValue (10);  		row ["CREATE_TIME"] = reader.GetValue (11);  		row ["UPDATE_TIME"] = reader.GetValue (12);  		row ["CHECK_TIME"] = reader.GetValue (13);  		row ["TABLE_COLLATION"] = GetString (reader' 14);  		row ["CHECKSUM"] = reader.GetValue (15);  		row ["CREATE_OPTIONS"] = GetString (reader' 16);  		row ["TABLE_COMMENT"] = GetString (reader' 17);  		schemaTable.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: while (reader.Read ()) {  	var row = schemaTable.NewRow ();  	row ["TABLE_CATALOG"] = null;  	row ["TABLE_SCHEMA"] = restrictions [1];  	row ["TABLE_NAME"] = reader.GetString (0);  	row ["TABLE_TYPE"] = table_type;  	row ["ENGINE"] = GetString (reader' 1);  	row ["VERSION"] = reader.GetValue (2);  	row ["ROW_FORMAT"] = GetString (reader' 3);  	row ["TABLE_ROWS"] = reader.GetValue (4);  	row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  	row ["DATA_LENGTH"] = reader.GetValue (6);  	row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  	row ["INDEX_LENGTH"] = reader.GetValue (8);  	row ["DATA_FREE"] = reader.GetValue (9);  	row ["AUTO_INCREMENT"] = reader.GetValue (10);  	row ["CREATE_TIME"] = reader.GetValue (11);  	row ["UPDATE_TIME"] = reader.GetValue (12);  	row ["CHECK_TIME"] = reader.GetValue (13);  	row ["TABLE_COLLATION"] = GetString (reader' 14);  	row ["CHECKSUM"] = reader.GetValue (15);  	row ["CREATE_OPTIONS"] = GetString (reader' 16);  	row ["TABLE_COMMENT"] = GetString (reader' 17);  	schemaTable.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["VERSION"] = reader.GetValue (2);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["ROW_FORMAT"] = GetString (reader' 3);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["TABLE_ROWS"] = reader.GetValue (4);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["AVG_ROW_LENGTH"] = reader.GetValue (5);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["DATA_LENGTH"] = reader.GetValue (6);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["MAX_DATA_LENGTH"] = reader.GetValue (7);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["INDEX_LENGTH"] = reader.GetValue (8);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["DATA_FREE"] = reader.GetValue (9);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["AUTO_INCREMENT"] = reader.GetValue (10);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["CREATE_TIME"] = reader.GetValue (11);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["UPDATE_TIME"] = reader.GetValue (12);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["CHECK_TIME"] = reader.GetValue (13);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["TABLE_COLLATION"] = GetString (reader' 14);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["CHECKSUM"] = reader.GetValue (15);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["CREATE_OPTIONS"] = GetString (reader' 16);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,FindTables,The following statement contains a magic number: row ["TABLE_COMMENT"] = GetString (reader' 17);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetUDF,The following statement contains a magic number: try {  	using (var reader = cmd.ExecuteReader ()) {  		while (reader.Read ()) {  			var row = dt.NewRow ();  			row [0] = reader.GetString (0);  			row [1] = reader.GetInt32 (1);  			row [2] = reader.GetString (2);  			dt.Rows.Add (row);  		}  	}  }  catch (MySqlException ex) {  	if (ex.Number != (int)MySqlErrorCode.TableAccessDenied)  		throw;  	throw new MySqlException (Resources.UnableToEnumerateUDF' ex);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetUDF,The following statement contains a magic number: try {  	using (var reader = cmd.ExecuteReader ()) {  		while (reader.Read ()) {  			var row = dt.NewRow ();  			row [0] = reader.GetString (0);  			row [1] = reader.GetInt32 (1);  			row [2] = reader.GetString (2);  			dt.Rows.Add (row);  		}  	}  }  catch (MySqlException ex) {  	if (ex.Number != (int)MySqlErrorCode.TableAccessDenied)  		throw;  	throw new MySqlException (Resources.UnableToEnumerateUDF' ex);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetUDF,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = dt.NewRow ();  		row [0] = reader.GetString (0);  		row [1] = reader.GetInt32 (1);  		row [2] = reader.GetString (2);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetUDF,The following statement contains a magic number: using (var reader = cmd.ExecuteReader ()) {  	while (reader.Read ()) {  		var row = dt.NewRow ();  		row [0] = reader.GetString (0);  		row [1] = reader.GetInt32 (1);  		row [2] = reader.GetString (2);  		dt.Rows.Add (row);  	}  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetUDF,The following statement contains a magic number: while (reader.Read ()) {  	var row = dt.NewRow ();  	row [0] = reader.GetString (0);  	row [1] = reader.GetInt32 (1);  	row [2] = reader.GetString (2);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetUDF,The following statement contains a magic number: while (reader.Read ()) {  	var row = dt.NewRow ();  	row [0] = reader.GetString (0);  	row [1] = reader.GetInt32 (1);  	row [2] = reader.GetString (2);  	dt.Rows.Add (row);  }  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetUDF,The following statement contains a magic number: row [2] = reader.GetString (2);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetUDF,The following statement contains a magic number: row [2] = reader.GetString (2);  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetSchemaInternal,The following statement contains a magic number: if (restrictions == null)  	restrictions = new string[2];  
Magic Number,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetSchemaInternal,The following statement contains a magic number: restrictions = new string[2];  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,BindParameters,The following statement contains a magic number: while (true) {  	InternalBindParameters (ResolvedCommandText' parameters' null);  	// if we are not batching' then we are done.  This is only really relevant the  	// first time through  	if (command.Batch == null)  		return;  	while (index < command.Batch.Count) {  		var batchedCmd = command.Batch [index++];  		var packet = (MySqlPacket)buffers [buffers.Count - 1];  		// now we make a guess if this statement will fit in our current stream  		var estimatedCmdSize = batchedCmd.EstimatedSize ();  		if (((packet.Length - 4) + estimatedCmdSize) > Connection.driver.MaxPacketSize) {  			// it won't' so we setup to start a new run from here  			parameters = batchedCmd.Parameters;  			break;  		}  		// looks like we might have room for it so we remember the current end of the stream  		buffers.RemoveAt (buffers.Count - 1);  		//long originalLength = packet.Length - 4;  		// and attempt to stream the next command  		var text = ResolvedCommandText;  		if (text.StartsWith ("("' StringComparison.Ordinal))  			packet.WriteStringNoNull ("' ");  		else  			packet.WriteStringNoNull ("; ");  		InternalBindParameters (text' batchedCmd.Parameters' packet);  		if ((packet.Length - 4) > Connection.driver.MaxPacketSize) {  			//TODO  			//stream.InternalBuffer.SetLength(originalLength);  			parameters = batchedCmd.Parameters;  			break;  		}  	}  	if (index == command.Batch.Count)  		return;  }  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,BindParameters,The following statement contains a magic number: while (true) {  	InternalBindParameters (ResolvedCommandText' parameters' null);  	// if we are not batching' then we are done.  This is only really relevant the  	// first time through  	if (command.Batch == null)  		return;  	while (index < command.Batch.Count) {  		var batchedCmd = command.Batch [index++];  		var packet = (MySqlPacket)buffers [buffers.Count - 1];  		// now we make a guess if this statement will fit in our current stream  		var estimatedCmdSize = batchedCmd.EstimatedSize ();  		if (((packet.Length - 4) + estimatedCmdSize) > Connection.driver.MaxPacketSize) {  			// it won't' so we setup to start a new run from here  			parameters = batchedCmd.Parameters;  			break;  		}  		// looks like we might have room for it so we remember the current end of the stream  		buffers.RemoveAt (buffers.Count - 1);  		//long originalLength = packet.Length - 4;  		// and attempt to stream the next command  		var text = ResolvedCommandText;  		if (text.StartsWith ("("' StringComparison.Ordinal))  			packet.WriteStringNoNull ("' ");  		else  			packet.WriteStringNoNull ("; ");  		InternalBindParameters (text' batchedCmd.Parameters' packet);  		if ((packet.Length - 4) > Connection.driver.MaxPacketSize) {  			//TODO  			//stream.InternalBuffer.SetLength(originalLength);  			parameters = batchedCmd.Parameters;  			break;  		}  	}  	if (index == command.Batch.Count)  		return;  }  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,BindParameters,The following statement contains a magic number: while (index < command.Batch.Count) {  	var batchedCmd = command.Batch [index++];  	var packet = (MySqlPacket)buffers [buffers.Count - 1];  	// now we make a guess if this statement will fit in our current stream  	var estimatedCmdSize = batchedCmd.EstimatedSize ();  	if (((packet.Length - 4) + estimatedCmdSize) > Connection.driver.MaxPacketSize) {  		// it won't' so we setup to start a new run from here  		parameters = batchedCmd.Parameters;  		break;  	}  	// looks like we might have room for it so we remember the current end of the stream  	buffers.RemoveAt (buffers.Count - 1);  	//long originalLength = packet.Length - 4;  	// and attempt to stream the next command  	var text = ResolvedCommandText;  	if (text.StartsWith ("("' StringComparison.Ordinal))  		packet.WriteStringNoNull ("' ");  	else  		packet.WriteStringNoNull ("; ");  	InternalBindParameters (text' batchedCmd.Parameters' packet);  	if ((packet.Length - 4) > Connection.driver.MaxPacketSize) {  		//TODO  		//stream.InternalBuffer.SetLength(originalLength);  		parameters = batchedCmd.Parameters;  		break;  	}  }  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,BindParameters,The following statement contains a magic number: while (index < command.Batch.Count) {  	var batchedCmd = command.Batch [index++];  	var packet = (MySqlPacket)buffers [buffers.Count - 1];  	// now we make a guess if this statement will fit in our current stream  	var estimatedCmdSize = batchedCmd.EstimatedSize ();  	if (((packet.Length - 4) + estimatedCmdSize) > Connection.driver.MaxPacketSize) {  		// it won't' so we setup to start a new run from here  		parameters = batchedCmd.Parameters;  		break;  	}  	// looks like we might have room for it so we remember the current end of the stream  	buffers.RemoveAt (buffers.Count - 1);  	//long originalLength = packet.Length - 4;  	// and attempt to stream the next command  	var text = ResolvedCommandText;  	if (text.StartsWith ("("' StringComparison.Ordinal))  		packet.WriteStringNoNull ("' ");  	else  		packet.WriteStringNoNull ("; ");  	InternalBindParameters (text' batchedCmd.Parameters' packet);  	if ((packet.Length - 4) > Connection.driver.MaxPacketSize) {  		//TODO  		//stream.InternalBuffer.SetLength(originalLength);  		parameters = batchedCmd.Parameters;  		break;  	}  }  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,BindParameters,The following statement contains a magic number: if (((packet.Length - 4) + estimatedCmdSize) > Connection.driver.MaxPacketSize) {  	// it won't' so we setup to start a new run from here  	parameters = batchedCmd.Parameters;  	break;  }  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,BindParameters,The following statement contains a magic number: if ((packet.Length - 4) > Connection.driver.MaxPacketSize) {  	//TODO  	//stream.InternalBuffer.SetLength(originalLength);  	parameters = batchedCmd.Parameters;  	break;  }  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,InternalBindParameters,The following statement contains a magic number: while (token != null) {  	// serialize everything that came before the token (i.e. whitespace)  	packet.WriteStringNoNull (sql.Substring (pos' tokenizer.StartIndex - pos));  	pos = tokenizer.StopIndex;  	if (MySqlTokenizer.IsParameter (token)) {  		if (SerializeParameter (parameters' packet' token))  			token = null;  	}  	if (token != null) {  		if (sqlServerMode && tokenizer.Quoted && token.StartsWith ("["' StringComparison.Ordinal))  			token = String.Format ("`{0}`"' token.Substring (1' token.Length - 2));  		packet.WriteStringNoNull (token);  	}  	token = tokenizer.NextToken ();  }  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,InternalBindParameters,The following statement contains a magic number: if (token != null) {  	if (sqlServerMode && tokenizer.Quoted && token.StartsWith ("["' StringComparison.Ordinal))  		token = String.Format ("`{0}`"' token.Substring (1' token.Length - 2));  	packet.WriteStringNoNull (token);  }  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,InternalBindParameters,The following statement contains a magic number: if (sqlServerMode && tokenizer.Quoted && token.StartsWith ("["' StringComparison.Ordinal))  	token = String.Format ("`{0}`"' token.Substring (1' token.Length - 2));  
Magic Number,MySql.Data.MySqlClient,Statement,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Statement.cs,InternalBindParameters,The following statement contains a magic number: token = String.Format ("`{0}`"' token.Substring (1' token.Length - 2));  
Magic Number,MySql.Data.MySqlClient,TableCache,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TableCache.cs,TableCache,The following statement contains a magic number: cache = new BaseTableCache (480/* 8 hour max by default */);  
Magic Number,MySql.Data.MySqlClient,TimedStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TimedStream.cs,ShouldResetStreamTimeout,The following statement contains a magic number: if (currentValue >= newValue + 100)  	return true;  
Magic Number,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,SendQuery,The following statement contains a magic number: if (cmdText.Length > 300) {  	var normalizer = new QueryNormalizer ();  	normalized_query = normalizer.Normalize (cmdText);  	cmdText = cmdText.Substring (0' 300);  }  
Magic Number,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,SendQuery,The following statement contains a magic number: if (cmdText.Length > 300) {  	var normalizer = new QueryNormalizer ();  	normalized_query = normalizer.Normalize (cmdText);  	cmdText = cmdText.Substring (0' 300);  }  
Magic Number,MySql.Data.MySqlClient,TracingDriver,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\TracingDriver.cs,SendQuery,The following statement contains a magic number: cmdText = cmdText.Substring (0' 300);  
Magic Number,MySql.Data.Common,ContextString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\ContextString.cs,Split,The following statement contains a magic number: foreach (var c in src) {  	if (delimiters.IndexOf (c) != -1 && !escaped) {  		if (contextMarker != Char.MinValue)  			sb.Append (c);  		else {  			if (sb.Length > 0) {  				parts.Add (sb.ToString ());  				sb.Remove (0' sb.Length);  			}  		}  	}  	else if (c == '\\' && escapeBackslash)  		escaped = !escaped;  	else {  		var contextIndex = contextMarkers.IndexOf (c);  		if (!escaped && contextIndex != -1) {  			// if we have found the closing marker for our open   			// marker' then close the context  			if ((contextIndex % 2) == 1) {  				if (contextMarker == contextMarkers [contextIndex - 1])  					contextMarker = Char.MinValue;  			}  			else {  				// if the opening and closing context markers are   				// the same then we will always find the opening  				// marker.  				if (contextMarker == contextMarkers [contextIndex + 1])  					contextMarker = Char.MinValue;  				else if (contextMarker == Char.MinValue)  					contextMarker = c;  			}  		}  		sb.Append (c);  	}  }  
Magic Number,MySql.Data.Common,ContextString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\ContextString.cs,Split,The following statement contains a magic number: if (delimiters.IndexOf (c) != -1 && !escaped) {  	if (contextMarker != Char.MinValue)  		sb.Append (c);  	else {  		if (sb.Length > 0) {  			parts.Add (sb.ToString ());  			sb.Remove (0' sb.Length);  		}  	}  }  else if (c == '\\' && escapeBackslash)  	escaped = !escaped;  else {  	var contextIndex = contextMarkers.IndexOf (c);  	if (!escaped && contextIndex != -1) {  		// if we have found the closing marker for our open   		// marker' then close the context  		if ((contextIndex % 2) == 1) {  			if (contextMarker == contextMarkers [contextIndex - 1])  				contextMarker = Char.MinValue;  		}  		else {  			// if the opening and closing context markers are   			// the same then we will always find the opening  			// marker.  			if (contextMarker == contextMarkers [contextIndex + 1])  				contextMarker = Char.MinValue;  			else if (contextMarker == Char.MinValue)  				contextMarker = c;  		}  	}  	sb.Append (c);  }  
Magic Number,MySql.Data.Common,ContextString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\ContextString.cs,Split,The following statement contains a magic number: if (c == '\\' && escapeBackslash)  	escaped = !escaped;  else {  	var contextIndex = contextMarkers.IndexOf (c);  	if (!escaped && contextIndex != -1) {  		// if we have found the closing marker for our open   		// marker' then close the context  		if ((contextIndex % 2) == 1) {  			if (contextMarker == contextMarkers [contextIndex - 1])  				contextMarker = Char.MinValue;  		}  		else {  			// if the opening and closing context markers are   			// the same then we will always find the opening  			// marker.  			if (contextMarker == contextMarkers [contextIndex + 1])  				contextMarker = Char.MinValue;  			else if (contextMarker == Char.MinValue)  				contextMarker = c;  		}  	}  	sb.Append (c);  }  
Magic Number,MySql.Data.Common,ContextString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\ContextString.cs,Split,The following statement contains a magic number: if (!escaped && contextIndex != -1) {  	// if we have found the closing marker for our open   	// marker' then close the context  	if ((contextIndex % 2) == 1) {  		if (contextMarker == contextMarkers [contextIndex - 1])  			contextMarker = Char.MinValue;  	}  	else {  		// if the opening and closing context markers are   		// the same then we will always find the opening  		// marker.  		if (contextMarker == contextMarkers [contextIndex + 1])  			contextMarker = Char.MinValue;  		else if (contextMarker == Char.MinValue)  			contextMarker = c;  	}  }  
Magic Number,MySql.Data.Common,ContextString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\ContextString.cs,Split,The following statement contains a magic number: if ((contextIndex % 2) == 1) {  	if (contextMarker == contextMarkers [contextIndex - 1])  		contextMarker = Char.MinValue;  }  else {  	// if the opening and closing context markers are   	// the same then we will always find the opening  	// marker.  	if (contextMarker == contextMarkers [contextIndex + 1])  		contextMarker = Char.MinValue;  	else if (contextMarker == Char.MinValue)  		contextMarker = c;  }  
Magic Number,MySql.Data.Common,NamedPipeStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\NamedPipeStream.cs,Open,The following statement contains a magic number: fileStream = new FileStream (handle' mode' 4096' true);  
Magic Number,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,CollapseValueList,The following statement contains a magic number: if (parenIndices.Count < 2)  	return;  
Magic Number,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,ConsumeComment,The following statement contains a magic number: if (c == '-' && ((pos + 2) >= fullSql.Length || fullSql [pos + 1] != '-' || fullSql [pos + 2] != ' '))  	return false;  
Magic Number,MySql.Data.Common,QueryNormalizer,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\QueryNormalizer.cs,ConsumeComment,The following statement contains a magic number: if (c == '-' && ((pos + 2) >= fullSql.Length || fullSql [pos + 1] != '-' || fullSql [pos + 2] != ' '))  	return false;  
Magic Number,MySql.Data.Common,SharedMemoryStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\SharedMemoryStream.cs,GetConnectNumber,The following statement contains a magic number: using (var connectData = new SharedMemory (memoryName + "_CONNECT_DATA"' (IntPtr)4)) {  	// now start the connection  	if (!connectRequest.Set ())  		throw new MySqlException ("Failed to open shared memory connection");  	if (!connectAnswer.WaitOne ((int)(timeOut * 1000)' false))  		throw new MySqlException ("Timeout during connection");  	connectNumber = Marshal.ReadInt32 (connectData.View);  }  
Magic Number,MySql.Data.Common,SharedMemoryStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\SharedMemoryStream.cs,GetConnectNumber,The following statement contains a magic number: using (var connectData = new SharedMemory (memoryName + "_CONNECT_DATA"' (IntPtr)4)) {  	// now start the connection  	if (!connectRequest.Set ())  		throw new MySqlException ("Failed to open shared memory connection");  	if (!connectAnswer.WaitOne ((int)(timeOut * 1000)' false))  		throw new MySqlException ("Timeout during connection");  	connectNumber = Marshal.ReadInt32 (connectData.View);  }  
Magic Number,MySql.Data.Common,SharedMemoryStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\SharedMemoryStream.cs,GetConnectNumber,The following statement contains a magic number: if (!connectAnswer.WaitOne ((int)(timeOut * 1000)' false))  	throw new MySqlException ("Timeout during connection");  
Magic Number,MySql.Data.Common,SharedMemoryStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\SharedMemoryStream.cs,Read,The following statement contains a magic number: while (bytesLeft == 0) {  	stopwatch.Start ();  	var index = WaitHandle.WaitAny (waitHandles' timeLeft);  	stopwatch.Stop ();  	if (index == WaitHandle.WaitTimeout)  		throw new TimeoutException ("Timeout when reading from shared memory");  	if (waitHandles [index] == connectionClosed)  		throw new MySqlException ("Connection to server lost"' true' null);  	if (readTimeout != Timeout.Infinite) {  		timeLeft = readTimeout - (int)stopwatch.ElapsedMilliseconds;  		if (timeLeft < 0)  			throw new TimeoutException ("Timeout when reading from shared memory");  	}  	bytesLeft = Marshal.ReadInt32 (data.View);  	position = 4;  }  
Magic Number,MySql.Data.Common,SharedMemoryStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\SharedMemoryStream.cs,Read,The following statement contains a magic number: position = 4;  
Magic Number,MySql.Data.Common,SharedMemoryStream,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\SharedMemoryStream.cs,Write,The following statement contains a magic number: while (leftToDo > 0) {  	stopwatch.Start ();  	var index = WaitHandle.WaitAny (waitHandles' timeLeft);  	stopwatch.Stop ();  	if (waitHandles [index] == connectionClosed)  		throw new MySqlException ("Connection to server lost"' true' null);  	if (index == WaitHandle.WaitTimeout)  		throw new TimeoutException ("Timeout when reading from shared memory");  	if (writeTimeout != Timeout.Infinite) {  		timeLeft = writeTimeout - (int)stopwatch.ElapsedMilliseconds;  		if (timeLeft < 0)  			throw new TimeoutException ("Timeout when writing to shared memory");  	}  	var bytesToDo = Math.Min (leftToDo' BUFFERLENGTH);  	var baseMem = data.View.ToInt64 () + 4;  	Marshal.WriteInt32 (data.View' bytesToDo);  	Marshal.Copy (buffer' buffPos' (IntPtr)baseMem' bytesToDo);  	buffPos += bytesToDo;  	leftToDo -= bytesToDo;  	if (!clientWrote.Set ())  		throw new MySqlException ("Writing to shared memory failed");  }  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: if (pipeName != null && pipeName.Length != 0) {  	#if !CF  	stream = NamedPipeStream.Create (pipeName' hostName' timeout);  	#endif  }  else {  	var ipHE = GetHostEntry (hostName);  	foreach (var address in ipHE.AddressList) {  		if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  			continue;  		try {  			stream = CreateSocketStream (address' false);  			if (stream != null)  				break;  		}  		catch (Exception ex) {  			var socketException = ex as SocketException;  			// if the exception is a ConnectionRefused then we eat it as we may have other address  			// to attempt  			if (socketException == null)  				throw;  			#if !CF  			if (socketException.SocketErrorCode != SocketError.ConnectionRefused)  				throw;  			#endif  		}  	}  }  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: if (pipeName != null && pipeName.Length != 0) {  	#if !CF  	stream = NamedPipeStream.Create (pipeName' hostName' timeout);  	#endif  }  else {  	var ipHE = GetHostEntry (hostName);  	foreach (var address in ipHE.AddressList) {  		if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  			continue;  		try {  			stream = CreateSocketStream (address' false);  			if (stream != null)  				break;  		}  		catch (Exception ex) {  			var socketException = ex as SocketException;  			// if the exception is a ConnectionRefused then we eat it as we may have other address  			// to attempt  			if (socketException == null)  				throw;  			#if !CF  			if (socketException.SocketErrorCode != SocketError.ConnectionRefused)  				throw;  			#endif  		}  	}  }  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: if (pipeName != null && pipeName.Length != 0) {  	#if !CF  	stream = NamedPipeStream.Create (pipeName' hostName' timeout);  	#endif  }  else {  	var ipHE = GetHostEntry (hostName);  	foreach (var address in ipHE.AddressList) {  		if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  			continue;  		try {  			stream = CreateSocketStream (address' false);  			if (stream != null)  				break;  		}  		catch (Exception ex) {  			var socketException = ex as SocketException;  			// if the exception is a ConnectionRefused then we eat it as we may have other address  			// to attempt  			if (socketException == null)  				throw;  			#if !CF  			if (socketException.SocketErrorCode != SocketError.ConnectionRefused)  				throw;  			#endif  		}  	}  }  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: foreach (var address in ipHE.AddressList) {  	if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  		continue;  	try {  		stream = CreateSocketStream (address' false);  		if (stream != null)  			break;  	}  	catch (Exception ex) {  		var socketException = ex as SocketException;  		// if the exception is a ConnectionRefused then we eat it as we may have other address  		// to attempt  		if (socketException == null)  			throw;  		#if !CF  		if (socketException.SocketErrorCode != SocketError.ConnectionRefused)  			throw;  		#endif  	}  }  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: foreach (var address in ipHE.AddressList) {  	if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  		continue;  	try {  		stream = CreateSocketStream (address' false);  		if (stream != null)  			break;  	}  	catch (Exception ex) {  		var socketException = ex as SocketException;  		// if the exception is a ConnectionRefused then we eat it as we may have other address  		// to attempt  		if (socketException == null)  			throw;  		#if !CF  		if (socketException.SocketErrorCode != SocketError.ConnectionRefused)  			throw;  		#endif  	}  }  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: foreach (var address in ipHE.AddressList) {  	if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  		continue;  	try {  		stream = CreateSocketStream (address' false);  		if (stream != null)  			break;  	}  	catch (Exception ex) {  		var socketException = ex as SocketException;  		// if the exception is a ConnectionRefused then we eat it as we may have other address  		// to attempt  		if (socketException == null)  			throw;  		#if !CF  		if (socketException.SocketErrorCode != SocketError.ConnectionRefused)  			throw;  		#endif  	}  }  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  	continue;  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  	continue;  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,GetStreamFromHost,The following statement contains a magic number: if (address.AddressFamily == AddressFamily.InterNetworkV6 && !driverVersion.isAtLeast (5' 5' 3))  	continue;  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,CreateSocketStream,The following statement contains a magic number: if (!ias.AsyncWaitHandle.WaitOne ((int)timeOut * 1000' false)) {  	socket.Close ();  	return null;  }  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,SetKeepAlive,The following statement contains a magic number: if (time > UInt32.MaxValue / 1000)  	timeMilliseconds = UInt32.MaxValue;  else  	timeMilliseconds = time * 1000;  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,SetKeepAlive,The following statement contains a magic number: if (time > UInt32.MaxValue / 1000)  	timeMilliseconds = UInt32.MaxValue;  else  	timeMilliseconds = time * 1000;  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,SetKeepAlive,The following statement contains a magic number: timeMilliseconds = time * 1000;  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,SetKeepAlive,The following statement contains a magic number: BitConverter.GetBytes (time).CopyTo (inOptionValues' 4);  
Magic Number,MySql.Data.Common,StreamCreator,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\StreamCreator.cs,SetKeepAlive,The following statement contains a magic number: BitConverter.GetBytes (interval).CopyTo (inOptionValues' 8);  
Magic Number,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,NameToType,The following statement contains a magic number: switch (typeName.ToUpper (CultureInfo.InvariantCulture)) {  case "CHAR":  	return MySqlDbType.String;  case "VARCHAR":  	return MySqlDbType.VarChar;  case "DATE":  	return MySqlDbType.Date;  case "DATETIME":  	return MySqlDbType.DateTime;  case "NUMERIC":  case "DECIMAL":  case "DEC":  case "FIXED":  	if (connection.driver.Version.isAtLeast (5' 0' 3))  		return MySqlDbType.NewDecimal;  	else  		return MySqlDbType.Decimal;  case "YEAR":  	return MySqlDbType.Year;  case "TIME":  	return MySqlDbType.Time;  case "TIMESTAMP":  	return MySqlDbType.Timestamp;  case "SET":  	return MySqlDbType.Set;  case "ENUM":  	return MySqlDbType.Enum;  case "BIT":  	return MySqlDbType.Bit;  case "TINYINT":  	return unsigned ? MySqlDbType.UByte : MySqlDbType.Byte;  case "BOOL":  case "BOOLEAN":  	return MySqlDbType.Byte;  case "SMALLINT":  	return unsigned ? MySqlDbType.UInt16 : MySqlDbType.Int16;  case "MEDIUMINT":  	return unsigned ? MySqlDbType.UInt24 : MySqlDbType.Int24;  case "INT":  case "INTEGER":  	return unsigned ? MySqlDbType.UInt32 : MySqlDbType.Int32;  case "SERIAL":  	return MySqlDbType.UInt64;  case "BIGINT":  	return unsigned ? MySqlDbType.UInt64 : MySqlDbType.Int64;  case "FLOAT":  	return MySqlDbType.Float;  case "DOUBLE":  	return MySqlDbType.Double;  case "REAL":  	return realAsFloat ? MySqlDbType.Float : MySqlDbType.Double;  case "TEXT":  	return MySqlDbType.Text;  case "BLOB":  	return MySqlDbType.Blob;  case "LONGBLOB":  	return MySqlDbType.LongBlob;  case "LONGTEXT":  	return MySqlDbType.LongText;  case "MEDIUMBLOB":  	return MySqlDbType.MediumBlob;  case "MEDIUMTEXT":  	return MySqlDbType.MediumText;  case "TINYBLOB":  	return MySqlDbType.TinyBlob;  case "TINYTEXT":  	return MySqlDbType.TinyText;  case "BINARY":  	return MySqlDbType.Binary;  case "VARBINARY":  	return MySqlDbType.VarBinary;  }  
Magic Number,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,NameToType,The following statement contains a magic number: switch (typeName.ToUpper (CultureInfo.InvariantCulture)) {  case "CHAR":  	return MySqlDbType.String;  case "VARCHAR":  	return MySqlDbType.VarChar;  case "DATE":  	return MySqlDbType.Date;  case "DATETIME":  	return MySqlDbType.DateTime;  case "NUMERIC":  case "DECIMAL":  case "DEC":  case "FIXED":  	if (connection.driver.Version.isAtLeast (5' 0' 3))  		return MySqlDbType.NewDecimal;  	else  		return MySqlDbType.Decimal;  case "YEAR":  	return MySqlDbType.Year;  case "TIME":  	return MySqlDbType.Time;  case "TIMESTAMP":  	return MySqlDbType.Timestamp;  case "SET":  	return MySqlDbType.Set;  case "ENUM":  	return MySqlDbType.Enum;  case "BIT":  	return MySqlDbType.Bit;  case "TINYINT":  	return unsigned ? MySqlDbType.UByte : MySqlDbType.Byte;  case "BOOL":  case "BOOLEAN":  	return MySqlDbType.Byte;  case "SMALLINT":  	return unsigned ? MySqlDbType.UInt16 : MySqlDbType.Int16;  case "MEDIUMINT":  	return unsigned ? MySqlDbType.UInt24 : MySqlDbType.Int24;  case "INT":  case "INTEGER":  	return unsigned ? MySqlDbType.UInt32 : MySqlDbType.Int32;  case "SERIAL":  	return MySqlDbType.UInt64;  case "BIGINT":  	return unsigned ? MySqlDbType.UInt64 : MySqlDbType.Int64;  case "FLOAT":  	return MySqlDbType.Float;  case "DOUBLE":  	return MySqlDbType.Double;  case "REAL":  	return realAsFloat ? MySqlDbType.Float : MySqlDbType.Double;  case "TEXT":  	return MySqlDbType.Text;  case "BLOB":  	return MySqlDbType.Blob;  case "LONGBLOB":  	return MySqlDbType.LongBlob;  case "LONGTEXT":  	return MySqlDbType.LongText;  case "MEDIUMBLOB":  	return MySqlDbType.MediumBlob;  case "MEDIUMTEXT":  	return MySqlDbType.MediumText;  case "TINYBLOB":  	return MySqlDbType.TinyBlob;  case "TINYTEXT":  	return MySqlDbType.TinyText;  case "BINARY":  	return MySqlDbType.Binary;  case "VARBINARY":  	return MySqlDbType.VarBinary;  }  
Magic Number,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,NameToType,The following statement contains a magic number: if (connection.driver.Version.isAtLeast (5' 0' 3))  	return MySqlDbType.NewDecimal;  else  	return MySqlDbType.Decimal;  
Magic Number,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,NameToType,The following statement contains a magic number: if (connection.driver.Version.isAtLeast (5' 0' 3))  	return MySqlDbType.NewDecimal;  else  	return MySqlDbType.Decimal;  
Magic Number,MySql.Data.Types,MySqlBinary,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlBinary.cs,SetDSInfo,The following statement contains a magic number: for (var x = 0; x < types.Length; x++) {  	var row = dsTable.NewRow ();  	row ["TypeName"] = types [x];  	row ["ProviderDbType"] = dbtype [x];  	row ["ColumnSize"] = sizes [x];  	row ["CreateFormat"] = format [x];  	row ["CreateParameters"] = parms [x];  	row ["DataType"] = "System.Byte[]";  	row ["IsAutoincrementable"] = false;  	row ["IsBestMatch"] = true;  	row ["IsCaseSensitive"] = false;  	row ["IsFixedLength"] = x < 4 ? false : true;  	row ["IsFixedPrecisionScale"] = false;  	row ["IsLong"] = sizes [x] > 255;  	row ["IsNullable"] = true;  	row ["IsSearchable"] = false;  	row ["IsSearchableWithLike"] = false;  	row ["IsUnsigned"] = DBNull.Value;  	row ["MaximumScale"] = DBNull.Value;  	row ["MinimumScale"] = DBNull.Value;  	row ["IsConcurrencyType"] = DBNull.Value;  	row ["IsLiteralSupported"] = false;  	row ["LiteralPrefix"] = "0x";  	row ["LiteralSuffix"] = DBNull.Value;  	row ["NativeDataType"] = DBNull.Value;  	dsTable.Rows.Add (row);  }  
Magic Number,MySql.Data.Types,MySqlBinary,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlBinary.cs,SetDSInfo,The following statement contains a magic number: for (var x = 0; x < types.Length; x++) {  	var row = dsTable.NewRow ();  	row ["TypeName"] = types [x];  	row ["ProviderDbType"] = dbtype [x];  	row ["ColumnSize"] = sizes [x];  	row ["CreateFormat"] = format [x];  	row ["CreateParameters"] = parms [x];  	row ["DataType"] = "System.Byte[]";  	row ["IsAutoincrementable"] = false;  	row ["IsBestMatch"] = true;  	row ["IsCaseSensitive"] = false;  	row ["IsFixedLength"] = x < 4 ? false : true;  	row ["IsFixedPrecisionScale"] = false;  	row ["IsLong"] = sizes [x] > 255;  	row ["IsNullable"] = true;  	row ["IsSearchable"] = false;  	row ["IsSearchableWithLike"] = false;  	row ["IsUnsigned"] = DBNull.Value;  	row ["MaximumScale"] = DBNull.Value;  	row ["MinimumScale"] = DBNull.Value;  	row ["IsConcurrencyType"] = DBNull.Value;  	row ["IsLiteralSupported"] = false;  	row ["LiteralPrefix"] = "0x";  	row ["LiteralSuffix"] = DBNull.Value;  	row ["NativeDataType"] = DBNull.Value;  	dsTable.Rows.Add (row);  }  
Magic Number,MySql.Data.Types,MySqlBinary,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlBinary.cs,SetDSInfo,The following statement contains a magic number: row ["IsFixedLength"] = x < 4 ? false : true;  
Magic Number,MySql.Data.Types,MySqlBinary,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlBinary.cs,SetDSInfo,The following statement contains a magic number: row ["IsLong"] = sizes [x] > 255;  
Magic Number,MySql.Data.Types,MySqlBit,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlBit.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger ((long)v' 8);  else  	packet.WriteStringNoNull (v.ToString ());  
Magic Number,MySql.Data.Types,MySqlBit,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlBit.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger ((long)v' 8);  
Magic Number,MySql.Data.Types,MySqlBit,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlBit.cs,SetDSInfo,The following statement contains a magic number: row ["ColumnSize"] = 64;  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: if (dtValue.Millisecond > 0)  	packet.WriteByte (11);  else  	packet.WriteByte (7);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: if (dtValue.Millisecond > 0)  	packet.WriteByte (11);  else  	packet.WriteByte (7);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: packet.WriteByte (11);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: packet.WriteByte (7);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger (dtValue.Year' 2);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: if (dtValue.Millisecond > 0) {  	long val = dtValue.Millisecond < 1000 ? dtValue.Millisecond * 1000 : dtValue.Millisecond;  	for (var x = 0; x < 4; x++) {  		packet.WriteByte ((byte)(val & 0xff));  		val >>= 8;  	}  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: if (dtValue.Millisecond > 0) {  	long val = dtValue.Millisecond < 1000 ? dtValue.Millisecond * 1000 : dtValue.Millisecond;  	for (var x = 0; x < 4; x++) {  		packet.WriteByte ((byte)(val & 0xff));  		val >>= 8;  	}  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: if (dtValue.Millisecond > 0) {  	long val = dtValue.Millisecond < 1000 ? dtValue.Millisecond * 1000 : dtValue.Millisecond;  	for (var x = 0; x < 4; x++) {  		packet.WriteByte ((byte)(val & 0xff));  		val >>= 8;  	}  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: if (dtValue.Millisecond > 0) {  	long val = dtValue.Millisecond < 1000 ? dtValue.Millisecond * 1000 : dtValue.Millisecond;  	for (var x = 0; x < 4; x++) {  		packet.WriteByte ((byte)(val & 0xff));  		val >>= 8;  	}  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: for (var x = 0; x < 4; x++) {  	packet.WriteByte ((byte)(val & 0xff));  	val >>= 8;  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: for (var x = 0; x < 4; x++) {  	packet.WriteByte ((byte)(val & 0xff));  	val >>= 8;  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,WriteValue,The following statement contains a magic number: val >>= 8;  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 3) {  	hour = int.Parse (parts [3]);  	minute = int.Parse (parts [4]);  	second = int.Parse (parts [5]);  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 3) {  	hour = int.Parse (parts [3]);  	minute = int.Parse (parts [4]);  	second = int.Parse (parts [5]);  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 3) {  	hour = int.Parse (parts [3]);  	minute = int.Parse (parts [4]);  	second = int.Parse (parts [5]);  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 3) {  	hour = int.Parse (parts [3]);  	minute = int.Parse (parts [4]);  	second = int.Parse (parts [5]);  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: hour = int.Parse (parts [3]);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: minute = int.Parse (parts [4]);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: second = int.Parse (parts [5]);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 6) {  	millisecond = int.Parse (parts [6]);  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 6) {  	millisecond = int.Parse (parts [6]);  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ParseMySql,The following statement contains a magic number: millisecond = int.Parse (parts [6]);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ReadValue,The following statement contains a magic number: if (bufLength >= 4) {  	year = packet.ReadInteger (2);  	month = packet.ReadByte ();  	day = packet.ReadByte ();  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ReadValue,The following statement contains a magic number: if (bufLength >= 4) {  	year = packet.ReadInteger (2);  	month = packet.ReadByte ();  	day = packet.ReadByte ();  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ReadValue,The following statement contains a magic number: year = packet.ReadInteger (2);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ReadValue,The following statement contains a magic number: if (bufLength > 4) {  	hour = packet.ReadByte ();  	minute = packet.ReadByte ();  	second = packet.ReadByte ();  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,ReadValue,The following statement contains a magic number: if (bufLength > 7) {  	millisecond = packet.Read3ByteInt ();  	packet.ReadByte ();  }  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,FormatDateCustom,The following statement contains a magic number: year2digit -= ((year2digit / 100) * 100);  
Magic Number,MySql.Data.Types,MySqlDateTime,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDateTime.cs,FormatDateCustom,The following statement contains a magic number: year2digit -= ((year2digit / 100) * 100);  
Magic Number,MySql.Data.Types,MySqlDouble,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDouble.cs,ReadValue,The following statement contains a magic number: if (length == -1) {  	var b = new byte[8];  	packet.Read (b' 0' 8);  	return new MySqlDouble (BitConverter.ToDouble (b' 0));  }  
Magic Number,MySql.Data.Types,MySqlDouble,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDouble.cs,ReadValue,The following statement contains a magic number: if (length == -1) {  	var b = new byte[8];  	packet.Read (b' 0' 8);  	return new MySqlDouble (BitConverter.ToDouble (b' 0));  }  
Magic Number,MySql.Data.Types,MySqlDouble,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDouble.cs,ReadValue,The following statement contains a magic number: packet.Read (b' 0' 8);  
Magic Number,MySql.Data.Types,MySqlDouble,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlDouble.cs,SkipValue,The following statement contains a magic number: packet.Position += 8;  
Magic Number,MySql.Data.Types,MySqlInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt16.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger ((long)v' 2);  else  	packet.WriteStringNoNull (v.ToString ());  
Magic Number,MySql.Data.Types,MySqlInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt16.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger ((long)v' 2);  
Magic Number,MySql.Data.Types,MySqlInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt16.cs,ReadValue,The following statement contains a magic number: if (length == -1)  	return new MySqlInt16 ((short)packet.ReadInteger (2));  else  	return new MySqlInt16 (Int16.Parse (packet.ReadString (length)));  
Magic Number,MySql.Data.Types,MySqlInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt16.cs,ReadValue,The following statement contains a magic number: return new MySqlInt16 ((short)packet.ReadInteger (2));  
Magic Number,MySql.Data.Types,MySqlInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt16.cs,SkipValue,The following statement contains a magic number: packet.Position += 2;  
Magic Number,MySql.Data.Types,MySqlInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt32.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger ((long)v' is24Bit ? 3 : 4);  else  	packet.WriteStringNoNull (v.ToString ());  
Magic Number,MySql.Data.Types,MySqlInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt32.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger ((long)v' is24Bit ? 3 : 4);  else  	packet.WriteStringNoNull (v.ToString ());  
Magic Number,MySql.Data.Types,MySqlInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt32.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger ((long)v' is24Bit ? 3 : 4);  
Magic Number,MySql.Data.Types,MySqlInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt32.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger ((long)v' is24Bit ? 3 : 4);  
Magic Number,MySql.Data.Types,MySqlInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt32.cs,ReadValue,The following statement contains a magic number: if (length == -1)  	return new MySqlInt32 ((this as IMySqlValue).MySqlDbType' packet.ReadInteger (4));  else  	return new MySqlInt32 ((this as IMySqlValue).MySqlDbType' Int32.Parse (packet.ReadString (length)' CultureInfo.InvariantCulture));  
Magic Number,MySql.Data.Types,MySqlInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt32.cs,ReadValue,The following statement contains a magic number: return new MySqlInt32 ((this as IMySqlValue).MySqlDbType' packet.ReadInteger (4));  
Magic Number,MySql.Data.Types,MySqlInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt32.cs,SkipValue,The following statement contains a magic number: packet.Position += 4;  
Magic Number,MySql.Data.Types,MySqlInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt64.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger (v' 8);  else  	packet.WriteStringNoNull (v.ToString ());  
Magic Number,MySql.Data.Types,MySqlInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt64.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger (v' 8);  
Magic Number,MySql.Data.Types,MySqlInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt64.cs,ReadValue,The following statement contains a magic number: if (length == -1)  	return new MySqlInt64 ((long)packet.ReadULong (8));  else  	return new MySqlInt64 (Int64.Parse (packet.ReadString (length)));  
Magic Number,MySql.Data.Types,MySqlInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt64.cs,ReadValue,The following statement contains a magic number: return new MySqlInt64 ((long)packet.ReadULong (8));  
Magic Number,MySql.Data.Types,MySqlInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlInt64.cs,SkipValue,The following statement contains a magic number: packet.Position += 8;  
Magic Number,MySql.Data.Types,MySqlSingle,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlSingle.cs,ReadValue,The following statement contains a magic number: if (length == -1) {  	var b = new byte[4];  	packet.Read (b' 0' 4);  	return new MySqlSingle (BitConverter.ToSingle (b' 0));  }  
Magic Number,MySql.Data.Types,MySqlSingle,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlSingle.cs,ReadValue,The following statement contains a magic number: if (length == -1) {  	var b = new byte[4];  	packet.Read (b' 0' 4);  	return new MySqlSingle (BitConverter.ToSingle (b' 0));  }  
Magic Number,MySql.Data.Types,MySqlSingle,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlSingle.cs,ReadValue,The following statement contains a magic number: packet.Read (b' 0' 4);  
Magic Number,MySql.Data.Types,MySqlSingle,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlSingle.cs,SkipValue,The following statement contains a magic number: packet.Position += 4;  
Magic Number,MySql.Data.Types,MySqlString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlString.cs,SetDSInfo,The following statement contains a magic number: for (var x = 0; x < types.Length; x++) {  	var row = dsTable.NewRow ();  	row ["TypeName"] = types [x];  	row ["ProviderDbType"] = dbtype [x];  	row ["ColumnSize"] = 0;  	row ["CreateFormat"] = x < 4 ? types [x] + "({0})" : types [x];  	row ["CreateParameters"] = x < 4 ? "size" : null;  	row ["DataType"] = "System.String";  	row ["IsAutoincrementable"] = false;  	row ["IsBestMatch"] = true;  	row ["IsCaseSensitive"] = false;  	row ["IsFixedLength"] = false;  	row ["IsFixedPrecisionScale"] = true;  	row ["IsLong"] = false;  	row ["IsNullable"] = true;  	row ["IsSearchable"] = true;  	row ["IsSearchableWithLike"] = true;  	row ["IsUnsigned"] = false;  	row ["MaximumScale"] = 0;  	row ["MinimumScale"] = 0;  	row ["IsConcurrencyType"] = DBNull.Value;  	row ["IsLiteralSupported"] = false;  	row ["LiteralPrefix"] = null;  	row ["LiteralSuffix"] = null;  	row ["NativeDataType"] = null;  	dsTable.Rows.Add (row);  }  
Magic Number,MySql.Data.Types,MySqlString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlString.cs,SetDSInfo,The following statement contains a magic number: for (var x = 0; x < types.Length; x++) {  	var row = dsTable.NewRow ();  	row ["TypeName"] = types [x];  	row ["ProviderDbType"] = dbtype [x];  	row ["ColumnSize"] = 0;  	row ["CreateFormat"] = x < 4 ? types [x] + "({0})" : types [x];  	row ["CreateParameters"] = x < 4 ? "size" : null;  	row ["DataType"] = "System.String";  	row ["IsAutoincrementable"] = false;  	row ["IsBestMatch"] = true;  	row ["IsCaseSensitive"] = false;  	row ["IsFixedLength"] = false;  	row ["IsFixedPrecisionScale"] = true;  	row ["IsLong"] = false;  	row ["IsNullable"] = true;  	row ["IsSearchable"] = true;  	row ["IsSearchableWithLike"] = true;  	row ["IsUnsigned"] = false;  	row ["MaximumScale"] = 0;  	row ["MinimumScale"] = 0;  	row ["IsConcurrencyType"] = DBNull.Value;  	row ["IsLiteralSupported"] = false;  	row ["LiteralPrefix"] = null;  	row ["LiteralSuffix"] = null;  	row ["NativeDataType"] = null;  	dsTable.Rows.Add (row);  }  
Magic Number,MySql.Data.Types,MySqlString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlString.cs,SetDSInfo,The following statement contains a magic number: row ["CreateFormat"] = x < 4 ? types [x] + "({0})" : types [x];  
Magic Number,MySql.Data.Types,MySqlString,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlString.cs,SetDSInfo,The following statement contains a magic number: row ["CreateParameters"] = x < 4 ? "size" : null;  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (binary) {  	if (ts.Milliseconds > 0)  		packet.WriteByte (12);  	else  		packet.WriteByte (8);  	packet.WriteByte ((byte)(negative ? 1 : 0));  	packet.WriteInteger (ts.Days' 4);  	packet.WriteByte ((byte)ts.Hours);  	packet.WriteByte ((byte)ts.Minutes);  	packet.WriteByte ((byte)ts.Seconds);  	if (ts.Milliseconds > 0) {  		long mval = ts.Milliseconds * 1000;  		packet.WriteInteger (mval' 4);  	}  }  else {  	var s = String.Format ("'{0}{1} {2:00}:{3:00}:{4:00}.{5}'"' negative ? "-" : ""' ts.Days' ts.Hours' ts.Minutes' ts.Seconds' ts.Milliseconds);  	packet.WriteStringNoNull (s);  }  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (binary) {  	if (ts.Milliseconds > 0)  		packet.WriteByte (12);  	else  		packet.WriteByte (8);  	packet.WriteByte ((byte)(negative ? 1 : 0));  	packet.WriteInteger (ts.Days' 4);  	packet.WriteByte ((byte)ts.Hours);  	packet.WriteByte ((byte)ts.Minutes);  	packet.WriteByte ((byte)ts.Seconds);  	if (ts.Milliseconds > 0) {  		long mval = ts.Milliseconds * 1000;  		packet.WriteInteger (mval' 4);  	}  }  else {  	var s = String.Format ("'{0}{1} {2:00}:{3:00}:{4:00}.{5}'"' negative ? "-" : ""' ts.Days' ts.Hours' ts.Minutes' ts.Seconds' ts.Milliseconds);  	packet.WriteStringNoNull (s);  }  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (binary) {  	if (ts.Milliseconds > 0)  		packet.WriteByte (12);  	else  		packet.WriteByte (8);  	packet.WriteByte ((byte)(negative ? 1 : 0));  	packet.WriteInteger (ts.Days' 4);  	packet.WriteByte ((byte)ts.Hours);  	packet.WriteByte ((byte)ts.Minutes);  	packet.WriteByte ((byte)ts.Seconds);  	if (ts.Milliseconds > 0) {  		long mval = ts.Milliseconds * 1000;  		packet.WriteInteger (mval' 4);  	}  }  else {  	var s = String.Format ("'{0}{1} {2:00}:{3:00}:{4:00}.{5}'"' negative ? "-" : ""' ts.Days' ts.Hours' ts.Minutes' ts.Seconds' ts.Milliseconds);  	packet.WriteStringNoNull (s);  }  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (binary) {  	if (ts.Milliseconds > 0)  		packet.WriteByte (12);  	else  		packet.WriteByte (8);  	packet.WriteByte ((byte)(negative ? 1 : 0));  	packet.WriteInteger (ts.Days' 4);  	packet.WriteByte ((byte)ts.Hours);  	packet.WriteByte ((byte)ts.Minutes);  	packet.WriteByte ((byte)ts.Seconds);  	if (ts.Milliseconds > 0) {  		long mval = ts.Milliseconds * 1000;  		packet.WriteInteger (mval' 4);  	}  }  else {  	var s = String.Format ("'{0}{1} {2:00}:{3:00}:{4:00}.{5}'"' negative ? "-" : ""' ts.Days' ts.Hours' ts.Minutes' ts.Seconds' ts.Milliseconds);  	packet.WriteStringNoNull (s);  }  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (binary) {  	if (ts.Milliseconds > 0)  		packet.WriteByte (12);  	else  		packet.WriteByte (8);  	packet.WriteByte ((byte)(negative ? 1 : 0));  	packet.WriteInteger (ts.Days' 4);  	packet.WriteByte ((byte)ts.Hours);  	packet.WriteByte ((byte)ts.Minutes);  	packet.WriteByte ((byte)ts.Seconds);  	if (ts.Milliseconds > 0) {  		long mval = ts.Milliseconds * 1000;  		packet.WriteInteger (mval' 4);  	}  }  else {  	var s = String.Format ("'{0}{1} {2:00}:{3:00}:{4:00}.{5}'"' negative ? "-" : ""' ts.Days' ts.Hours' ts.Minutes' ts.Seconds' ts.Milliseconds);  	packet.WriteStringNoNull (s);  }  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (ts.Milliseconds > 0)  	packet.WriteByte (12);  else  	packet.WriteByte (8);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (ts.Milliseconds > 0)  	packet.WriteByte (12);  else  	packet.WriteByte (8);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: packet.WriteByte (12);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: packet.WriteByte (8);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger (ts.Days' 4);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (ts.Milliseconds > 0) {  	long mval = ts.Milliseconds * 1000;  	packet.WriteInteger (mval' 4);  }  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: if (ts.Milliseconds > 0) {  	long mval = ts.Milliseconds * 1000;  	packet.WriteInteger (mval' 4);  }  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger (mval' 4);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 0)  	isNull = true;  else if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 0)  	isNull = true;  else if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 0)  	isNull = true;  else if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 0)  	isNull = true;  else if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 0)  	isNull = true;  else if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 0)  	isNull = true;  else if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 0)  	isNull = true;  else if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 5)  	mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  else if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: mValue = new TimeSpan (packet.ReadInteger (4)' 0' 0' 0);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: if (bufLength == 8)  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  else  	mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ());  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ReadValue,The following statement contains a magic number: mValue = new TimeSpan (packet.ReadInteger (4)' packet.ReadByte ()' packet.ReadByte ()' packet.ReadByte ()' packet.ReadInteger (4) / 1000000);  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 3)  	msecs = Int32.Parse (parts [3]) / 1000;  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 3)  	msecs = Int32.Parse (parts [3]) / 1000;  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ParseMySql,The following statement contains a magic number: if (parts.Length > 3)  	msecs = Int32.Parse (parts [3]) / 1000;  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ParseMySql,The following statement contains a magic number: msecs = Int32.Parse (parts [3]) / 1000;  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ParseMySql,The following statement contains a magic number: msecs = Int32.Parse (parts [3]) / 1000;  
Magic Number,MySql.Data.Types,MySqlTimeSpan,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlTime.cs,ParseMySql,The following statement contains a magic number: hours = hours - (days * 24);  
Magic Number,MySql.Data.Types,MySqlUInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt16.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger ((long)v' 2);  else  	packet.WriteStringNoNull (v.ToString ());  
Magic Number,MySql.Data.Types,MySqlUInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt16.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger ((long)v' 2);  
Magic Number,MySql.Data.Types,MySqlUInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt16.cs,ReadValue,The following statement contains a magic number: if (length == -1)  	return new MySqlUInt16 ((ushort)packet.ReadInteger (2));  else  	return new MySqlUInt16 (UInt16.Parse (packet.ReadString (length)));  
Magic Number,MySql.Data.Types,MySqlUInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt16.cs,ReadValue,The following statement contains a magic number: return new MySqlUInt16 ((ushort)packet.ReadInteger (2));  
Magic Number,MySql.Data.Types,MySqlUInt16,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt16.cs,SkipValue,The following statement contains a magic number: packet.Position += 2;  
Magic Number,MySql.Data.Types,MySqlUInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt32.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger ((long)val' is24Bit ? 3 : 4);  else  	packet.WriteStringNoNull (val.ToString ());  
Magic Number,MySql.Data.Types,MySqlUInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt32.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger ((long)val' is24Bit ? 3 : 4);  else  	packet.WriteStringNoNull (val.ToString ());  
Magic Number,MySql.Data.Types,MySqlUInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt32.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger ((long)val' is24Bit ? 3 : 4);  
Magic Number,MySql.Data.Types,MySqlUInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt32.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger ((long)val' is24Bit ? 3 : 4);  
Magic Number,MySql.Data.Types,MySqlUInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt32.cs,ReadValue,The following statement contains a magic number: if (length == -1)  	return new MySqlUInt32 ((this as IMySqlValue).MySqlDbType' (uint)packet.ReadInteger (4));  else  	return new MySqlUInt32 ((this as IMySqlValue).MySqlDbType' UInt32.Parse (packet.ReadString (length)' NumberStyles.Any' CultureInfo.InvariantCulture));  
Magic Number,MySql.Data.Types,MySqlUInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt32.cs,ReadValue,The following statement contains a magic number: return new MySqlUInt32 ((this as IMySqlValue).MySqlDbType' (uint)packet.ReadInteger (4));  
Magic Number,MySql.Data.Types,MySqlUInt32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt32.cs,SkipValue,The following statement contains a magic number: packet.Position += 4;  
Magic Number,MySql.Data.Types,MySqlUInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt64.cs,WriteValue,The following statement contains a magic number: if (binary)  	packet.WriteInteger ((long)v' 8);  else  	packet.WriteStringNoNull (v.ToString ());  
Magic Number,MySql.Data.Types,MySqlUInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt64.cs,WriteValue,The following statement contains a magic number: packet.WriteInteger ((long)v' 8);  
Magic Number,MySql.Data.Types,MySqlUInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt64.cs,ReadValue,The following statement contains a magic number: if (length == -1)  	return new MySqlUInt64 (packet.ReadULong (8));  else  	return new MySqlUInt64 (UInt64.Parse (packet.ReadString (length)));  
Magic Number,MySql.Data.Types,MySqlUInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt64.cs,ReadValue,The following statement contains a magic number: return new MySqlUInt64 (packet.ReadULong (8));  
Magic Number,MySql.Data.Types,MySqlUInt64,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MySqlUInt64.cs,SkipValue,The following statement contains a magic number: packet.Position += 8;  
Magic Number,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += (buf [index++] & 0xff);  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (len > 0) {  	k = len < NMAX ? len : NMAX;  	len -= k;  	while (k >= 16) {  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		s1 += (buf [index++] & 0xff);  		s2 += s1;  		k -= 16;  	}  	if (k != 0) {  		do {  			s1 += (buf [index++] & 0xff);  			s2 += s1;  		}  		while (--k != 0);  	}  	s1 %= BASE;  	s2 %= BASE;  }  
Magic Number,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (k >= 16) {  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	k -= 16;  }  
Magic Number,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The following statement contains a magic number: while (k >= 16) {  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	s1 += (buf [index++] & 0xff);  	s2 += s1;  	k -= 16;  }  
Magic Number,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The following statement contains a magic number: k -= 16;  
Magic Number,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,lm_init,The following statement contains a magic number: window_size = 2 * w_size;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,tr_init,The following statement contains a magic number: last_eob_len = 8;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (var i = 0; i < L_CODES; i++)  	dyn_ltree [i * 2] = 0;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree [i * 2] = 0;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (var i = 0; i < D_CODES; i++)  	dyn_dtree [i * 2] = 0;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_dtree [i * 2] = 0;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,init_block,The following statement contains a magic number: for (var i = 0; i < BL_CODES; i++)  	bl_tree [i * 2] = 0;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,init_block,The following statement contains a magic number: bl_tree [i * 2] = 0;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree [END_BLOCK * 2] = 1;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree [n * 2] < tree [m * 2] || (tree [n * 2] == tree [m * 2] && depth [n] <= depth [m]));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree [n * 2] < tree [m * 2] || (tree [n * 2] == tree [m * 2] && depth [n] <= depth [m]));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree [n * 2] < tree [m * 2] || (tree [n * 2] == tree [m * 2] && depth [n] <= depth [m]));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree [n * 2] < tree [m * 2] || (tree [n * 2] == tree [m * 2] && depth [n] <= depth [m]));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree [(max_code + 1) * 2 + 1] = (short)SupportClass.Identity (0xffff);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  	}  	else if (curlen != 0) {  		if (curlen != prevlen)  			bl_tree [curlen * 2]++;  		bl_tree [REP_3_6 * 2]++;  	}  	else if (count <= 10) {  		bl_tree [REPZ_3_10 * 2]++;  	}  	else {  		bl_tree [REPZ_11_138 * 2]++;  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: nextlen = tree [(n + 1) * 2 + 1];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count < min_count) {  	bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  }  else if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [curlen * 2] = (short)(bl_tree [curlen * 2] + count);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen)  		bl_tree [curlen * 2]++;  	bl_tree [REP_3_6 * 2]++;  }  else if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen != prevlen)  	bl_tree [curlen * 2]++;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [curlen * 2]++;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [REP_3_6 * 2]++;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (count <= 10) {  	bl_tree [REPZ_3_10 * 2]++;  }  else {  	bl_tree [REPZ_11_138 * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [REPZ_3_10 * 2]++;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: bl_tree [REPZ_11_138 * 2]++;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 6;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 7;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 4;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {  	if (bl_tree [Tree.bl_order [max_blindex] * 2 + 1] != 0)  		break;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {  	if (bl_tree [Tree.bl_order [max_blindex] * 2 + 1] != 0)  		break;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: if (bl_tree [Tree.bl_order [max_blindex] * 2 + 1] != 0)  	break;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (lcodes - 257' 5);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (lcodes - 257' 5);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (dcodes - 1' 5);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (blcodes - 4' 4);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (blcodes - 4' 4);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++) {  	send_bits (bl_tree [Tree.bl_order [rank] * 2 + 1]' 3);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: for (rank = 0; rank < blcodes; rank++) {  	send_bits (bl_tree [Tree.bl_order [rank] * 2 + 1]' 3);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (bl_tree [Tree.bl_order [rank] * 2 + 1]' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits (bl_tree [Tree.bl_order [rank] * 2 + 1]' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	curlen = nextlen;  	nextlen = tree [(n + 1) * 2 + 1];  	if (++count < max_count && curlen == nextlen) {  		continue;  	}  	else if (count < min_count) {  		do {  			send_code (curlen' bl_tree);  		}  		while (--count != 0);  	}  	else if (curlen != 0) {  		if (curlen != prevlen) {  			send_code (curlen' bl_tree);  			count--;  		}  		send_code (REP_3_6' bl_tree);  		send_bits (count - 3' 2);  	}  	else if (count <= 10) {  		send_code (REPZ_3_10' bl_tree);  		send_bits (count - 3' 3);  	}  	else {  		send_code (REPZ_11_138' bl_tree);  		send_bits (count - 11' 7);  	}  	count = 0;  	prevlen = curlen;  	if (nextlen == 0) {  		max_count = 138;  		min_count = 3;  	}  	else if (curlen == nextlen) {  		max_count = 6;  		min_count = 3;  	}  	else {  		max_count = 7;  		min_count = 4;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: nextlen = tree [(n + 1) * 2 + 1];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (++count < max_count && curlen == nextlen) {  	continue;  }  else if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count < min_count) {  	do {  		send_code (curlen' bl_tree);  	}  	while (--count != 0);  }  else if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen != 0) {  	if (curlen != prevlen) {  		send_code (curlen' bl_tree);  		count--;  	}  	send_code (REP_3_6' bl_tree);  	send_bits (count - 3' 2);  }  else if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 3' 2);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 3' 2);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (count <= 10) {  	send_code (REPZ_3_10' bl_tree);  	send_bits (count - 3' 3);  }  else {  	send_code (REPZ_11_138' bl_tree);  	send_bits (count - 11' 7);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 3' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 3' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 11' 7);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: send_bits (count - 11' 7);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (nextlen == 0) {  	max_count = 138;  	min_count = 3;  }  else if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: if (curlen == nextlen) {  	max_count = 6;  	min_count = 3;  }  else {  	max_count = 7;  	min_count = 4;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 6;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 7;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 4;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,put_short,The following statement contains a magic number: put_byte ((byte)(SupportClass.URShift (w' 8)));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,putShortMSB,The following statement contains a magic number: put_byte ((byte)(b >> 8));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits ((tree [c * 2] & 0xffff)' (tree [c * 2 + 1] & 0xffff));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits ((tree [c * 2] & 0xffff)' (tree [c * 2 + 1] & 0xffff));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits (STATIC_TREES << 1' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9) {  	send_bits (STATIC_TREES << 1' 3);  	send_code (END_BLOCK' StaticTree.static_ltree);  	bi_flush ();  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9) {  	send_bits (STATIC_TREES << 1' 3);  	send_code (END_BLOCK' StaticTree.static_ltree);  	bi_flush ();  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: if (1 + last_eob_len + 10 - bi_valid < 9) {  	send_bits (STATIC_TREES << 1' 3);  	send_code (END_BLOCK' StaticTree.static_ltree);  	bi_flush ();  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits (STATIC_TREES << 1' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf [d_buf + last_lit * 2] = (byte)(SupportClass.URShift (dist' 8));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf [d_buf + last_lit * 2] = (byte)(SupportClass.URShift (dist' 8));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf [d_buf + last_lit * 2 + 1] = (byte)dist;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0) {  	// lc is the unmatched char  	dyn_ltree [lc * 2]++;  }  else {  	matches++;  	// Here' lc is the match length - MIN_MATCH  	dist--;  	// dist = match distance - 1  	dyn_ltree [(Tree._length_code [lc] + LITERALS + 1) * 2]++;  	dyn_dtree [Tree.d_code (dist) * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0) {  	// lc is the unmatched char  	dyn_ltree [lc * 2]++;  }  else {  	matches++;  	// Here' lc is the match length - MIN_MATCH  	dist--;  	// dist = match distance - 1  	dyn_ltree [(Tree._length_code [lc] + LITERALS + 1) * 2]++;  	dyn_dtree [Tree.d_code (dist) * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if (dist == 0) {  	// lc is the unmatched char  	dyn_ltree [lc * 2]++;  }  else {  	matches++;  	// Here' lc is the match length - MIN_MATCH  	dist--;  	// dist = match distance - 1  	dyn_ltree [(Tree._length_code [lc] + LITERALS + 1) * 2]++;  	dyn_dtree [Tree.d_code (dist) * 2]++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree [lc * 2]++;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree [(Tree._length_code [lc] + LITERALS + 1) * 2]++;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_dtree [Tree.d_code (dist) * 2]++;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2) {  	// Compute an upper bound for the compressed length  	var out_length = last_lit * 8;  	var in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.extra_dbits [dcode]));  	}  	out_length = SupportClass.URShift (out_length' 3);  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2) {  	// Compute an upper bound for the compressed length  	var out_length = last_lit * 8;  	var in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.extra_dbits [dcode]));  	}  	out_length = SupportClass.URShift (out_length' 3);  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2) {  	// Compute an upper bound for the compressed length  	var out_length = last_lit * 8;  	var in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.extra_dbits [dcode]));  	}  	out_length = SupportClass.URShift (out_length' 3);  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2) {  	// Compute an upper bound for the compressed length  	var out_length = last_lit * 8;  	var in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.extra_dbits [dcode]));  	}  	out_length = SupportClass.URShift (out_length' 3);  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2) {  	// Compute an upper bound for the compressed length  	var out_length = last_lit * 8;  	var in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.extra_dbits [dcode]));  	}  	out_length = SupportClass.URShift (out_length' 3);  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((last_lit & 0x1fff) == 0 && level > 2) {  	// Compute an upper bound for the compressed length  	var out_length = last_lit * 8;  	var in_length = strstart - block_start;  	int dcode;  	for (dcode = 0; dcode < D_CODES; dcode++) {  		out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.extra_dbits [dcode]));  	}  	out_length = SupportClass.URShift (out_length' 3);  	if ((matches < (last_lit / 2)) && out_length < in_length / 2)  		return true;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: for (dcode = 0; dcode < D_CODES; dcode++) {  	out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.extra_dbits [dcode]));  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree [dcode * 2] * (5L + Tree.extra_dbits [dcode]));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = SupportClass.URShift (out_length' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((matches < (last_lit / 2)) && out_length < in_length / 2)  	return true;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: if ((matches < (last_lit / 2)) && out_length < in_length / 2)  	return true;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0) {  	do {  		dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  		lc = (pending_buf [l_buf + lx]) & 0xff;  		lx++;  		if (dist == 0) {  			send_code (lc' ltree);  			// send a literal byte  		}  		else {  			// Here' lc is the match length - MIN_MATCH  			code = Tree._length_code [lc];  			send_code (code + LITERALS + 1' ltree);  			// send the length code  			extra = Tree.extra_lbits [code];  			if (extra != 0) {  				lc -= Tree.base_length [code];  				send_bits (lc' extra);  				// send the extra length bits  			}  			dist--;  			// dist is now the match distance - 1  			code = Tree.d_code (dist);  			send_code (code' dtree);  			// send the distance code  			extra = Tree.extra_dbits [code];  			if (extra != 0) {  				dist -= Tree.base_dist [code];  				send_bits (dist' extra);  				// send the extra distance bits  			}  		}  		// literal or match pair ?  		// Check that the overlay between pending_buf and d_buf+l_buf is ok:  	}  	while (lx < last_lit);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0) {  	do {  		dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  		lc = (pending_buf [l_buf + lx]) & 0xff;  		lx++;  		if (dist == 0) {  			send_code (lc' ltree);  			// send a literal byte  		}  		else {  			// Here' lc is the match length - MIN_MATCH  			code = Tree._length_code [lc];  			send_code (code + LITERALS + 1' ltree);  			// send the length code  			extra = Tree.extra_lbits [code];  			if (extra != 0) {  				lc -= Tree.base_length [code];  				send_bits (lc' extra);  				// send the extra length bits  			}  			dist--;  			// dist is now the match distance - 1  			code = Tree.d_code (dist);  			send_code (code' dtree);  			// send the distance code  			extra = Tree.extra_dbits [code];  			if (extra != 0) {  				dist -= Tree.base_dist [code];  				send_bits (dist' extra);  				// send the extra distance bits  			}  		}  		// literal or match pair ?  		// Check that the overlay between pending_buf and d_buf+l_buf is ok:  	}  	while (lx < last_lit);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: if (last_lit != 0) {  	do {  		dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  		lc = (pending_buf [l_buf + lx]) & 0xff;  		lx++;  		if (dist == 0) {  			send_code (lc' ltree);  			// send a literal byte  		}  		else {  			// Here' lc is the match length - MIN_MATCH  			code = Tree._length_code [lc];  			send_code (code + LITERALS + 1' ltree);  			// send the length code  			extra = Tree.extra_lbits [code];  			if (extra != 0) {  				lc -= Tree.base_length [code];  				send_bits (lc' extra);  				// send the extra length bits  			}  			dist--;  			// dist is now the match distance - 1  			code = Tree.d_code (dist);  			send_code (code' dtree);  			// send the distance code  			extra = Tree.extra_dbits [code];  			if (extra != 0) {  				dist -= Tree.base_dist [code];  				send_bits (dist' extra);  				// send the extra distance bits  			}  		}  		// literal or match pair ?  		// Check that the overlay between pending_buf and d_buf+l_buf is ok:  	}  	while (lx < last_lit);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: do {  	dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  	lc = (pending_buf [l_buf + lx]) & 0xff;  	lx++;  	if (dist == 0) {  		send_code (lc' ltree);  		// send a literal byte  	}  	else {  		// Here' lc is the match length - MIN_MATCH  		code = Tree._length_code [lc];  		send_code (code + LITERALS + 1' ltree);  		// send the length code  		extra = Tree.extra_lbits [code];  		if (extra != 0) {  			lc -= Tree.base_length [code];  			send_bits (lc' extra);  			// send the extra length bits  		}  		dist--;  		// dist is now the match distance - 1  		code = Tree.d_code (dist);  		send_code (code' dtree);  		// send the distance code  		extra = Tree.extra_dbits [code];  		if (extra != 0) {  			dist -= Tree.base_dist [code];  			send_bits (dist' extra);  			// send the extra distance bits  		}  	}  	// literal or match pair ?  	// Check that the overlay between pending_buf and d_buf+l_buf is ok:  }  while (lx < last_lit);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: do {  	dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  	lc = (pending_buf [l_buf + lx]) & 0xff;  	lx++;  	if (dist == 0) {  		send_code (lc' ltree);  		// send a literal byte  	}  	else {  		// Here' lc is the match length - MIN_MATCH  		code = Tree._length_code [lc];  		send_code (code + LITERALS + 1' ltree);  		// send the length code  		extra = Tree.extra_lbits [code];  		if (extra != 0) {  			lc -= Tree.base_length [code];  			send_bits (lc' extra);  			// send the extra length bits  		}  		dist--;  		// dist is now the match distance - 1  		code = Tree.d_code (dist);  		send_code (code' dtree);  		// send the distance code  		extra = Tree.extra_dbits [code];  		if (extra != 0) {  			dist -= Tree.base_dist [code];  			send_bits (dist' extra);  			// send the extra distance bits  		}  	}  	// literal or match pair ?  	// Check that the overlay between pending_buf and d_buf+l_buf is ok:  }  while (lx < last_lit);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: do {  	dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  	lc = (pending_buf [l_buf + lx]) & 0xff;  	lx++;  	if (dist == 0) {  		send_code (lc' ltree);  		// send a literal byte  	}  	else {  		// Here' lc is the match length - MIN_MATCH  		code = Tree._length_code [lc];  		send_code (code + LITERALS + 1' ltree);  		// send the length code  		extra = Tree.extra_lbits [code];  		if (extra != 0) {  			lc -= Tree.base_length [code];  			send_bits (lc' extra);  			// send the extra length bits  		}  		dist--;  		// dist is now the match distance - 1  		code = Tree.d_code (dist);  		send_code (code' dtree);  		// send the distance code  		extra = Tree.extra_dbits [code];  		if (extra != 0) {  			dist -= Tree.base_dist [code];  			send_bits (dist' extra);  			// send the extra distance bits  		}  	}  	// literal or match pair ?  	// Check that the overlay between pending_buf and d_buf+l_buf is ok:  }  while (lx < last_lit);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf [d_buf + lx * 2] << 8) & 0xff00) | (pending_buf [d_buf + lx * 2 + 1] & 0xff);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,compress_block,The following statement contains a magic number: last_eob_len = ltree [END_BLOCK * 2 + 1];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7) {  	bin_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 7) {  	bin_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree [n * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128) {  	ascii_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < 128) {  	ascii_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree [n * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: while (n < LITERALS) {  	bin_freq += dyn_ltree [n * 2];  	n++;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree [n * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (byte)(bin_freq > (SupportClass.URShift (ascii_freq' 2)) ? Z_BINARY : Z_ASCII);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	put_short (bi_buf);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	put_byte ((byte)bi_buf);  	bi_buf = (short)(SupportClass.URShift (bi_buf' 8));  	bi_valid -= 8;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	put_short (bi_buf);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	put_byte ((byte)bi_buf);  	bi_buf = (short)(SupportClass.URShift (bi_buf' 8));  	bi_valid -= 8;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	put_short (bi_buf);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	put_byte ((byte)bi_buf);  	bi_buf = (short)(SupportClass.URShift (bi_buf' 8));  	bi_valid -= 8;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid == 16) {  	put_short (bi_buf);  	bi_buf = 0;  	bi_valid = 0;  }  else if (bi_valid >= 8) {  	put_byte ((byte)bi_buf);  	bi_buf = (short)(SupportClass.URShift (bi_buf' 8));  	bi_valid -= 8;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid >= 8) {  	put_byte ((byte)bi_buf);  	bi_buf = (short)(SupportClass.URShift (bi_buf' 8));  	bi_valid -= 8;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid >= 8) {  	put_byte ((byte)bi_buf);  	bi_buf = (short)(SupportClass.URShift (bi_buf' 8));  	bi_valid -= 8;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: if (bi_valid >= 8) {  	put_byte ((byte)bi_buf);  	bi_buf = (short)(SupportClass.URShift (bi_buf' 8));  	bi_valid -= 8;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: bi_buf = (short)(SupportClass.URShift (bi_buf' 8));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: bi_valid -= 8;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,bi_windup,The following statement contains a magic number: if (bi_valid > 8) {  	put_short (bi_buf);  }  else if (bi_valid > 0) {  	put_byte ((byte)bi_buf);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5) {  	max_block_size = pending_buf_size - 5;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: if (max_block_size > pending_buf_size - 5) {  	max_block_size = pending_buf_size - 5;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: max_block_size = pending_buf_size - 5;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits ((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	l_desc.build_tree (this);  	d_desc.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  	static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	l_desc.build_tree (this);  	d_desc.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  	static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	l_desc.build_tree (this);  	d_desc.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  	static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	l_desc.build_tree (this);  	d_desc.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  	static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	l_desc.build_tree (this);  	d_desc.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  	static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	l_desc.build_tree (this);  	d_desc.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  	static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (level > 0) {  	// Check if the file is ascii or binary  	if (data_type == Z_UNKNOWN)  		set_data_type ();  	// Construct the literal and distance trees  	l_desc.build_tree (this);  	d_desc.build_tree (this);  	// At this point' opt_len and static_len are the total bit lengths of  	// the compressed block data' excluding the tree representations.  	// Build the bit length tree for the above two trees' and get the index  	// in bl_order of the last bit length code to send.  	max_blindex = build_bl_tree ();  	// Determine the best encoding. Compute first the block length in bytes  	opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  	static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  	if (static_lenb <= opt_lenb)  		opt_lenb = static_lenb;  }  else {  	opt_lenb = static_lenb = stored_len + 5;  	// force a stored block  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift ((opt_len + 3 + 7)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift ((static_len + 3 + 7)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = static_lenb = stored_len + 5;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1) {  	// 4: two words for the lengths  	// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  	// Otherwise we can't have processed more than WSIZE input bytes since  	// the last block flush' because compression would have been  	// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  	// transform a block into a stored block.  	_tr_stored_block (buf' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (StaticTree.static_ltree' StaticTree.static_dtree);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  	compress_block (dyn_ltree' dyn_dtree);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1) {  	// 4: two words for the lengths  	// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  	// Otherwise we can't have processed more than WSIZE input bytes since  	// the last block flush' because compression would have been  	// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  	// transform a block into a stored block.  	_tr_stored_block (buf' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (StaticTree.static_ltree' StaticTree.static_dtree);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  	compress_block (dyn_ltree' dyn_dtree);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (stored_len + 4 <= opt_lenb && buf != -1) {  	// 4: two words for the lengths  	// The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.  	// Otherwise we can't have processed more than WSIZE input bytes since  	// the last block flush' because compression would have been  	// successful. If LIT_BUFSIZE <= WSIZE' it is never too late to  	// transform a block into a stored block.  	_tr_stored_block (buf' stored_len' eof);  }  else if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (StaticTree.static_ltree' StaticTree.static_dtree);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  	compress_block (dyn_ltree' dyn_dtree);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (StaticTree.static_ltree' StaticTree.static_dtree);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  	compress_block (dyn_ltree' dyn_dtree);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: if (static_lenb == opt_lenb) {  	send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  	compress_block (StaticTree.static_ltree' StaticTree.static_dtree);  }  else {  	send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  	send_all_trees (l_desc.max_code + 1' d_desc.max_code + 1' max_blindex + 1);  	compress_block (dyn_ltree' dyn_dtree);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: send_bits ((STATIC_TREES << 1) + (eof ? 1 : 0)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: send_bits ((DYN_TREES << 1) + (eof ? 1 : 0)' 3);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true) {  	// Make sure that we always have enough lookahead' except  	// at the end of the input file. We need MAX_MATCH bytes  	// for the next match' plus MIN_MATCH bytes to insert the  	// string following the next match.  	if (lookahead < MIN_LOOKAHEAD) {  		fill_window ();  		if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {  			return NeedMore;  		}  		if (lookahead == 0)  			break;  		// flush the current block  	}  	// Insert the string window[strstart .. strstart+2] in the  	// dictionary' and set hash_head to the head of the hash chain:  	if (lookahead >= MIN_MATCH) {  		ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  		//	prev[strstart&w_mask]=hash_head=head[ins_h];  		hash_head = (head [ins_h] & 0xffff);  		prev [strstart & w_mask] = head [ins_h];  		head [ins_h] = (short)strstart;  	}  	// Find the longest match' discarding those <= prev_length.  	prev_length = match_length;  	prev_match = match_start;  	match_length = MIN_MATCH - 1;  	if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  		// To simplify the code' we prevent matches with the string  		// of window index 0 (in particular we have to avoid a match  		// of the string with itself at the start of the input file).  		if (strategy != Z_HUFFMAN_ONLY) {  			match_length = longest_match (hash_head);  		}  		// longest_match() sets match_start  		if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  			// If prev_match is also MIN_MATCH' match_start is garbage  			// but we will ignore the current match anyway.  			match_length = MIN_MATCH - 1;  		}  	}  	// If there was a match at the previous step and the current  	// match is not better' output the previous match:  	if (prev_length >= MIN_MATCH && match_length <= prev_length) {  		var max_insert = strstart + lookahead - MIN_MATCH;  		// Do not insert strings in hash table beyond this.  		//          check_match(strstart-1' prev_match' prev_length);  		bflush = _tr_tally (strstart - 1 - prev_match' prev_length - MIN_MATCH);  		// Insert in hash table all strings up to the end of the match.  		// strstart-1 and strstart are already inserted. If there is not  		// enough lookahead' the last two strings are not inserted in  		// the hash table.  		lookahead -= (prev_length - 1);  		prev_length -= 2;  		do {  			if (++strstart <= max_insert) {  				ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  				//prev[strstart&w_mask]=hash_head=head[ins_h];  				hash_head = (head [ins_h] & 0xffff);  				prev [strstart & w_mask] = head [ins_h];  				head [ins_h] = (short)strstart;  			}  		}  		while (--prev_length != 0);  		match_available = 0;  		match_length = MIN_MATCH - 1;  		strstart++;  		if (bflush) {  			flush_block_only (false);  			if (strm.avail_out == 0)  				return NeedMore;  		}  	}  	else if (match_available != 0) {  		// If there was no match at the previous position' output a  		// single literal. If there was a match but the current match  		// is longer' truncate the previous match to a single literal.  		bflush = _tr_tally (0' window [strstart - 1] & 0xff);  		if (bflush) {  			flush_block_only (false);  		}  		strstart++;  		lookahead--;  		if (strm.avail_out == 0)  			return NeedMore;  	}  	else {  		// There is no previous match to compare with' wait for  		// the next step to decide.  		match_available = 1;  		strstart++;  		lookahead--;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true) {  	// Make sure that we always have enough lookahead' except  	// at the end of the input file. We need MAX_MATCH bytes  	// for the next match' plus MIN_MATCH bytes to insert the  	// string following the next match.  	if (lookahead < MIN_LOOKAHEAD) {  		fill_window ();  		if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {  			return NeedMore;  		}  		if (lookahead == 0)  			break;  		// flush the current block  	}  	// Insert the string window[strstart .. strstart+2] in the  	// dictionary' and set hash_head to the head of the hash chain:  	if (lookahead >= MIN_MATCH) {  		ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  		//	prev[strstart&w_mask]=hash_head=head[ins_h];  		hash_head = (head [ins_h] & 0xffff);  		prev [strstart & w_mask] = head [ins_h];  		head [ins_h] = (short)strstart;  	}  	// Find the longest match' discarding those <= prev_length.  	prev_length = match_length;  	prev_match = match_start;  	match_length = MIN_MATCH - 1;  	if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  		// To simplify the code' we prevent matches with the string  		// of window index 0 (in particular we have to avoid a match  		// of the string with itself at the start of the input file).  		if (strategy != Z_HUFFMAN_ONLY) {  			match_length = longest_match (hash_head);  		}  		// longest_match() sets match_start  		if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  			// If prev_match is also MIN_MATCH' match_start is garbage  			// but we will ignore the current match anyway.  			match_length = MIN_MATCH - 1;  		}  	}  	// If there was a match at the previous step and the current  	// match is not better' output the previous match:  	if (prev_length >= MIN_MATCH && match_length <= prev_length) {  		var max_insert = strstart + lookahead - MIN_MATCH;  		// Do not insert strings in hash table beyond this.  		//          check_match(strstart-1' prev_match' prev_length);  		bflush = _tr_tally (strstart - 1 - prev_match' prev_length - MIN_MATCH);  		// Insert in hash table all strings up to the end of the match.  		// strstart-1 and strstart are already inserted. If there is not  		// enough lookahead' the last two strings are not inserted in  		// the hash table.  		lookahead -= (prev_length - 1);  		prev_length -= 2;  		do {  			if (++strstart <= max_insert) {  				ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  				//prev[strstart&w_mask]=hash_head=head[ins_h];  				hash_head = (head [ins_h] & 0xffff);  				prev [strstart & w_mask] = head [ins_h];  				head [ins_h] = (short)strstart;  			}  		}  		while (--prev_length != 0);  		match_available = 0;  		match_length = MIN_MATCH - 1;  		strstart++;  		if (bflush) {  			flush_block_only (false);  			if (strm.avail_out == 0)  				return NeedMore;  		}  	}  	else if (match_available != 0) {  		// If there was no match at the previous position' output a  		// single literal. If there was a match but the current match  		// is longer' truncate the previous match to a single literal.  		bflush = _tr_tally (0' window [strstart - 1] & 0xff);  		if (bflush) {  			flush_block_only (false);  		}  		strstart++;  		lookahead--;  		if (strm.avail_out == 0)  			return NeedMore;  	}  	else {  		// There is no previous match to compare with' wait for  		// the next step to decide.  		match_available = 1;  		strstart++;  		lookahead--;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: while (true) {  	// Make sure that we always have enough lookahead' except  	// at the end of the input file. We need MAX_MATCH bytes  	// for the next match' plus MIN_MATCH bytes to insert the  	// string following the next match.  	if (lookahead < MIN_LOOKAHEAD) {  		fill_window ();  		if (lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {  			return NeedMore;  		}  		if (lookahead == 0)  			break;  		// flush the current block  	}  	// Insert the string window[strstart .. strstart+2] in the  	// dictionary' and set hash_head to the head of the hash chain:  	if (lookahead >= MIN_MATCH) {  		ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  		//	prev[strstart&w_mask]=hash_head=head[ins_h];  		hash_head = (head [ins_h] & 0xffff);  		prev [strstart & w_mask] = head [ins_h];  		head [ins_h] = (short)strstart;  	}  	// Find the longest match' discarding those <= prev_length.  	prev_length = match_length;  	prev_match = match_start;  	match_length = MIN_MATCH - 1;  	if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  		// To simplify the code' we prevent matches with the string  		// of window index 0 (in particular we have to avoid a match  		// of the string with itself at the start of the input file).  		if (strategy != Z_HUFFMAN_ONLY) {  			match_length = longest_match (hash_head);  		}  		// longest_match() sets match_start  		if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  			// If prev_match is also MIN_MATCH' match_start is garbage  			// but we will ignore the current match anyway.  			match_length = MIN_MATCH - 1;  		}  	}  	// If there was a match at the previous step and the current  	// match is not better' output the previous match:  	if (prev_length >= MIN_MATCH && match_length <= prev_length) {  		var max_insert = strstart + lookahead - MIN_MATCH;  		// Do not insert strings in hash table beyond this.  		//          check_match(strstart-1' prev_match' prev_length);  		bflush = _tr_tally (strstart - 1 - prev_match' prev_length - MIN_MATCH);  		// Insert in hash table all strings up to the end of the match.  		// strstart-1 and strstart are already inserted. If there is not  		// enough lookahead' the last two strings are not inserted in  		// the hash table.  		lookahead -= (prev_length - 1);  		prev_length -= 2;  		do {  			if (++strstart <= max_insert) {  				ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  				//prev[strstart&w_mask]=hash_head=head[ins_h];  				hash_head = (head [ins_h] & 0xffff);  				prev [strstart & w_mask] = head [ins_h];  				head [ins_h] = (short)strstart;  			}  		}  		while (--prev_length != 0);  		match_available = 0;  		match_length = MIN_MATCH - 1;  		strstart++;  		if (bflush) {  			flush_block_only (false);  			if (strm.avail_out == 0)  				return NeedMore;  		}  	}  	else if (match_available != 0) {  		// If there was no match at the previous position' output a  		// single literal. If there was a match but the current match  		// is longer' truncate the previous match to a single literal.  		bflush = _tr_tally (0' window [strstart - 1] & 0xff);  		if (bflush) {  			flush_block_only (false);  		}  		strstart++;  		lookahead--;  		if (strm.avail_out == 0)  			return NeedMore;  	}  	else {  		// There is no previous match to compare with' wait for  		// the next step to decide.  		match_available = 1;  		strstart++;  		lookahead--;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  	// To simplify the code' we prevent matches with the string  	// of window index 0 (in particular we have to avoid a match  	// of the string with itself at the start of the input file).  	if (strategy != Z_HUFFMAN_ONLY) {  		match_length = longest_match (hash_head);  	}  	// longest_match() sets match_start  	if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  		// If prev_match is also MIN_MATCH' match_start is garbage  		// but we will ignore the current match anyway.  		match_length = MIN_MATCH - 1;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: if (hash_head != 0 && prev_length < max_lazy_match && ((strstart - hash_head) & 0xffff) <= w_size - MIN_LOOKAHEAD) {  	// To simplify the code' we prevent matches with the string  	// of window index 0 (in particular we have to avoid a match  	// of the string with itself at the start of the input file).  	if (strategy != Z_HUFFMAN_ONLY) {  		match_length = longest_match (hash_head);  	}  	// longest_match() sets match_start  	if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  		// If prev_match is also MIN_MATCH' match_start is garbage  		// but we will ignore the current match anyway.  		match_length = MIN_MATCH - 1;  	}  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  	// If prev_match is also MIN_MATCH' match_start is garbage  	// but we will ignore the current match anyway.  	match_length = MIN_MATCH - 1;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: if (match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))) {  	// If prev_match is also MIN_MATCH' match_start is garbage  	// but we will ignore the current match anyway.  	match_length = MIN_MATCH - 1;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: if (prev_length >= MIN_MATCH && match_length <= prev_length) {  	var max_insert = strstart + lookahead - MIN_MATCH;  	// Do not insert strings in hash table beyond this.  	//          check_match(strstart-1' prev_match' prev_length);  	bflush = _tr_tally (strstart - 1 - prev_match' prev_length - MIN_MATCH);  	// Insert in hash table all strings up to the end of the match.  	// strstart-1 and strstart are already inserted. If there is not  	// enough lookahead' the last two strings are not inserted in  	// the hash table.  	lookahead -= (prev_length - 1);  	prev_length -= 2;  	do {  		if (++strstart <= max_insert) {  			ins_h = (((ins_h) << hash_shift) ^ (window [(strstart) + (MIN_MATCH - 1)] & 0xff)) & hash_mask;  			//prev[strstart&w_mask]=hash_head=head[ins_h];  			hash_head = (head [ins_h] & 0xffff);  			prev [strstart & w_mask] = head [ins_h];  			head [ins_h] = (short)strstart;  		}  	}  	while (--prev_length != 0);  	match_available = 0;  	match_length = MIN_MATCH - 1;  	strstart++;  	if (bflush) {  		flush_block_only (false);  		if (strm.avail_out == 0)  			return NeedMore;  	}  }  else if (match_available != 0) {  	// If there was no match at the previous position' output a  	// single literal. If there was a match but the current match  	// is longer' truncate the previous match to a single literal.  	bflush = _tr_tally (0' window [strstart - 1] & 0xff);  	if (bflush) {  		flush_block_only (false);  	}  	strstart++;  	lookahead--;  	if (strm.avail_out == 0)  		return NeedMore;  }  else {  	// There is no previous match to compare with' wait for  	// the next step to decide.  	match_available = 1;  	strstart++;  	lookahead--;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: prev_length -= 2;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,The following statement contains a magic number: if (prev_length >= good_match) {  	chain_length >>= 2;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,The following statement contains a magic number: do {  	match = cur_match;  	// Skip to next match if the match length cannot increase  	// or if the match length is less than 2:  	if (window [match + best_len] != scan_end || window [match + best_len - 1] != scan_end1 || window [match] != window [scan] || window [++match] != window [scan + 1])  		continue;  	// The check at best_len-1 can be removed because it will be made  	// again later. (This heuristic is not always a win.)  	// It is not necessary to compare scan[2] and match[2] since they  	// are always equal when the other bytes match' given that  	// the hash keys are equal and that HASH_BITS >= 8.  	scan += 2;  	match++;  	// We check for insufficient lookahead only every 8th comparison;  	// the 256th check will be made at strstart+258.  	do {  	}  	while (window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && window [++scan] == window [++match] && scan < strend);  	len = MAX_MATCH - (int)(strend - scan);  	scan = strend - MAX_MATCH;  	if (len > best_len) {  		match_start = cur_match;  		best_len = len;  		if (len >= nice_match)  			break;  		scan_end1 = window [scan + best_len - 1];  		scan_end = window [scan + best_len];  	}  }  while ((cur_match = (prev [cur_match & wmask] & 0xffff)) > limit && --chain_length != 0);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,longest_match,The following statement contains a magic number: scan += 2;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (level == Z_DEFAULT_COMPRESSION)  	level = 6;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: level = 6;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: d_buf = lit_bufsize / 2;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level == Z_DEFAULT_COMPRESSION) {  	_level = 6;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: _level = 6;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: if (_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY) {  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (status == INIT_STATE) {  	var header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;  	var level_flags = ((level - 1) & 0xff) >> 1;  	if (level_flags > 3)  		level_flags = 3;  	header |= (level_flags << 6);  	if (strstart != 0)  		header |= PRESET_DICT;  	header += 31 - (header % 31);  	status = BUSY_STATE;  	putShortMSB (header);  	// Save the adler32 of the preset dictionary:  	if (strstart != 0) {  		putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  		putShortMSB ((int)(strm.adler & 0xffff));  	}  	strm.adler = strm._adler.adler32 (0' null' 0' 0);  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (level_flags > 3)  	level_flags = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (level_flags > 3)  	level_flags = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: level_flags = 3;  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: header |= (level_flags << 6);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: if (strstart != 0) {  	putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  	putShortMSB ((int)(strm.adler & 0xffff));  }  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB ((int)(SupportClass.URShift (strm.adler' 16)));  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table = new Config[10];  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [1] = new Config (4' 4' 8' 4' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [1] = new Config (4' 4' 8' 4' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [1] = new Config (4' 4' 8' 4' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [1] = new Config (4' 4' 8' 4' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [2] = new Config (4' 5' 16' 8' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [2] = new Config (4' 5' 16' 8' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [2] = new Config (4' 5' 16' 8' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [2] = new Config (4' 5' 16' 8' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [2] = new Config (4' 5' 16' 8' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [3] = new Config (4' 6' 32' 32' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [3] = new Config (4' 6' 32' 32' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [3] = new Config (4' 6' 32' 32' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [3] = new Config (4' 6' 32' 32' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [3] = new Config (4' 6' 32' 32' FAST);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [4] = new Config (4' 4' 16' 16' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [4] = new Config (4' 4' 16' 16' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [4] = new Config (4' 4' 16' 16' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [4] = new Config (4' 4' 16' 16' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [4] = new Config (4' 4' 16' 16' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [5] = new Config (8' 16' 32' 32' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [5] = new Config (8' 16' 32' 32' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [5] = new Config (8' 16' 32' 32' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [5] = new Config (8' 16' 32' 32' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [5] = new Config (8' 16' 32' 32' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [6] = new Config (8' 16' 128' 128' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [6] = new Config (8' 16' 128' 128' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [6] = new Config (8' 16' 128' 128' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [6] = new Config (8' 16' 128' 128' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [6] = new Config (8' 16' 128' 128' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [7] = new Config (8' 32' 128' 256' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [7] = new Config (8' 32' 128' 256' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [7] = new Config (8' 32' 128' 256' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [7] = new Config (8' 32' 128' 256' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [7] = new Config (8' 32' 128' 256' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [8] = new Config (32' 128' 258' 1024' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [8] = new Config (32' 128' 258' 1024' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [8] = new Config (32' 128' 258' 1024' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [8] = new Config (32' 128' 258' 1024' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [8] = new Config (32' 128' 258' 1024' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [9] = new Config (32' 258' 258' 4096' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [9] = new Config (32' 258' 258' 4096' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [9] = new Config (32' 258' 258' 4096' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [9] = new Config (32' 258' 258' 4096' SLOW);  
Magic Number,zlib,Deflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table [9] = new Config (32' 258' 258' 4096' SLOW);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	case TYPE:  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = (int)(b & 7);  		last = t & 1;  		switch (SupportClass.URShift (t' 1)) {  		case 0:  			// stored   			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			t = k & 7;  			// go to byte boundary  			{  				b = SupportClass.URShift (b' (t));  				k -= (t);  			}  			mode = LENS;  			// get length of stored block  			break;  		case 1:  			// fixed  			{  				var bl = new int[1];  				var bd = new int[1];  				var tl = new int[1][];  				var td = new int[1][];  				InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  				codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  			}  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = CODES;  			break;  		case 2:  			// dynamic  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = TABLE;  			break;  		case 3:  			// illegal  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  			mode = BAD;  			z.msg = "invalid block type";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		break;  	case LENS:  		while (k < (32)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  			mode = BAD;  			z.msg = "invalid stored block lengths";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		left = (b & 0xffff);  		b = k = 0;  		// dump bits  		mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  		break;  	case STORED:  		if (n == 0) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		if (m == 0) {  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				write = q;  				r = inflate_flush (z' r);  				q = write;  				m = (int)(q < read ? read - q - 1 : end - q);  				if (q == end && read != 0) {  					q = 0;  					m = (int)(q < read ? read - q - 1 : end - q);  				}  				if (m == 0) {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		t = left;  		if (t > n)  			t = n;  		if (t > m)  			t = m;  		Array.Copy (z.next_in' p' window' q' t);  		p += t;  		n -= t;  		q += t;  		m -= t;  		if ((left -= t) != 0)  			break;  		mode = last != 0 ? DRY : TYPE;  		break;  	case TABLE:  		while (k < (14)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		table = t = (b & 0x3fff);  		if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  			mode = BAD;  			z.msg = "too many length or distance symbols";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  		blens = new int[t];  		{  			b = SupportClass.URShift (b' (14));  			k -= (14);  		}  		index = 0;  		mode = BTREE;  		goto case BTREE;  	case BTREE:  		while (index < 4 + (SupportClass.URShift (table' 10))) {  			while (k < (3)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			blens [border [index++]] = b & 7;  			{  				b = SupportClass.URShift (b' (3));  				k -= (3);  			}  		}  		while (index < 19) {  			blens [border [index++]] = 0;  		}  		bb [0] = 7;  		t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  		if (t != Z_OK) {  			r = t;  			if (r == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		index = 0;  		mode = DTREE;  		goto case DTREE;  	case DTREE:  		while (true) {  			t = table;  			if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  				break;  			}  			int i' j' c;  			t = bb [0];  			while (k < (t)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			if (tb [0] == -1) {  				//System.err.println("null...");  			}  			t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  			c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  			if (c < 16) {  				b = SupportClass.URShift (b' (t));  				k -= (t);  				blens [index++] = c;  			}  			else {  				// c == 16..18  				i = c == 18 ? 7 : c - 14;  				j = c == 18 ? 11 : 3;  				while (k < (t + i)) {  					if (n != 0) {  						r = Z_OK;  					}  					else {  						bitb = b;  						bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						write = q;  						return inflate_flush (z' r);  					}  					;  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				b = SupportClass.URShift (b' (t));  				k -= (t);  				j += (b & inflate_mask [i]);  				b = SupportClass.URShift (b' (i));  				k -= (i);  				i = index;  				t = table;  				if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  					blens = null;  					mode = BAD;  					z.msg = "invalid bit length repeat";  					r = Z_DATA_ERROR;  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				c = c == 16 ? blens [i - 1] : 0;  				do {  					blens [i++] = c;  				}  				while (--j != 0);  				index = i;  			}  		}  		tb [0] = -1;  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1];  			var td = new int[1];  			bl [0] = 9;  			// must be <= 9 for lookahead assumptions  			bd [0] = 6;  			// must be <= 9 for lookahead assumptions  			t = table;  			t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  			if (t != Z_OK) {  				if (t == Z_DATA_ERROR) {  					blens = null;  					mode = BAD;  				}  				r = t;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  		}  		blens = null;  		mode = CODES;  		goto case CODES;  	case CODES:  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  			return inflate_flush (z' r);  		}  		r = Z_OK;  		codes.free (z);  		p = z.next_in_index;  		n = z.avail_in;  		b = bitb;  		k = bitk;  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (last == 0) {  			mode = TYPE;  			break;  		}  		mode = DRY;  		goto case DRY;  	case DRY:  		write = q;  		r = inflate_flush (z' r);  		q = write;  		m = (int)(q < read ? read - q - 1 : end - q);  		if (read != write) {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		mode = DONE;  		goto case DONE;  	case DONE:  		r = Z_STREAM_END;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	case BAD:  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode) {  case TYPE:  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = (int)(b & 7);  	last = t & 1;  	switch (SupportClass.URShift (t' 1)) {  	case 0:  		// stored   		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		t = k & 7;  		// go to byte boundary  		{  			b = SupportClass.URShift (b' (t));  			k -= (t);  		}  		mode = LENS;  		// get length of stored block  		break;  	case 1:  		// fixed  		{  			var bl = new int[1];  			var bd = new int[1];  			var tl = new int[1][];  			var td = new int[1][];  			InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  			codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  		}  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = CODES;  		break;  	case 2:  		// dynamic  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = TABLE;  		break;  	case 3:  		// illegal  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  		mode = BAD;  		z.msg = "invalid block type";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	break;  case LENS:  	while (k < (32)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  		mode = BAD;  		z.msg = "invalid stored block lengths";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	left = (b & 0xffff);  	b = k = 0;  	// dump bits  	mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);  	break;  case STORED:  	if (n == 0) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	if (m == 0) {  		if (q == end && read != 0) {  			q = 0;  			m = (int)(q < read ? read - q - 1 : end - q);  		}  		if (m == 0) {  			write = q;  			r = inflate_flush (z' r);  			q = write;  			m = (int)(q < read ? read - q - 1 : end - q);  			if (q == end && read != 0) {  				q = 0;  				m = (int)(q < read ? read - q - 1 : end - q);  			}  			if (m == 0) {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	t = left;  	if (t > n)  		t = n;  	if (t > m)  		t = m;  	Array.Copy (z.next_in' p' window' q' t);  	p += t;  	n -= t;  	q += t;  	m -= t;  	if ((left -= t) != 0)  		break;  	mode = last != 0 ? DRY : TYPE;  	break;  case TABLE:  	while (k < (14)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	table = t = (b & 0x3fff);  	if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  		mode = BAD;  		z.msg = "too many length or distance symbols";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  	blens = new int[t];  	{  		b = SupportClass.URShift (b' (14));  		k -= (14);  	}  	index = 0;  	mode = BTREE;  	goto case BTREE;  case BTREE:  	while (index < 4 + (SupportClass.URShift (table' 10))) {  		while (k < (3)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		blens [border [index++]] = b & 7;  		{  			b = SupportClass.URShift (b' (3));  			k -= (3);  		}  	}  	while (index < 19) {  		blens [border [index++]] = 0;  	}  	bb [0] = 7;  	t = InfTree.inflate_trees_bits (blens' bb' tb' hufts' z);  	if (t != Z_OK) {  		r = t;  		if (r == Z_DATA_ERROR) {  			blens = null;  			mode = BAD;  		}  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	index = 0;  	mode = DTREE;  	goto case DTREE;  case DTREE:  	while (true) {  		t = table;  		if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  			break;  		}  		int i' j' c;  		t = bb [0];  		while (k < (t)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		if (tb [0] == -1) {  			//System.err.println("null...");  		}  		t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  		c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  		if (c < 16) {  			b = SupportClass.URShift (b' (t));  			k -= (t);  			blens [index++] = c;  		}  		else {  			// c == 16..18  			i = c == 18 ? 7 : c - 14;  			j = c == 18 ? 11 : 3;  			while (k < (t + i)) {  				if (n != 0) {  					r = Z_OK;  				}  				else {  					bitb = b;  					bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					write = q;  					return inflate_flush (z' r);  				}  				;  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			b = SupportClass.URShift (b' (t));  			k -= (t);  			j += (b & inflate_mask [i]);  			b = SupportClass.URShift (b' (i));  			k -= (i);  			i = index;  			t = table;  			if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  				blens = null;  				mode = BAD;  				z.msg = "invalid bit length repeat";  				r = Z_DATA_ERROR;  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			c = c == 16 ? blens [i - 1] : 0;  			do {  				blens [i++] = c;  			}  			while (--j != 0);  			index = i;  		}  	}  	tb [0] = -1;  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1];  		var td = new int[1];  		bl [0] = 9;  		// must be <= 9 for lookahead assumptions  		bd [0] = 6;  		// must be <= 9 for lookahead assumptions  		t = table;  		t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  		if (t != Z_OK) {  			if (t == Z_DATA_ERROR) {  				blens = null;  				mode = BAD;  			}  			r = t;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		codes = new InfCodes (bl [0]' bd [0]' hufts' tl [0]' hufts' td [0]' z);  	}  	blens = null;  	mode = CODES;  	goto case CODES;  case CODES:  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	if ((r = codes.proc (this' z' r)) != Z_STREAM_END) {  		return inflate_flush (z' r);  	}  	r = Z_OK;  	codes.free (z);  	p = z.next_in_index;  	n = z.avail_in;  	b = bitb;  	k = bitk;  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (last == 0) {  		mode = TYPE;  		break;  	}  	mode = DRY;  	goto case DRY;  case DRY:  	write = q;  	r = inflate_flush (z' r);  	q = write;  	m = (int)(q < read ? read - q - 1 : end - q);  	if (read != write) {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	mode = DONE;  	goto case DONE;  case DONE:  	r = Z_STREAM_END;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  case BAD:  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = (int)(b & 7);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = k & 7;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (32)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (32)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (((SupportClass.URShift ((~b)' 16)) & 0xffff) != (b & 0xffff)) {  	mode = BAD;  	z.msg = "invalid stored block lengths";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (14)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (14)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = BAD;  	z.msg = "too many length or distance symbols";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = BAD;  	z.msg = "too many length or distance symbols";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {  	mode = BAD;  	z.msg = "too many length or distance symbols";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (14));  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (14);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 4 + (SupportClass.URShift (table' 10))) {  	while (k < (3)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	blens [border [index++]] = b & 7;  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (3)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: blens [border [index++]] = b & 7;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: b = SupportClass.URShift (b' (3));  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k -= (3);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (index < 19) {  	blens [border [index++]] = 0;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: bb [0] = 7;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (true) {  	t = table;  	if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  		break;  	}  	int i' j' c;  	t = bb [0];  	while (k < (t)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	if (tb [0] == -1) {  		//System.err.println("null...");  	}  	t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  	c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  	if (c < 16) {  		b = SupportClass.URShift (b' (t));  		k -= (t);  		blens [index++] = c;  	}  	else {  		// c == 16..18  		i = c == 18 ? 7 : c - 14;  		j = c == 18 ? 11 : 3;  		while (k < (t + i)) {  			if (n != 0) {  				r = Z_OK;  			}  			else {  				bitb = b;  				bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				write = q;  				return inflate_flush (z' r);  			}  			;  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		b = SupportClass.URShift (b' (t));  		k -= (t);  		j += (b & inflate_mask [i]);  		b = SupportClass.URShift (b' (i));  		k -= (i);  		i = index;  		t = table;  		if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  			blens = null;  			mode = BAD;  			z.msg = "invalid bit length repeat";  			r = Z_DATA_ERROR;  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		c = c == 16 ? blens [i - 1] : 0;  		do {  			blens [i++] = c;  		}  		while (--j != 0);  		index = i;  	}  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  	break;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))) {  	break;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (t)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 1];  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: c = hufts [(tb [0] + (b & inflate_mask [t])) * 3 + 2];  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (c < 16) {  	b = SupportClass.URShift (b' (t));  	k -= (t);  	blens [index++] = c;  }  else {  	// c == 16..18  	i = c == 18 ? 7 : c - 14;  	j = c == 18 ? 11 : 3;  	while (k < (t + i)) {  		if (n != 0) {  			r = Z_OK;  		}  		else {  			bitb = b;  			bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			write = q;  			return inflate_flush (z' r);  		}  		;  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	b = SupportClass.URShift (b' (t));  	k -= (t);  	j += (b & inflate_mask [i]);  	b = SupportClass.URShift (b' (i));  	k -= (i);  	i = index;  	t = table;  	if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  		blens = null;  		mode = BAD;  		z.msg = "invalid bit length repeat";  		r = Z_DATA_ERROR;  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	c = c == 16 ? blens [i - 1] : 0;  	do {  		blens [i++] = c;  	}  	while (--j != 0);  	index = i;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: i = c == 18 ? 7 : c - 14;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: j = c == 18 ? 11 : 3;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: while (k < (t + i)) {  	if (n != 0) {  		r = Z_OK;  	}  	else {  		bitb = b;  		bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		write = q;  		return inflate_flush (z' r);  	}  	;  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = BAD;  	z.msg = "invalid bit length repeat";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = BAD;  	z.msg = "invalid bit length repeat";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {  	blens = null;  	mode = BAD;  	z.msg = "invalid bit length repeat";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: c = c == 16 ? blens [i - 1] : 0;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: bl [0] = 9;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: bd [0] = 6;  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  
Magic Number,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following statement contains a magic number: t = InfTree.inflate_trees_dynamic (257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (true) {  	switch (mode) {  	// waiting for "i:"=input' "o:"=output' "x:"=nothing  	case START:  		// x: set up for LEN  		if (m >= 258 && n >= 10) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  			p = z.next_in_index;  			n = z.avail_in;  			b = s.bitb;  			k = s.bitk;  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (r != Z_OK) {  				mode = r == Z_STREAM_END ? WASH : BADCODE;  				break;  			}  		}  		need = lbits;  		tree = ltree;  		tree_index = ltree_index;  		mode = LEN;  		goto case LEN;  	case LEN:  		// i: get length/literal/eob next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b = SupportClass.URShift (b' (tree [tindex + 1]));  		k -= (tree [tindex + 1]);  		e = tree [tindex];  		if (e == 0) {  			// literal  			lit = tree [tindex + 2];  			mode = LIT;  			break;  		}  		if ((e & 16) != 0) {  			// length  			get_Renamed = e & 15;  			len = tree [tindex + 2];  			mode = LENEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		if ((e & 32) != 0) {  			// end of block  			mode = WASH;  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid literal/length code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case LENEXT:  		// i: getting length extra (have base)  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		len += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		need = dbits;  		tree = dtree;  		tree_index = dtree_index;  		mode = DIST;  		goto case DIST;  	case DIST:  		// i: get distance next  		j = need;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		tindex = (tree_index + (b & inflate_mask [j])) * 3;  		b >>= tree [tindex + 1];  		k -= tree [tindex + 1];  		e = (tree [tindex]);  		if ((e & 16) != 0) {  			// distance  			get_Renamed = e & 15;  			dist = tree [tindex + 2];  			mode = DISTEXT;  			break;  		}  		if ((e & 64) == 0) {  			// next table  			need = e;  			tree_index = tindex / 3 + tree [tindex + 2];  			break;  		}  		mode = BADCODE;  		// invalid code  		z.msg = "invalid distance code";  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case DISTEXT:  		// i: getting distance extra  		j = get_Renamed;  		while (k < (j)) {  			if (n != 0)  				r = Z_OK;  			else {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		dist += (b & inflate_mask [j]);  		b >>= j;  		k -= j;  		mode = COPY;  		goto case COPY;  	case COPY:  		// o: copying bytes in window' waiting for space  		f = q - dist;  		while (f < 0) {  			// modulo window size-"while" instead  			f += s.end;  			// of "if" handles invalid distances  		}  		while (len != 0) {  			if (m == 0) {  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.write = q;  					r = s.inflate_flush (z' r);  					q = s.write;  					m = q < s.read ? s.read - q - 1 : s.end - q;  					if (q == s.end && s.read != 0) {  						q = 0;  						m = q < s.read ? s.read - q - 1 : s.end - q;  					}  					if (m == 0) {  						s.bitb = b;  						s.bitk = k;  						z.avail_in = n;  						z.total_in += p - z.next_in_index;  						z.next_in_index = p;  						s.write = q;  						return s.inflate_flush (z' r);  					}  				}  			}  			s.window [q++] = s.window [f++];  			m--;  			if (f == s.end)  				f = 0;  			len--;  		}  		mode = START;  		break;  	case LIT:  		// o: got literal' waiting for output space  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		r = Z_OK;  		s.window [q++] = (byte)lit;  		m--;  		mode = START;  		break;  	case WASH:  		// o: got eob' possibly more output  		if (k > 7) {  			// return unused byte' if any  			k -= 8;  			n++;  			p--;  			// can always return one  		}  		s.write = q;  		r = s.inflate_flush (z' r);  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (s.read != s.write) {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		mode = END;  		goto case END;  	case END:  		r = Z_STREAM_END;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	case BADCODE:  		// x: got error  		r = Z_DATA_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	default:  		r = Z_STREAM_ERROR;  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode) {  // waiting for "i:"=input' "o:"=output' "x:"=nothing  case START:  	// x: set up for LEN  	if (m >= 258 && n >= 10) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  		p = z.next_in_index;  		n = z.avail_in;  		b = s.bitb;  		k = s.bitk;  		q = s.write;  		m = q < s.read ? s.read - q - 1 : s.end - q;  		if (r != Z_OK) {  			mode = r == Z_STREAM_END ? WASH : BADCODE;  			break;  		}  	}  	need = lbits;  	tree = ltree;  	tree_index = ltree_index;  	mode = LEN;  	goto case LEN;  case LEN:  	// i: get length/literal/eob next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b = SupportClass.URShift (b' (tree [tindex + 1]));  	k -= (tree [tindex + 1]);  	e = tree [tindex];  	if (e == 0) {  		// literal  		lit = tree [tindex + 2];  		mode = LIT;  		break;  	}  	if ((e & 16) != 0) {  		// length  		get_Renamed = e & 15;  		len = tree [tindex + 2];  		mode = LENEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	if ((e & 32) != 0) {  		// end of block  		mode = WASH;  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid literal/length code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case LENEXT:  	// i: getting length extra (have base)  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	len += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	need = dbits;  	tree = dtree;  	tree_index = dtree_index;  	mode = DIST;  	goto case DIST;  case DIST:  	// i: get distance next  	j = need;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	tindex = (tree_index + (b & inflate_mask [j])) * 3;  	b >>= tree [tindex + 1];  	k -= tree [tindex + 1];  	e = (tree [tindex]);  	if ((e & 16) != 0) {  		// distance  		get_Renamed = e & 15;  		dist = tree [tindex + 2];  		mode = DISTEXT;  		break;  	}  	if ((e & 64) == 0) {  		// next table  		need = e;  		tree_index = tindex / 3 + tree [tindex + 2];  		break;  	}  	mode = BADCODE;  	// invalid code  	z.msg = "invalid distance code";  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case DISTEXT:  	// i: getting distance extra  	j = get_Renamed;  	while (k < (j)) {  		if (n != 0)  			r = Z_OK;  		else {  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return s.inflate_flush (z' r);  		}  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	dist += (b & inflate_mask [j]);  	b >>= j;  	k -= j;  	mode = COPY;  	goto case COPY;  case COPY:  	// o: copying bytes in window' waiting for space  	f = q - dist;  	while (f < 0) {  		// modulo window size-"while" instead  		f += s.end;  		// of "if" handles invalid distances  	}  	while (len != 0) {  		if (m == 0) {  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.write = q;  				r = s.inflate_flush (z' r);  				q = s.write;  				m = q < s.read ? s.read - q - 1 : s.end - q;  				if (q == s.end && s.read != 0) {  					q = 0;  					m = q < s.read ? s.read - q - 1 : s.end - q;  				}  				if (m == 0) {  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return s.inflate_flush (z' r);  				}  			}  		}  		s.window [q++] = s.window [f++];  		m--;  		if (f == s.end)  			f = 0;  		len--;  	}  	mode = START;  	break;  case LIT:  	// o: got literal' waiting for output space  	if (m == 0) {  		if (q == s.end && s.read != 0) {  			q = 0;  			m = q < s.read ? s.read - q - 1 : s.end - q;  		}  		if (m == 0) {  			s.write = q;  			r = s.inflate_flush (z' r);  			q = s.write;  			m = q < s.read ? s.read - q - 1 : s.end - q;  			if (q == s.end && s.read != 0) {  				q = 0;  				m = q < s.read ? s.read - q - 1 : s.end - q;  			}  			if (m == 0) {  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return s.inflate_flush (z' r);  			}  		}  	}  	r = Z_OK;  	s.window [q++] = (byte)lit;  	m--;  	mode = START;  	break;  case WASH:  	// o: got eob' possibly more output  	if (k > 7) {  		// return unused byte' if any  		k -= 8;  		n++;  		p--;  		// can always return one  	}  	s.write = q;  	r = s.inflate_flush (z' r);  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (s.read != s.write) {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	mode = END;  	goto case END;  case END:  	r = Z_STREAM_END;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  case BADCODE:  	// x: got error  	r = Z_DATA_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  default:  	r = Z_STREAM_ERROR;  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return s.inflate_flush (z' r);  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (m >= 258 && n >= 10) {  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  	p = z.next_in_index;  	n = z.avail_in;  	b = s.bitb;  	k = s.bitk;  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (r != Z_OK) {  		mode = r == Z_STREAM_END ? WASH : BADCODE;  		break;  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (m >= 258 && n >= 10) {  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	r = inflate_fast (lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);  	p = z.next_in_index;  	n = z.avail_in;  	b = s.bitb;  	k = s.bitk;  	q = s.write;  	m = q < s.read ? s.read - q - 1 : s.end - q;  	if (r != Z_OK) {  		mode = r == Z_STREAM_END ? WASH : BADCODE;  		break;  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (k < (j)) {  	if (n != 0)  		r = Z_OK;  	else {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: tindex = (tree_index + (b & inflate_mask [j])) * 3;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (e == 0) {  	// literal  	lit = tree [tindex + 2];  	mode = LIT;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: lit = tree [tindex + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	get_Renamed = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	get_Renamed = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// length  	get_Renamed = e & 15;  	len = tree [tindex + 2];  	mode = LENEXT;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: get_Renamed = e & 15;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: len = tree [tindex + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 32) != 0) {  	// end of block  	mode = WASH;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (k < (j)) {  	if (n != 0)  		r = Z_OK;  	else {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (k < (j)) {  	if (n != 0)  		r = Z_OK;  	else {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: tindex = (tree_index + (b & inflate_mask [j])) * 3;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// distance  	get_Renamed = e & 15;  	dist = tree [tindex + 2];  	mode = DISTEXT;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// distance  	get_Renamed = e & 15;  	dist = tree [tindex + 2];  	mode = DISTEXT;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 16) != 0) {  	// distance  	get_Renamed = e & 15;  	dist = tree [tindex + 2];  	mode = DISTEXT;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: get_Renamed = e & 15;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: dist = tree [tindex + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if ((e & 64) == 0) {  	// next table  	need = e;  	tree_index = tindex / 3 + tree [tindex + 2];  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: tree_index = tindex / 3 + tree [tindex + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: while (k < (j)) {  	if (n != 0)  		r = Z_OK;  	else {  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return s.inflate_flush (z' r);  	}  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (k > 7) {  	// return unused byte' if any  	k -= 8;  	n++;  	p--;  	// can always return one  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: if (k > 7) {  	// return unused byte' if any  	k -= 8;  	n++;  	p--;  	// can always return one  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The following statement contains a magic number: k -= 8;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	// assume called with m >= 258 && n >= 10  	// get literal/length code  	while (k < (20)) {  		// max bits for literal/length code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & ml;  	tp = tl;  	tp_index = tl_index;  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		continue;  	}  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			e &= 15;  			c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  			b >>= e;  			k -= e;  			// decode distance base of block to copy  			while (k < (15)) {  				// max bits for distance code  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			t = b & md;  			tp = td;  			tp_index = td_index;  			e = tp [(tp_index + t) * 3];  			do {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				if ((e & 16) != 0) {  					// get extra bits to add to distance base  					e &= 15;  					while (k < (e)) {  						// get extra bits (up to 13)  						n--;  						b |= (z.next_in [p++] & 0xff) << k;  						k += 8;  					}  					d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  					b >>= (e);  					k -= (e);  					// do the copy  					m -= c;  					if (q >= d) {  						// offset before dest  						//  just copy  						r = q - d;  						if (q - r > 0 && 2 > (q - r)) {  							s.window [q++] = s.window [r++];  							c--;  							// minimum count is three'  							s.window [q++] = s.window [r++];  							c--;  							// so unroll loop a little  						}  						else {  							Array.Copy (s.window' r' s.window' q' 2);  							q += 2;  							r += 2;  							c -= 2;  						}  					}  					else {  						// else offset after destination  						r = q - d;  						do {  							r += s.end;  							// force pointer in window  						}  						while (r < 0);  						// covers invalid distances  						e = s.end - r;  						if (c > e) {  							// if source crosses'  							c -= e;  							// wrapped copy  							if (q - r > 0 && e > (q - r)) {  								do {  									s.window [q++] = s.window [r++];  								}  								while (--e != 0);  							}  							else {  								Array.Copy (s.window' r' s.window' q' e);  								q += e;  								r += e;  								e = 0;  							}  							r = 0;  							// copy rest from start of window  						}  					}  					// copy all or what's left  					if (q - r > 0 && c > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--c != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' c);  						q += c;  						r += c;  						c = 0;  					}  					break;  				}  				else if ((e & 64) == 0) {  					t += tp [(tp_index + t) * 3 + 2];  					t += (b & inflate_mask [e]);  					e = tp [(tp_index + t) * 3];  				}  				else {  					z.msg = "invalid distance code";  					c = z.avail_in - n;  					c = (k >> 3) < c ? k >> 3 : c;  					n += c;  					p -= c;  					k -= (c << 3);  					s.bitb = b;  					s.bitk = k;  					z.avail_in = n;  					z.total_in += p - z.next_in_index;  					z.next_in_index = p;  					s.write = q;  					return Z_DATA_ERROR;  				}  			}  			while (true);  			break;  		}  		if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			if ((e = tp [(tp_index + t) * 3]) == 0) {  				b >>= (tp [(tp_index + t) * 3 + 1]);  				k -= (tp [(tp_index + t) * 3 + 1]);  				s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  				m--;  				break;  			}  		}  		else if ((e & 32) != 0) {  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_STREAM_END;  		}  		else {  			z.msg = "invalid literal/length code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  }  while (m >= 258 && n >= 10);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (20)) {  	// max bits for literal/length code  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (20)) {  	// max bits for literal/length code  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	continue;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		e &= 15;  		c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  		b >>= e;  		k -= e;  		// decode distance base of block to copy  		while (k < (15)) {  			// max bits for distance code  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		t = b & md;  		tp = td;  		tp_index = td_index;  		e = tp [(tp_index + t) * 3];  		do {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			if ((e & 16) != 0) {  				// get extra bits to add to distance base  				e &= 15;  				while (k < (e)) {  					// get extra bits (up to 13)  					n--;  					b |= (z.next_in [p++] & 0xff) << k;  					k += 8;  				}  				d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  				b >>= (e);  				k -= (e);  				// do the copy  				m -= c;  				if (q >= d) {  					// offset before dest  					//  just copy  					r = q - d;  					if (q - r > 0 && 2 > (q - r)) {  						s.window [q++] = s.window [r++];  						c--;  						// minimum count is three'  						s.window [q++] = s.window [r++];  						c--;  						// so unroll loop a little  					}  					else {  						Array.Copy (s.window' r' s.window' q' 2);  						q += 2;  						r += 2;  						c -= 2;  					}  				}  				else {  					// else offset after destination  					r = q - d;  					do {  						r += s.end;  						// force pointer in window  					}  					while (r < 0);  					// covers invalid distances  					e = s.end - r;  					if (c > e) {  						// if source crosses'  						c -= e;  						// wrapped copy  						if (q - r > 0 && e > (q - r)) {  							do {  								s.window [q++] = s.window [r++];  							}  							while (--e != 0);  						}  						else {  							Array.Copy (s.window' r' s.window' q' e);  							q += e;  							r += e;  							e = 0;  						}  						r = 0;  						// copy rest from start of window  					}  				}  				// copy all or what's left  				if (q - r > 0 && c > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--c != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' c);  					q += c;  					r += c;  					c = 0;  				}  				break;  			}  			else if ((e & 64) == 0) {  				t += tp [(tp_index + t) * 3 + 2];  				t += (b & inflate_mask [e]);  				e = tp [(tp_index + t) * 3];  			}  			else {  				z.msg = "invalid distance code";  				c = z.avail_in - n;  				c = (k >> 3) < c ? k >> 3 : c;  				n += c;  				p -= c;  				k -= (c << 3);  				s.bitb = b;  				s.bitk = k;  				z.avail_in = n;  				z.total_in += p - z.next_in_index;  				z.next_in_index = p;  				s.write = q;  				return Z_DATA_ERROR;  			}  		}  		while (true);  		break;  	}  	if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		if ((e = tp [(tp_index + t) * 3]) == 0) {  			b >>= (tp [(tp_index + t) * 3 + 1]);  			k -= (tp [(tp_index + t) * 3 + 1]);  			s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  			m--;  			break;  		}  	}  	else if ((e & 32) != 0) {  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_STREAM_END;  	}  	else {  		z.msg = "invalid literal/length code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	e &= 15;  	c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  	b >>= e;  	k -= e;  	// decode distance base of block to copy  	while (k < (15)) {  		// max bits for distance code  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	t = b & md;  	tp = td;  	tp_index = td_index;  	e = tp [(tp_index + t) * 3];  	do {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		if ((e & 16) != 0) {  			// get extra bits to add to distance base  			e &= 15;  			while (k < (e)) {  				// get extra bits (up to 13)  				n--;  				b |= (z.next_in [p++] & 0xff) << k;  				k += 8;  			}  			d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  			b >>= (e);  			k -= (e);  			// do the copy  			m -= c;  			if (q >= d) {  				// offset before dest  				//  just copy  				r = q - d;  				if (q - r > 0 && 2 > (q - r)) {  					s.window [q++] = s.window [r++];  					c--;  					// minimum count is three'  					s.window [q++] = s.window [r++];  					c--;  					// so unroll loop a little  				}  				else {  					Array.Copy (s.window' r' s.window' q' 2);  					q += 2;  					r += 2;  					c -= 2;  				}  			}  			else {  				// else offset after destination  				r = q - d;  				do {  					r += s.end;  					// force pointer in window  				}  				while (r < 0);  				// covers invalid distances  				e = s.end - r;  				if (c > e) {  					// if source crosses'  					c -= e;  					// wrapped copy  					if (q - r > 0 && e > (q - r)) {  						do {  							s.window [q++] = s.window [r++];  						}  						while (--e != 0);  					}  					else {  						Array.Copy (s.window' r' s.window' q' e);  						q += e;  						r += e;  						e = 0;  					}  					r = 0;  					// copy rest from start of window  				}  			}  			// copy all or what's left  			if (q - r > 0 && c > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--c != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' c);  				q += c;  				r += c;  				c = 0;  			}  			break;  		}  		else if ((e & 64) == 0) {  			t += tp [(tp_index + t) * 3 + 2];  			t += (b & inflate_mask [e]);  			e = tp [(tp_index + t) * 3];  		}  		else {  			z.msg = "invalid distance code";  			c = z.avail_in - n;  			c = (k >> 3) < c ? k >> 3 : c;  			n += c;  			p -= c;  			k -= (c << 3);  			s.bitb = b;  			s.bitk = k;  			z.avail_in = n;  			z.total_in += p - z.next_in_index;  			z.next_in_index = p;  			s.write = q;  			return Z_DATA_ERROR;  		}  	}  	while (true);  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp [(tp_index + t) * 3 + 2] + ((int)b & inflate_mask [e]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (15)) {  	// max bits for distance code  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (15)) {  	// max bits for distance code  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e = tp [(tp_index + t) * 3];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: do {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	if ((e & 16) != 0) {  		// get extra bits to add to distance base  		e &= 15;  		while (k < (e)) {  			// get extra bits (up to 13)  			n--;  			b |= (z.next_in [p++] & 0xff) << k;  			k += 8;  		}  		d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  		b >>= (e);  		k -= (e);  		// do the copy  		m -= c;  		if (q >= d) {  			// offset before dest  			//  just copy  			r = q - d;  			if (q - r > 0 && 2 > (q - r)) {  				s.window [q++] = s.window [r++];  				c--;  				// minimum count is three'  				s.window [q++] = s.window [r++];  				c--;  				// so unroll loop a little  			}  			else {  				Array.Copy (s.window' r' s.window' q' 2);  				q += 2;  				r += 2;  				c -= 2;  			}  		}  		else {  			// else offset after destination  			r = q - d;  			do {  				r += s.end;  				// force pointer in window  			}  			while (r < 0);  			// covers invalid distances  			e = s.end - r;  			if (c > e) {  				// if source crosses'  				c -= e;  				// wrapped copy  				if (q - r > 0 && e > (q - r)) {  					do {  						s.window [q++] = s.window [r++];  					}  					while (--e != 0);  				}  				else {  					Array.Copy (s.window' r' s.window' q' e);  					q += e;  					r += e;  					e = 0;  				}  				r = 0;  				// copy rest from start of window  			}  		}  		// copy all or what's left  		if (q - r > 0 && c > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--c != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' c);  			q += c;  			r += c;  			c = 0;  		}  		break;  	}  	else if ((e & 64) == 0) {  		t += tp [(tp_index + t) * 3 + 2];  		t += (b & inflate_mask [e]);  		e = tp [(tp_index + t) * 3];  	}  	else {  		z.msg = "invalid distance code";  		c = z.avail_in - n;  		c = (k >> 3) < c ? k >> 3 : c;  		n += c;  		p -= c;  		k -= (c << 3);  		s.bitb = b;  		s.bitk = k;  		z.avail_in = n;  		z.total_in += p - z.next_in_index;  		z.next_in_index = p;  		s.write = q;  		return Z_DATA_ERROR;  	}  }  while (true);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 16) != 0) {  	// get extra bits to add to distance base  	e &= 15;  	while (k < (e)) {  		// get extra bits (up to 13)  		n--;  		b |= (z.next_in [p++] & 0xff) << k;  		k += 8;  	}  	d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  	b >>= (e);  	k -= (e);  	// do the copy  	m -= c;  	if (q >= d) {  		// offset before dest  		//  just copy  		r = q - d;  		if (q - r > 0 && 2 > (q - r)) {  			s.window [q++] = s.window [r++];  			c--;  			// minimum count is three'  			s.window [q++] = s.window [r++];  			c--;  			// so unroll loop a little  		}  		else {  			Array.Copy (s.window' r' s.window' q' 2);  			q += 2;  			r += 2;  			c -= 2;  		}  	}  	else {  		// else offset after destination  		r = q - d;  		do {  			r += s.end;  			// force pointer in window  		}  		while (r < 0);  		// covers invalid distances  		e = s.end - r;  		if (c > e) {  			// if source crosses'  			c -= e;  			// wrapped copy  			if (q - r > 0 && e > (q - r)) {  				do {  					s.window [q++] = s.window [r++];  				}  				while (--e != 0);  			}  			else {  				Array.Copy (s.window' r' s.window' q' e);  				q += e;  				r += e;  				e = 0;  			}  			r = 0;  			// copy rest from start of window  		}  	}  	// copy all or what's left  	if (q - r > 0 && c > (q - r)) {  		do {  			s.window [q++] = s.window [r++];  		}  		while (--c != 0);  	}  	else {  		Array.Copy (s.window' r' s.window' q' c);  		q += c;  		r += c;  		c = 0;  	}  	break;  }  else if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: while (k < (e)) {  	// get extra bits (up to 13)  	n--;  	b |= (z.next_in [p++] & 0xff) << k;  	k += 8;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp [(tp_index + t) * 3 + 2] + (b & inflate_mask [e]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q >= d) {  	// offset before dest  	//  just copy  	r = q - d;  	if (q - r > 0 && 2 > (q - r)) {  		s.window [q++] = s.window [r++];  		c--;  		// minimum count is three'  		s.window [q++] = s.window [r++];  		c--;  		// so unroll loop a little  	}  	else {  		Array.Copy (s.window' r' s.window' q' 2);  		q += 2;  		r += 2;  		c -= 2;  	}  }  else {  	// else offset after destination  	r = q - d;  	do {  		r += s.end;  		// force pointer in window  	}  	while (r < 0);  	// covers invalid distances  	e = s.end - r;  	if (c > e) {  		// if source crosses'  		c -= e;  		// wrapped copy  		if (q - r > 0 && e > (q - r)) {  			do {  				s.window [q++] = s.window [r++];  			}  			while (--e != 0);  		}  		else {  			Array.Copy (s.window' r' s.window' q' e);  			q += e;  			r += e;  			e = 0;  		}  		r = 0;  		// copy rest from start of window  	}  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if (q - r > 0 && 2 > (q - r)) {  	s.window [q++] = s.window [r++];  	c--;  	// minimum count is three'  	s.window [q++] = s.window [r++];  	c--;  	// so unroll loop a little  }  else {  	Array.Copy (s.window' r' s.window' q' 2);  	q += 2;  	r += 2;  	c -= 2;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: Array.Copy (s.window' r' s.window' q' 2);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: q += 2;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: r += 2;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c -= 2;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	e = tp [(tp_index + t) * 3];  }  else {  	z.msg = "invalid distance code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp [(tp_index + t) * 3 + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp [(tp_index + t) * 3 + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e = tp [(tp_index + t) * 3];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 64) == 0) {  	t += tp [(tp_index + t) * 3 + 2];  	t += (b & inflate_mask [e]);  	if ((e = tp [(tp_index + t) * 3]) == 0) {  		b >>= (tp [(tp_index + t) * 3 + 1]);  		k -= (tp [(tp_index + t) * 3 + 1]);  		s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  		m--;  		break;  	}  }  else if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp [(tp_index + t) * 3 + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp [(tp_index + t) * 3 + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e = tp [(tp_index + t) * 3]) == 0) {  	b >>= (tp [(tp_index + t) * 3 + 1]);  	k -= (tp [(tp_index + t) * 3 + 1]);  	s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  	m--;  	break;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp [(tp_index + t) * 3 + 1]);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window [q++] = (byte)tp [(tp_index + t) * 3 + 2];  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: if ((e & 32) != 0) {  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_STREAM_END;  }  else {  	z.msg = "invalid literal/length code";  	c = z.avail_in - n;  	c = (k >> 3) < c ? k >> 3 : c;  	n += c;  	p -= c;  	k -= (c << 3);  	s.bitb = b;  	s.bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	s.write = q;  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;  
Magic Number,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15) {  	inflateEnd (z);  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: if (w < 8 || w > 15) {  	inflateEnd (z);  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: while (true) {  	//System.out.println("mode: "+z.istate.mode);  	switch (z.istate.mode) {  	case METHOD:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  			z.istate.mode = BAD;  			z.msg = "unknown compression method";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  			z.istate.mode = BAD;  			z.msg = "invalid window size";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = FLAG;  		goto case FLAG;  	case FLAG:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		b = (z.next_in [z.next_in_index++]) & 0xff;  		if ((((z.istate.method << 8) + b) % 31) != 0) {  			z.istate.mode = BAD;  			z.msg = "incorrect header check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		if ((b & PRESET_DICT) == 0) {  			z.istate.mode = BLOCKS;  			break;  		}  		z.istate.mode = DICT4;  		goto case DICT4;  	case DICT4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = DICT3;  		goto case DICT3;  	case DICT3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = DICT2;  		goto case DICT2;  	case DICT2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = DICT1;  		goto case DICT1;  	case DICT1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		z.adler = z.istate.need;  		z.istate.mode = DICT0;  		return Z_NEED_DICT;  	case DICT0:  		z.istate.mode = BAD;  		z.msg = "need dictionary";  		z.istate.marker = 0;  		// can try inflateSync  		return Z_STREAM_ERROR;  	case BLOCKS:  		r = z.istate.blocks.proc (z' r);  		if (r == Z_DATA_ERROR) {  			z.istate.mode = BAD;  			z.istate.marker = 0;  			// can try inflateSync  			break;  		}  		if (r == Z_OK) {  			r = f;  		}  		if (r != Z_STREAM_END) {  			return r;  		}  		r = f;  		z.istate.blocks.reset (z' z.istate.was);  		if (z.istate.nowrap != 0) {  			z.istate.mode = DONE;  			break;  		}  		z.istate.mode = CHECK4;  		goto case CHECK4;  	case CHECK4:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  		z.istate.mode = CHECK3;  		goto case CHECK3;  	case CHECK3:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  		z.istate.mode = CHECK2;  		goto case CHECK2;  	case CHECK2:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  		z.istate.mode = CHECK1;  		goto case CHECK1;  	case CHECK1:  		if (z.avail_in == 0)  			return r;  		r = f;  		z.avail_in--;  		z.total_in++;  		z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  		if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  			z.istate.mode = BAD;  			z.msg = "incorrect data check";  			z.istate.marker = 5;  			// can't try inflateSync  			break;  		}  		z.istate.mode = DONE;  		goto case DONE;  	case DONE:  		return Z_STREAM_END;  	case BAD:  		return Z_DATA_ERROR;  	default:  		return Z_STREAM_ERROR;  	}  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode) {  case METHOD:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  		z.istate.mode = BAD;  		z.msg = "unknown compression method";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  		z.istate.mode = BAD;  		z.msg = "invalid window size";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = FLAG;  	goto case FLAG;  case FLAG:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	b = (z.next_in [z.next_in_index++]) & 0xff;  	if ((((z.istate.method << 8) + b) % 31) != 0) {  		z.istate.mode = BAD;  		z.msg = "incorrect header check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	if ((b & PRESET_DICT) == 0) {  		z.istate.mode = BLOCKS;  		break;  	}  	z.istate.mode = DICT4;  	goto case DICT4;  case DICT4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = DICT3;  	goto case DICT3;  case DICT3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = DICT2;  	goto case DICT2;  case DICT2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = DICT1;  	goto case DICT1;  case DICT1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	z.adler = z.istate.need;  	z.istate.mode = DICT0;  	return Z_NEED_DICT;  case DICT0:  	z.istate.mode = BAD;  	z.msg = "need dictionary";  	z.istate.marker = 0;  	// can try inflateSync  	return Z_STREAM_ERROR;  case BLOCKS:  	r = z.istate.blocks.proc (z' r);  	if (r == Z_DATA_ERROR) {  		z.istate.mode = BAD;  		z.istate.marker = 0;  		// can try inflateSync  		break;  	}  	if (r == Z_OK) {  		r = f;  	}  	if (r != Z_STREAM_END) {  		return r;  	}  	r = f;  	z.istate.blocks.reset (z' z.istate.was);  	if (z.istate.nowrap != 0) {  		z.istate.mode = DONE;  		break;  	}  	z.istate.mode = CHECK4;  	goto case CHECK4;  case CHECK4:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  	z.istate.mode = CHECK3;  	goto case CHECK3;  case CHECK3:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  	z.istate.mode = CHECK2;  	goto case CHECK2;  case CHECK2:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  	z.istate.mode = CHECK1;  	goto case CHECK1;  case CHECK1:  	if (z.avail_in == 0)  		return r;  	r = f;  	z.avail_in--;  	z.total_in++;  	z.istate.need += (z.next_in [z.next_in_index++] & 0xffL);  	if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  		z.istate.mode = BAD;  		z.msg = "incorrect data check";  		z.istate.marker = 5;  		// can't try inflateSync  		break;  	}  	z.istate.mode = DONE;  	goto case DONE;  case DONE:  	return Z_STREAM_END;  case BAD:  	return Z_DATA_ERROR;  default:  	return Z_STREAM_ERROR;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: if (((z.istate.method = z.next_in [z.next_in_index++]) & 0xf) != Z_DEFLATED) {  	z.istate.mode = BAD;  	z.msg = "unknown compression method";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.marker = 5;  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  	z.istate.mode = BAD;  	z.msg = "invalid window size";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  	z.istate.mode = BAD;  	z.msg = "invalid window size";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((z.istate.method >> 4) + 8 > z.istate.wbits) {  	z.istate.mode = BAD;  	z.msg = "invalid window size";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.marker = 5;  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((((z.istate.method << 8) + b) % 31) != 0) {  	z.istate.mode = BAD;  	z.msg = "incorrect header check";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((((z.istate.method << 8) + b) % 31) != 0) {  	z.istate.mode = BAD;  	z.msg = "incorrect header check";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: if ((((z.istate.method << 8) + b) % 31) != 0) {  	z.istate.mode = BAD;  	z.msg = "incorrect header check";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.marker = 5;  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need = ((z.next_in [z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 16) & 0xff0000L);  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.need += (((z.next_in [z.next_in_index++] & 0xff) << 8) & 0xff00L);  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: if (((int)(z.istate.was [0])) != ((int)(z.istate.need))) {  	z.istate.mode = BAD;  	z.msg = "incorrect data check";  	z.istate.marker = 5;  	// can't try inflateSync  	break;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflate,The following statement contains a magic number: z.istate.marker = 5;  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4) {  	if (z.next_in [p] == mark [m]) {  		m++;  	}  	else if (z.next_in [p] != 0) {  		m = 0;  	}  	else {  		m = 4 - m;  	}  	p++;  	n--;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: while (n != 0 && m < 4) {  	if (z.next_in [p] == mark [m]) {  		m++;  	}  	else if (z.next_in [p] != 0) {  		m = 0;  	}  	else {  		m = 4 - m;  	}  	p++;  	n--;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (z.next_in [p] == mark [m]) {  	m++;  }  else if (z.next_in [p] != 0) {  	m = 0;  }  else {  	m = 4 - m;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (z.next_in [p] != 0) {  	m = 0;  }  else {  	m = 4 - m;  }  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: m = 4 - m;  
Magic Number,zlib,Inflate,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: if (m != 4) {  	return Z_DATA_ERROR;  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (; k <= g; k++) {  	a = c [k];  	while (a-- != 0) {  		// here i is the Huffman code of length k bits for value *p  		// make tables up to required level  		while (k > w + l) {  			h++;  			w += l;  			// previous table always l bits  			// compute minimum size table less than or equal to l bits  			z = g - w;  			z = (z > l) ? l : z;  			// table size upper limit  			if ((f = 1 << (j = k - w)) > a + 1) {  				// try a k-w bit table  				// too few codes for k-w bit table  				f -= (a + 1);  				// deduct codes from patterns left  				xp = k;  				if (j < z) {  					while (++j < z) {  						// try smaller tables up to z bits  						if ((f <<= 1) <= c [++xp])  							break;  						// enough codes to use up j bits  						f -= c [xp];  						// else deduct codes from patterns  					}  				}  			}  			z = 1 << j;  			// table entries for j-bit table  			// allocate new table  			if (hn [0] + z > MANY)  				// (note: doesn't matter for fixed)  				return Z_DATA_ERROR;  			// overflow of MANY  			u [h] = q = hn [0];  			// DEBUG  			hn [0] += z;  			// connect to last table' if there is one  			if (h != 0) {  				x [h] = i;  				// save pattern for backing up  				r [0] = (byte)j;  				// bits in this table  				r [1] = (byte)l;  				// bits to dump before this table  				j = SupportClass.URShift (i' (w - l));  				r [2] = (int)(q - u [h - 1] - j);  				// offset to this table  				Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  				// connect to last table  			}  			else {  				t [0] = q;  				// first table is returned result  			}  		}  		// set up table entry in r  		r [1] = (byte)(k - w);  		if (p >= n) {  			r [0] = 128 + 64;  			// out of values--invalid code  		}  		else if (v [p] < s) {  			r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  			// 256 is end-of-block  			r [2] = v [p++];  			// simple code is just the value  		}  		else {  			r [0] = (byte)(e [v [p] - s] + 16 + 64);  			// non-simple--look up in lists  			r [2] = d [v [p++] - s];  		}  		// fill code-like entries with r  		f = 1 << (k - w);  		for (j = SupportClass.URShift (i' w); j < z; j += f) {  			Array.Copy (r' 0' hp' (q + j) * 3' 3);  		}  		// backwards increment the k-bit code i  		for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  			i ^= j;  		}  		i ^= j;  		// backup over finished tables  		mask = (1 << w) - 1;  		// needed on HP' cc -O bug  		while ((i & mask) != x [h]) {  			h--;  			// don't need to update q  			w -= l;  			mask = (1 << w) - 1;  		}  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (a-- != 0) {  	// here i is the Huffman code of length k bits for value *p  	// make tables up to required level  	while (k > w + l) {  		h++;  		w += l;  		// previous table always l bits  		// compute minimum size table less than or equal to l bits  		z = g - w;  		z = (z > l) ? l : z;  		// table size upper limit  		if ((f = 1 << (j = k - w)) > a + 1) {  			// try a k-w bit table  			// too few codes for k-w bit table  			f -= (a + 1);  			// deduct codes from patterns left  			xp = k;  			if (j < z) {  				while (++j < z) {  					// try smaller tables up to z bits  					if ((f <<= 1) <= c [++xp])  						break;  					// enough codes to use up j bits  					f -= c [xp];  					// else deduct codes from patterns  				}  			}  		}  		z = 1 << j;  		// table entries for j-bit table  		// allocate new table  		if (hn [0] + z > MANY)  			// (note: doesn't matter for fixed)  			return Z_DATA_ERROR;  		// overflow of MANY  		u [h] = q = hn [0];  		// DEBUG  		hn [0] += z;  		// connect to last table' if there is one  		if (h != 0) {  			x [h] = i;  			// save pattern for backing up  			r [0] = (byte)j;  			// bits in this table  			r [1] = (byte)l;  			// bits to dump before this table  			j = SupportClass.URShift (i' (w - l));  			r [2] = (int)(q - u [h - 1] - j);  			// offset to this table  			Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  			// connect to last table  		}  		else {  			t [0] = q;  			// first table is returned result  		}  	}  	// set up table entry in r  	r [1] = (byte)(k - w);  	if (p >= n) {  		r [0] = 128 + 64;  		// out of values--invalid code  	}  	else if (v [p] < s) {  		r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  		// 256 is end-of-block  		r [2] = v [p++];  		// simple code is just the value  	}  	else {  		r [0] = (byte)(e [v [p] - s] + 16 + 64);  		// non-simple--look up in lists  		r [2] = d [v [p++] - s];  	}  	// fill code-like entries with r  	f = 1 << (k - w);  	for (j = SupportClass.URShift (i' w); j < z; j += f) {  		Array.Copy (r' 0' hp' (q + j) * 3' 3);  	}  	// backwards increment the k-bit code i  	for (j = 1 << (k - 1); (i & j) != 0; j = SupportClass.URShift (j' 1)) {  		i ^= j;  	}  	i ^= j;  	// backup over finished tables  	mask = (1 << w) - 1;  	// needed on HP' cc -O bug  	while ((i & mask) != x [h]) {  		h--;  		// don't need to update q  		w -= l;  		mask = (1 << w) - 1;  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY)  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  	// overflow of MANY  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (byte)j;  		// bits in this table  		r [1] = (byte)l;  		// bits to dump before this table  		j = SupportClass.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY)  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  	// overflow of MANY  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (byte)j;  		// bits in this table  		r [1] = (byte)l;  		// bits to dump before this table  		j = SupportClass.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: while (k > w + l) {  	h++;  	w += l;  	// previous table always l bits  	// compute minimum size table less than or equal to l bits  	z = g - w;  	z = (z > l) ? l : z;  	// table size upper limit  	if ((f = 1 << (j = k - w)) > a + 1) {  		// try a k-w bit table  		// too few codes for k-w bit table  		f -= (a + 1);  		// deduct codes from patterns left  		xp = k;  		if (j < z) {  			while (++j < z) {  				// try smaller tables up to z bits  				if ((f <<= 1) <= c [++xp])  					break;  				// enough codes to use up j bits  				f -= c [xp];  				// else deduct codes from patterns  			}  		}  	}  	z = 1 << j;  	// table entries for j-bit table  	// allocate new table  	if (hn [0] + z > MANY)  		// (note: doesn't matter for fixed)  		return Z_DATA_ERROR;  	// overflow of MANY  	u [h] = q = hn [0];  	// DEBUG  	hn [0] += z;  	// connect to last table' if there is one  	if (h != 0) {  		x [h] = i;  		// save pattern for backing up  		r [0] = (byte)j;  		// bits in this table  		r [1] = (byte)l;  		// bits to dump before this table  		j = SupportClass.URShift (i' (w - l));  		r [2] = (int)(q - u [h - 1] - j);  		// offset to this table  		Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  		// connect to last table  	}  	else {  		t [0] = q;  		// first table is returned result  	}  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (byte)j;  	// bits in this table  	r [1] = (byte)l;  	// bits to dump before this table  	j = SupportClass.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (byte)j;  	// bits in this table  	r [1] = (byte)l;  	// bits to dump before this table  	j = SupportClass.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (h != 0) {  	x [h] = i;  	// save pattern for backing up  	r [0] = (byte)j;  	// bits in this table  	r [1] = (byte)l;  	// bits to dump before this table  	j = SupportClass.URShift (i' (w - l));  	r [2] = (int)(q - u [h - 1] - j);  	// offset to this table  	Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  	// connect to last table  }  else {  	t [0] = q;  	// first table is returned result  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = (int)(q - u [h - 1] - j);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (u [h - 1] + j) * 3' 3);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (p >= n) {  	r [0] = 128 + 64;  	// out of values--invalid code  }  else if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = 128 + 64;  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = 128 + 64;  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: if (v [p] < s) {  	r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  	// 256 is end-of-block  	r [2] = v [p++];  	// simple code is just the value  }  else {  	r [0] = (byte)(e [v [p] - s] + 16 + 64);  	// non-simple--look up in lists  	r [2] = d [v [p++] - s];  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(v [p] < 256 ? 0 : 32 + 64);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = v [p++];  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(e [v [p] - s] + 16 + 64);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [0] = (byte)(e [v [p] - s] + 16 + 64);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r [2] = d [v [p++] - s];  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (j = SupportClass.URShift (i' w); j < z; j += f) {  	Array.Copy (r' 0' hp' (q + j) * 3' 3);  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: for (j = SupportClass.URShift (i' w); j < z; j += f) {  	Array.Copy (r' 0' hp' (q + j) * 3' 3);  }  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (q + j) * 3' 3);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy (r' 0' hp' (q + j) * 3' 3);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build (c' 0' 19' 19' null' null' tb' bb' hp' hn' v);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build (c' 0' 19' 19' null' null' tb' bb' hp' hn' v);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build (c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);  
Magic Number,zlib,InfTree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: if (r != Z_OK || (bd [0] == 0 && nl > 257)) {  	if (r == Z_DATA_ERROR) {  		z.msg = "oversubscribed distance tree";  	}  	else if (r == Z_BUF_ERROR) {  		z.msg = "incomplete distance tree";  		r = Z_DATA_ERROR;  	}  	else if (r != Z_MEM_ERROR) {  		z.msg = "empty distance tree with lengths";  		r = Z_DATA_ERROR;  	}  	return r;  }  
Magic Number,zlib,SupportClass,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\SupportClass.cs,URShift,The following statement contains a magic number: if (number >= 0)  	return number >> bits;  else  	return (number >> bits) + (2 << ~bits);  
Magic Number,zlib,SupportClass,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\SupportClass.cs,URShift,The following statement contains a magic number: return (number >> bits) + (2 << ~bits);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code [dist] : _dist_code [256 + (SupportClass.URShift ((dist)' 7))]);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code [dist] : _dist_code [256 + (SupportClass.URShift ((dist)' 7))]);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code [dist] : _dist_code [256 + (SupportClass.URShift ((dist)' 7))]);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree [s.heap [s.heap_max] * 2 + 1] = 0;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {  	n = s.heap [h];  	bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  	if (bits > max_length) {  		bits = max_length;  		overflow++;  	}  	tree [n * 2 + 1] = (short)bits;  	// We overwrite tree[n*2+1] which is no longer needed  	if (n > max_code)  		continue;  	// not a leaf node  	s.bl_count [bits]++;  	xbits = 0;  	if (n >= base_Renamed)  		xbits = extra [n - base_Renamed];  	f = tree [n * 2];  	s.opt_len += f * (bits + xbits);  	if (stree != null)  		s.static_len += f * (stree [n * 2 + 1] + xbits);  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree [tree [n * 2 + 1] * 2 + 1] + 1;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree [n * 2 + 1] = (short)bits;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: f = tree [n * 2];  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (stree != null)  	s.static_len += f * (stree [n * 2 + 1] + xbits);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree [n * 2 + 1] + xbits);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do {  	bits = max_length - 1;  	while (s.bl_count [bits] == 0)  		bits--;  	s.bl_count [bits]--;  	// move one leaf down the tree  	s.bl_count [bits + 1] = (short)(s.bl_count [bits + 1] + 2);  	// move one overflow item as its brother  	s.bl_count [max_length]--;  	// The brother of the overflow item also moves one step up'  	// but this does not affect bl_count[max_length]  	overflow -= 2;  }  while (overflow > 0);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: do {  	bits = max_length - 1;  	while (s.bl_count [bits] == 0)  		bits--;  	s.bl_count [bits]--;  	// move one leaf down the tree  	s.bl_count [bits + 1] = (short)(s.bl_count [bits + 1] + 2);  	// move one overflow item as its brother  	s.bl_count [max_length]--;  	// The brother of the overflow item also moves one step up'  	// but this does not affect bl_count[max_length]  	overflow -= 2;  }  while (overflow > 0);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count [bits + 1] = (short)(s.bl_count [bits + 1] + 2);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--) {  	n = s.bl_count [bits];  	while (n != 0) {  		m = s.heap [--h];  		if (m > max_code)  			continue;  		if (tree [m * 2 + 1] != bits) {  			s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  			tree [m * 2 + 1] = (short)bits;  		}  		n--;  	}  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--) {  	n = s.bl_count [bits];  	while (n != 0) {  		m = s.heap [--h];  		if (m > max_code)  			continue;  		if (tree [m * 2 + 1] != bits) {  			s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  			tree [m * 2 + 1] = (short)bits;  		}  		n--;  	}  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--) {  	n = s.bl_count [bits];  	while (n != 0) {  		m = s.heap [--h];  		if (m > max_code)  			continue;  		if (tree [m * 2 + 1] != bits) {  			s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  			tree [m * 2 + 1] = (short)bits;  		}  		n--;  	}  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: for (bits = max_length; bits != 0; bits--) {  	n = s.bl_count [bits];  	while (n != 0) {  		m = s.heap [--h];  		if (m > max_code)  			continue;  		if (tree [m * 2 + 1] != bits) {  			s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  			tree [m * 2 + 1] = (short)bits;  		}  		n--;  	}  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: while (n != 0) {  	m = s.heap [--h];  	if (m > max_code)  		continue;  	if (tree [m * 2 + 1] != bits) {  		s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  		tree [m * 2 + 1] = (short)bits;  	}  	n--;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: while (n != 0) {  	m = s.heap [--h];  	if (m > max_code)  		continue;  	if (tree [m * 2 + 1] != bits) {  		s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  		tree [m * 2 + 1] = (short)bits;  	}  	n--;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: while (n != 0) {  	m = s.heap [--h];  	if (m > max_code)  		continue;  	if (tree [m * 2 + 1] != bits) {  		s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  		tree [m * 2 + 1] = (short)bits;  	}  	n--;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: while (n != 0) {  	m = s.heap [--h];  	if (m > max_code)  		continue;  	if (tree [m * 2 + 1] != bits) {  		s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  		tree [m * 2 + 1] = (short)bits;  	}  	n--;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (tree [m * 2 + 1] != bits) {  	s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  	tree [m * 2 + 1] = (short)bits;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (tree [m * 2 + 1] != bits) {  	s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  	tree [m * 2 + 1] = (short)bits;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (tree [m * 2 + 1] != bits) {  	s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  	tree [m * 2 + 1] = (short)bits;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: if (tree [m * 2 + 1] != bits) {  	s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  	tree [m * 2 + 1] = (short)bits;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree [m * 2 + 1]) * (long)tree [m * 2]);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree [m * 2 + 1] = (short)bits;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++) {  	if (tree [n * 2] != 0) {  		s.heap [++s.heap_len] = max_code = n;  		s.depth [n] = 0;  	}  	else {  		tree [n * 2 + 1] = 0;  	}  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = 0; n < elems; n++) {  	if (tree [n * 2] != 0) {  		s.heap [++s.heap_len] = max_code = n;  		s.depth [n] = 0;  	}  	else {  		tree [n * 2 + 1] = 0;  	}  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: if (tree [n * 2] != 0) {  	s.heap [++s.heap_len] = max_code = n;  	s.depth [n] = 0;  }  else {  	tree [n * 2 + 1] = 0;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: if (tree [n * 2] != 0) {  	s.heap [++s.heap_len] = max_code = n;  	s.depth [n] = 0;  }  else {  	tree [n * 2 + 1] = 0;  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [n * 2 + 1] = 0;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  	tree [node * 2] = 1;  	s.depth [node] = 0;  	s.opt_len--;  	if (stree != null)  		s.static_len -= stree [node * 2 + 1];  	// node is 0 or 1 so it does not have extra bits  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  	tree [node * 2] = 1;  	s.depth [node] = 0;  	s.opt_len--;  	if (stree != null)  		s.static_len -= stree [node * 2 + 1];  	// node is 0 or 1 so it does not have extra bits  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  	tree [node * 2] = 1;  	s.depth [node] = 0;  	s.opt_len--;  	if (stree != null)  		s.static_len -= stree [node * 2 + 1];  	// node is 0 or 1 so it does not have extra bits  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: while (s.heap_len < 2) {  	node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  	tree [node * 2] = 1;  	s.depth [node] = 0;  	s.opt_len--;  	if (stree != null)  		s.static_len -= stree [node * 2 + 1];  	// node is 0 or 1 so it does not have extra bits  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap [++s.heap_len] = (max_code < 2 ? ++max_code : 0);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [node * 2] = 1;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: if (stree != null)  	s.static_len -= stree [node * 2 + 1];  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: s.static_len -= stree [node * 2 + 1];  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: for (n = s.heap_len / 2; n >= 1; n--)  	s.pqdownheap (tree' n);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: n = s.heap_len / 2
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  	s.depth [node] = (byte)(Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  	s.depth [node] = (byte)(Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  	s.depth [node] = (byte)(Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  	s.depth [node] = (byte)(Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  	s.depth [node] = (byte)(Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: do {  	// n = node of least frequency  	n = s.heap [1];  	s.heap [1] = s.heap [s.heap_len--];  	s.pqdownheap (tree' 1);  	m = s.heap [1];  	// m = node of next least frequency  	s.heap [--s.heap_max] = n;  	// keep the nodes sorted by frequency  	s.heap [--s.heap_max] = m;  	// Create a new node father of n and m  	tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  	s.depth [node] = (byte)(Math.Max ((byte)s.depth [n]' (byte)s.depth [m]) + 1);  	tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  	// and insert the new node in the heap  	s.heap [1] = node++;  	s.pqdownheap (tree' 1);  }  while (s.heap_len >= 2);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [node * 2] = (short)(tree [n * 2] + tree [m * 2]);  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree [n * 2 + 1] = tree [m * 2 + 1] = (short)node;  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	int len = tree [n * 2 + 1];  	if (len == 0)  		continue;  	// Now reverse the bits  	tree [n * 2] = (short)(bi_reverse (next_code [len]++' len));  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_codes,The following statement contains a magic number: for (n = 0; n <= max_code; n++) {  	int len = tree [n * 2 + 1];  	if (len == 0)  		continue;  	// Now reverse the bits  	tree [n * 2] = (short)(bi_reverse (next_code [len]++' len));  }  
Magic Number,zlib,Tree,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Tree.cs,gen_codes,The following statement contains a magic number: tree [n * 2] = (short)(bi_reverse (next_code [len]++' len));  
Duplicate Code,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 31)' (14' 33)' (16' 35)' (18' 37)' (20' 39)' (22' 41)' (24' 43))
Duplicate Code,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 40)' (14' 42))
Duplicate Code,zlib,Adler32,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\Adler32.cs,adler32,The method contains a code clone-set at the following line numbers (starting from the method definition): ((12' 31)' (16' 35)' (18' 37)' (20' 39)' (22' 41)' (24' 43))
Duplicate Code,zlib,InfCodes,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfCodes.cs,proc,The method contains a code clone-set at the following line numbers (starting from the method definition): ((225' 249)' (260' 284))
Missing Default,MySql.Data.MySqlClient,MySqlConnection,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Connection.cs,BeginTransaction,The following switch statement is missing a default case: switch (iso) {  case IsolationLevel.ReadCommitted:  	cmd.CommandText += "READ COMMITTED";  	break;  case IsolationLevel.ReadUncommitted:  	cmd.CommandText += "READ UNCOMMITTED";  	break;  case IsolationLevel.RepeatableRead:  	cmd.CommandText += "REPEATABLE READ";  	break;  case IsolationLevel.Serializable:  	cmd.CommandText += "SERIALIZABLE";  	break;  case IsolationLevel.Chaos:  	Throw (new NotSupportedException (Resources.ChaosNotSupported));  	break;  case IsolationLevel.Snapshot:  	Throw (new NotSupportedException (Resources.SnapshotNotSupported));  	break;  }  
Missing Default,MySql.Data.MySqlClient,MySqlField,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Field.cs,SetTypeAndFlags,The following switch statement is missing a default case: switch (type) {  case MySqlDbType.Byte:  	mySqlDbType = MySqlDbType.UByte;  	return;  case MySqlDbType.Int16:  	mySqlDbType = MySqlDbType.UInt16;  	return;  case MySqlDbType.Int24:  	mySqlDbType = MySqlDbType.UInt24;  	return;  case MySqlDbType.Int32:  	mySqlDbType = MySqlDbType.UInt32;  	return;  case MySqlDbType.Int64:  	mySqlDbType = MySqlDbType.UInt64;  	return;  }  
Missing Default,MySql.Data.MySqlClient,ISSchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\ISSchemaProvider.cs,GetSchemaInternal,The following switch statement is missing a default case: switch (collection) {  case "VIEWS":  	return GetViews (restrictions);  case "PROCEDURES":  	return GetProcedures (restrictions);  case "PROCEDURES WITH PARAMETERS":  	return GetProceduresWithParameters (restrictions);  case "PROCEDURE PARAMETERS":  	return GetProcedureParameters (restrictions' null);  case "TRIGGERS":  	return GetTriggers (restrictions);  case "VIEWCOLUMNS":  	return GetViewColumns (restrictions);  }  
Missing Default,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadLong,The following switch statement is missing a default case: switch (numbytes) {  case 2:  	return BitConverter.ToUInt16 (bytes' pos);  case 4:  	return BitConverter.ToUInt32 (bytes' pos);  case 8:  	return BitConverter.ToInt64 (bytes' pos);  }  
Missing Default,MySql.Data.MySqlClient,MySqlPacket,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\MySqlPacket.cs,ReadULong,The following switch statement is missing a default case: switch (numbytes) {  case 2:  	return BitConverter.ToUInt16 (bytes' pos);  case 4:  	return BitConverter.ToUInt32 (bytes' pos);  case 8:  	return BitConverter.ToUInt64 (bytes' pos);  }  
Missing Default,MySql.Data.MySqlClient,MySqlParameter,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\parameter.cs,SetMySqlDbType,The following switch statement is missing a default case: switch (mySqlDbType) {  case MySqlDbType.NewDecimal:  case MySqlDbType.Decimal:  	dbType = DbType.Decimal;  	break;  case MySqlDbType.Byte:  	dbType = DbType.SByte;  	break;  case MySqlDbType.UByte:  	dbType = DbType.Byte;  	break;  case MySqlDbType.Int16:  	dbType = DbType.Int16;  	break;  case MySqlDbType.UInt16:  	dbType = DbType.UInt16;  	break;  case MySqlDbType.Int24:  case MySqlDbType.Int32:  	dbType = DbType.Int32;  	break;  case MySqlDbType.UInt24:  case MySqlDbType.UInt32:  	dbType = DbType.UInt32;  	break;  case MySqlDbType.Int64:  	dbType = DbType.Int64;  	break;  case MySqlDbType.UInt64:  	dbType = DbType.UInt64;  	break;  case MySqlDbType.Bit:  	dbType = DbType.UInt64;  	break;  case MySqlDbType.Float:  	dbType = DbType.Single;  	break;  case MySqlDbType.Double:  	dbType = DbType.Double;  	break;  case MySqlDbType.Timestamp:  case MySqlDbType.DateTime:  	dbType = DbType.DateTime;  	break;  case MySqlDbType.Date:  case MySqlDbType.Newdate:  case MySqlDbType.Year:  	dbType = DbType.Date;  	break;  case MySqlDbType.Time:  	dbType = DbType.Time;  	break;  case MySqlDbType.Enum:  case MySqlDbType.Set:  case MySqlDbType.VarChar:  	dbType = DbType.String;  	break;  case MySqlDbType.TinyBlob:  case MySqlDbType.MediumBlob:  case MySqlDbType.LongBlob:  case MySqlDbType.Blob:  	dbType = DbType.Object;  	break;  case MySqlDbType.String:  	dbType = DbType.StringFixedLength;  	break;  case MySqlDbType.Guid:  	dbType = DbType.Guid;  	break;  }  
Missing Default,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetSchemaInternal,The following switch statement is missing a default case: switch (collection) {  // common collections  case "METADATACOLLECTIONS":  	return GetCollections ();  case "DATASOURCEINFORMATION":  	return GetDataSourceInformation ();  case "DATATYPES":  	return GetDataTypes ();  case "RESTRICTIONS":  	return GetRestrictions ();  case "RESERVEDWORDS":  	return GetReservedWords ();  // collections specific to our provider  case "USERS":  	return GetUsers (restrictions);  case "DATABASES":  	return GetDatabases (restrictions);  case "UDF":  	return GetUDF (restrictions);  }  
Missing Default,MySql.Data.MySqlClient,SchemaProvider,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\SchemaProvider.cs,GetSchemaInternal,The following switch statement is missing a default case: switch (collection) {  case "TABLES":  	return GetTables (restrictions);  case "COLUMNS":  	return GetColumns (restrictions);  case "INDEXES":  	return GetIndexes (restrictions);  case "INDEXCOLUMNS":  	return GetIndexColumns (restrictions);  case "FOREIGN KEYS":  	return GetForeignKeys (restrictions);  case "FOREIGN KEY COLUMNS":  	return GetForeignKeyColumns (restrictions);  }  
Missing Default,MySql.Data.Common,Platform,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\common\Platform.cs,IsWindows,The following switch statement is missing a default case: switch (os.Platform) {  case PlatformID.Win32NT:  case PlatformID.Win32S:  case PlatformID.Win32Windows:  	return true;  }  
Missing Default,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,IsNumericType,The following switch statement is missing a default case: switch (lowerType) {  case "int":  case "integer":  case "numeric":  case "decimal":  case "dec":  case "fixed":  case "tinyint":  case "mediumint":  case "bigint":  case "real":  case "double":  case "float":  case "serial":  case "smallint":  	return true;  }  
Missing Default,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,IsTextType,The following switch statement is missing a default case: switch (lowerType) {  case "varchar":  case "char":  case "text":  case "longtext":  case "tinytext":  case "mediumtext":  case "nchar":  case "nvarchar":  case "enum":  case "set":  	return true;  }  
Missing Default,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,SupportScale,The following switch statement is missing a default case: switch (lowerType) {  case "numeric":  case "decimal":  case "dec":  case "real":  	return true;  }  
Missing Default,MySql.Data.Types,MetaData,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\Types\MetaData.cs,NameToType,The following switch statement is missing a default case: switch (typeName.ToUpper (CultureInfo.InvariantCulture)) {  case "CHAR":  	return MySqlDbType.String;  case "VARCHAR":  	return MySqlDbType.VarChar;  case "DATE":  	return MySqlDbType.Date;  case "DATETIME":  	return MySqlDbType.DateTime;  case "NUMERIC":  case "DECIMAL":  case "DEC":  case "FIXED":  	if (connection.driver.Version.isAtLeast (5' 0' 3))  		return MySqlDbType.NewDecimal;  	else  		return MySqlDbType.Decimal;  case "YEAR":  	return MySqlDbType.Year;  case "TIME":  	return MySqlDbType.Time;  case "TIMESTAMP":  	return MySqlDbType.Timestamp;  case "SET":  	return MySqlDbType.Set;  case "ENUM":  	return MySqlDbType.Enum;  case "BIT":  	return MySqlDbType.Bit;  case "TINYINT":  	return unsigned ? MySqlDbType.UByte : MySqlDbType.Byte;  case "BOOL":  case "BOOLEAN":  	return MySqlDbType.Byte;  case "SMALLINT":  	return unsigned ? MySqlDbType.UInt16 : MySqlDbType.Int16;  case "MEDIUMINT":  	return unsigned ? MySqlDbType.UInt24 : MySqlDbType.Int24;  case "INT":  case "INTEGER":  	return unsigned ? MySqlDbType.UInt32 : MySqlDbType.Int32;  case "SERIAL":  	return MySqlDbType.UInt64;  case "BIGINT":  	return unsigned ? MySqlDbType.UInt64 : MySqlDbType.Int64;  case "FLOAT":  	return MySqlDbType.Float;  case "DOUBLE":  	return MySqlDbType.Double;  case "REAL":  	return realAsFloat ? MySqlDbType.Float : MySqlDbType.Double;  case "TEXT":  	return MySqlDbType.Text;  case "BLOB":  	return MySqlDbType.Blob;  case "LONGBLOB":  	return MySqlDbType.LongBlob;  case "LONGTEXT":  	return MySqlDbType.LongText;  case "MEDIUMBLOB":  	return MySqlDbType.MediumBlob;  case "MEDIUMTEXT":  	return MySqlDbType.MediumText;  case "TINYBLOB":  	return MySqlDbType.TinyBlob;  case "TINYTEXT":  	return MySqlDbType.TinyText;  case "BINARY":  	return MySqlDbType.Binary;  case "VARBINARY":  	return MySqlDbType.VarBinary;  }  
Missing Default,zlib,InfBlocks,C:\repos\MonsterFag_YouMetATerribleFateHaventYou\MySql.Data\zlib\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift (t' 1)) {  case 0:  	// stored   	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	t = k & 7;  	// go to byte boundary  	{  		b = SupportClass.URShift (b' (t));  		k -= (t);  	}  	mode = LENS;  	// get length of stored block  	break;  case 1:  	// fixed  	{  		var bl = new int[1];  		var bd = new int[1];  		var tl = new int[1][];  		var td = new int[1][];  		InfTree.inflate_trees_fixed (bl' bd' tl' td' z);  		codes = new InfCodes (bl [0]' bd [0]' tl [0]' td [0]' z);  	}  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = CODES;  	break;  case 2:  	// dynamic  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = TABLE;  	break;  case 3:  	// illegal  	{  		b = SupportClass.URShift (b' (3));  		k -= (3);  	}  	mode = BAD;  	z.msg = "invalid block type";  	r = Z_DATA_ERROR;  	bitb = b;  	bitk = k;  	z.avail_in = n;  	z.total_in += p - z.next_in_index;  	z.next_in_index = p;  	write = q;  	return inflate_flush (z' r);  }  
