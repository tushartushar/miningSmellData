Implementation smell,Namespace,Class,File,Method,Description
Complex Method,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,Cyclomatic complexity of the method is 24
Complex Method,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,ComputeHashWorker,Cyclomatic complexity of the method is 22
Complex Method,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,Cyclomatic complexity of the method is 12
Long Parameter List,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,IsInCollection,The method has 5 parameters.
Long Statement,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,CanReuseSalt,The length of the statement  "	return Algorithm == value.Algorithm && ComplexityThrottle == value.ComplexityThrottle && this.SaltBytes == value._saltBytes; " is 124.
Long Statement,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The length of the statement  "	_saltBytes = new byte[hashWithSaltBytes.Length - (hashSizeInBytes + iterationCountSizeInBytes + algoMarkerSizeInBytes)]; " is 120.
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: switch (_algorithm) {  case SupportedHashAlgorithm.SHA1:  	hashSizeInBits = 160;  	break;  case SupportedHashAlgorithm.SHA256:  	hashSizeInBits = 256;  	break;  case SupportedHashAlgorithm.SHA384:  	hashSizeInBits = 384;  	break;  case SupportedHashAlgorithm.SHA512:  	hashSizeInBits = 512;  	break;  case SupportedHashAlgorithm.PBKDF2:  	hashSizeInBits = 192;  	hasIterationsCount = true;  	break;  default:  	hashSizeInBits = 128;  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: switch (_algorithm) {  case SupportedHashAlgorithm.SHA1:  	hashSizeInBits = 160;  	break;  case SupportedHashAlgorithm.SHA256:  	hashSizeInBits = 256;  	break;  case SupportedHashAlgorithm.SHA384:  	hashSizeInBits = 384;  	break;  case SupportedHashAlgorithm.SHA512:  	hashSizeInBits = 512;  	break;  case SupportedHashAlgorithm.PBKDF2:  	hashSizeInBits = 192;  	hasIterationsCount = true;  	break;  default:  	hashSizeInBits = 128;  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: switch (_algorithm) {  case SupportedHashAlgorithm.SHA1:  	hashSizeInBits = 160;  	break;  case SupportedHashAlgorithm.SHA256:  	hashSizeInBits = 256;  	break;  case SupportedHashAlgorithm.SHA384:  	hashSizeInBits = 384;  	break;  case SupportedHashAlgorithm.SHA512:  	hashSizeInBits = 512;  	break;  case SupportedHashAlgorithm.PBKDF2:  	hashSizeInBits = 192;  	hasIterationsCount = true;  	break;  default:  	hashSizeInBits = 128;  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: switch (_algorithm) {  case SupportedHashAlgorithm.SHA1:  	hashSizeInBits = 160;  	break;  case SupportedHashAlgorithm.SHA256:  	hashSizeInBits = 256;  	break;  case SupportedHashAlgorithm.SHA384:  	hashSizeInBits = 384;  	break;  case SupportedHashAlgorithm.SHA512:  	hashSizeInBits = 512;  	break;  case SupportedHashAlgorithm.PBKDF2:  	hashSizeInBits = 192;  	hasIterationsCount = true;  	break;  default:  	hashSizeInBits = 128;  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: switch (_algorithm) {  case SupportedHashAlgorithm.SHA1:  	hashSizeInBits = 160;  	break;  case SupportedHashAlgorithm.SHA256:  	hashSizeInBits = 256;  	break;  case SupportedHashAlgorithm.SHA384:  	hashSizeInBits = 384;  	break;  case SupportedHashAlgorithm.SHA512:  	hashSizeInBits = 512;  	break;  case SupportedHashAlgorithm.PBKDF2:  	hashSizeInBits = 192;  	hasIterationsCount = true;  	break;  default:  	hashSizeInBits = 128;  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: switch (_algorithm) {  case SupportedHashAlgorithm.SHA1:  	hashSizeInBits = 160;  	break;  case SupportedHashAlgorithm.SHA256:  	hashSizeInBits = 256;  	break;  case SupportedHashAlgorithm.SHA384:  	hashSizeInBits = 384;  	break;  case SupportedHashAlgorithm.SHA512:  	hashSizeInBits = 512;  	break;  case SupportedHashAlgorithm.PBKDF2:  	hashSizeInBits = 192;  	hasIterationsCount = true;  	break;  default:  	hashSizeInBits = 128;  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: hashSizeInBits = 160;  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: hashSizeInBits = 256;  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: hashSizeInBits = 384;  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: hashSizeInBits = 512;  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: hashSizeInBits = 192;  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,Init,The following statement contains a magic number: hashSizeInBits = 128;  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,ComputeHashWorker,The following statement contains a magic number: switch (algorithm) {  case SupportedHashAlgorithm.SHA1:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new SHA1Managed ());  	break;  case SupportedHashAlgorithm.SHA256:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new SHA256Managed ());  	break;  case SupportedHashAlgorithm.SHA384:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new SHA384Managed ());  	break;  case SupportedHashAlgorithm.SHA512:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new SHA512Managed ());  	break;  case SupportedHashAlgorithm.PBKDF2:  	complexityThrottle = complexityThrottle * 1000;  	hashBytes = new Rfc2898DeriveBytes (plainTextBytes' saltBytes' complexityThrottle).GetBytes (24);  	hasComplexityThrottle = true;  	break;  default:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new MD5CryptoServiceProvider ());  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,ComputeHashWorker,The following statement contains a magic number: switch (algorithm) {  case SupportedHashAlgorithm.SHA1:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new SHA1Managed ());  	break;  case SupportedHashAlgorithm.SHA256:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new SHA256Managed ());  	break;  case SupportedHashAlgorithm.SHA384:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new SHA384Managed ());  	break;  case SupportedHashAlgorithm.SHA512:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new SHA512Managed ());  	break;  case SupportedHashAlgorithm.PBKDF2:  	complexityThrottle = complexityThrottle * 1000;  	hashBytes = new Rfc2898DeriveBytes (plainTextBytes' saltBytes' complexityThrottle).GetBytes (24);  	hasComplexityThrottle = true;  	break;  default:  	hashBytes = CryptoHashAlgorithmComputeBytes (plainTextBytes' saltBytes' new MD5CryptoServiceProvider ());  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,ComputeHashWorker,The following statement contains a magic number: complexityThrottle = complexityThrottle * 1000;  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,ComputeHashWorker,The following statement contains a magic number: hashBytes = new Rfc2898DeriveBytes (plainTextBytes' saltBytes' complexityThrottle).GetBytes (24);  
Magic Number,PhiloSoftware.Core.Infrastructure.Security,HashedValue,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Security\HashedValue.cs,DetermineHashTypeFromHash,The following statement contains a magic number: for (var i = 0; i < 6; i++) {  	bytes [i] = hashBytes [algoIndex + i];  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  	Array.Reverse (guidBytes' 0' 4);  	Array.Reverse (guidBytes' 4' 2);  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  	Array.Reverse (guidBytes' 0' 4);  	Array.Reverse (guidBytes' 4' 2);  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  	Array.Reverse (guidBytes' 0' 4);  	Array.Reverse (guidBytes' 4' 2);  }  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Array.Reverse (guidBytes' 0' 4);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Array.Reverse (guidBytes' 4' 2);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Array.Reverse (guidBytes' 4' 2);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  
Magic Number,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following statement contains a magic number: Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  
Missing Default,PhiloSoftware.Core.Infrastructure,SequentialGuidGenerator,C:\repos\PhiloSoftware_PhiloSoftware.Core\Project\PhiloSoftware.Core.Infrastructure\Services\SequentialGuidService.cs,NewSequentialGuid,The following switch statement is missing a default case: switch (GuidType) {  case EnumSequentialGuidType.SequentialAsString:  case EnumSequentialGuidType.SequentialAsBinary:  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 0' 6);  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 6' 10);  	// If formatting as a string' we have to reverse the order  	// of the Data1 and Data2 blocks on little-endian systems.  	if (GuidType == EnumSequentialGuidType.SequentialAsString && BitConverter.IsLittleEndian) {  		Array.Reverse (guidBytes' 0' 4);  		Array.Reverse (guidBytes' 4' 2);  	}  	break;  case EnumSequentialGuidType.SequentialAtEnd:  	Buffer.BlockCopy (randomBytes' 0' guidBytes' 0' 10);  	Buffer.BlockCopy (timestampBytes' 2' guidBytes' 10' 6);  	break;  }  
