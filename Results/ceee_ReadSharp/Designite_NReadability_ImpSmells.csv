Implementation smell,Namespace,Class,File,Method,Description
Long Method,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The method has 203 lines of code.
Complex Method,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,Cyclomatic complexity of the method is 29
Complex Method,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindBaseUrl,Cyclomatic complexity of the method is 10
Complex Method,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,PrepareArticleContentElement,Cyclomatic complexity of the method is 9
Complex Method,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,GetClassWeight,Cyclomatic complexity of the method is 8
Complex Method,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,CleanConditionally,Cyclomatic complexity of the method is 8
Complex Method,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,ResolveElementsUrls,Cyclomatic complexity of the method is 8
Complex Method,ReadSharp.Ports.NReadability,SgmlDomSerializer,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\SgmlDomSerializer.cs,SerializeDocument,Cyclomatic complexity of the method is 10
Long Parameter List,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,NReadabilityTranscoder,The method has 6 parameters. Parameters: dontStripUnlikelys' dontNormalizeSpacesInTextContent' dontWeightClasses' readingStyle' readingMargin' readingSize
Long Parameter List,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,Transcode,The method has 5 parameters. Parameters: htmlContent' url' domSerializationParams' mainContentExtracted' nextPageUrl
Long Parameter List,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,TranscodeToXml,The method has 5 parameters. Parameters: htmlContent' url' mainContentExtracted' extractedTitle' nextPageUrl
Long Parameter List,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,ResolveElementsUrls,The method has 5 parameters. Parameters: document' tagName' attributeName' url' attributeValueTransformer
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,NReadabilityTranscoder,The length of the parameter dontNormalizeSpacesInTextContent is 32.
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,,The length of the parameter _ReadabilityStylesheetResourceName is 34.
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,,The length of the parameter _MaxImagesInShortSegmentsCount is 30.
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,,The length of the parameter _MinInnerTextLengthInElementsWithEmbed is 38.
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,,The length of the parameter _SiblingScoreTresholdCoefficient is 32.
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,,The length of the parameter _MaxSiblingParagraphLinksDensity is 32.
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,,The length of the parameter _MaxDensityForElementsWithSmallerClassWeight is 44.
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,,The length of the parameter _MaxDensityForElementsWithGreaterClassWeight is 44.
Long Identifier,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,,The length of the parameter _dontNormalizeSpacesInTextContent is 33.
Long Statement,ReadSharp.Ports.NReadability,DomExtensions,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\DomExtensions.cs,GetElementsByClass,The length of the statement  "        .Where(e => e != null && e.GetAttributeValue("class"' "").Contains(className)); //tagName.Equals(e.Name.LocalName' StringComparison.OrdinalIgnoreCase)); " is 152.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The length of the statement  "        /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */ " is 124.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The length of the statement  "         * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html " is 126.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The length of the statement  "            if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber)) " is 202.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The length of the statement  "          if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId))) " is 137.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The length of the statement  "          string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' ""); " is 182.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,GlueDocument,The length of the statement  "      Stream readabilityStylesheetStream = typeof(NReadabilityTranscoder).GetTypeInfo().Assembly.GetManifestResourceStream(_ReadabilityStylesheetResourceName); " is 153.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,StripUnlikelyCandidates,The length of the statement  "          /* Turn all divs that don't have children block level elements into p's or replace text nodes within the div with p's. */ " is 121.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,CollapseRedundantParagraphDivs,The length of the statement  "                // we have a div with a single child element that is a paragraph - let's remove the div and attach the paragraph to the div's parent " is 132.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindCandidatesForArticleContent,The length of the statement  "        // For every PARAGRAPH_SEGMENT_LENGTH characters in this paragraph' add another point. Up to MAX_POINTS_FOR_SEGMENTS_COUNT points. " is 130.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindCandidatesForArticleContent,The length of the statement  "        if (grandParentElement != null && !"html".Equals(grandParentElement.Name.LocalName' StringComparison.OrdinalIgnoreCase)) " is 120.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,CreateArticleContentElement,The length of the statement  "        // if the top candidate element has no parent' it means that it's an element created by us and detached from the document' " is 122.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,CreateArticleContentElement,The length of the statement  "          // we'll append this element if the calculated score is higher than a treshold (derived from the score of the top candidate element) " is 132.
Long Statement,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,CleanConditionally,The length of the statement  "                     || (embedsCount > _MaxEmbedsCount || (embedsCount == _MaxEmbedsCount && innerTextLength < _MinInnerTextLengthInElementsWithEmbed)); " is 131.
Long Statement,ReadSharp.Ports.NReadability,SgmlDomSerializer,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\SgmlDomSerializer.cs,SerializeDocument,The length of the statement  "      string result = document.ToString(domSerializationParams.PrettyPrint ? SaveOptions.None : SaveOptions.DisableFormatting); " is 121.
Complex Conditional,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The conditional expression  "originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber)"  is complex.
Complex Conditional,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,StripUnlikelyCandidates,The conditional expression  "unlikelyMatchString.Length > 0             && !"body".Equals(elementName' StringComparison.OrdinalIgnoreCase)             && !"a".Equals(elementName' StringComparison.OrdinalIgnoreCase)             && _UnlikelyCandidatesRegex.IsMatch(unlikelyMatchString)             && !_OkMaybeItsACandidateRegex.IsMatch(unlikelyMatchString)"  is complex.
Empty Catch Block,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The method has an empty catch block.
Magic Number,ReadSharp.Ports.NReadability,MetaExtractor,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\MetaExtractor.cs,GetCharset,The following statement contains a magic number: if (String.IsNullOrEmpty(result))        {          // find: <meta http-equiv="Content-Type" content="text/html; charset=windows-1250">          result = SearchCandidates(new Dictionary<string' string>()          {            { "http-equiv|Content-Type"' "content" }          });            if (!String.IsNullOrEmpty(result))          {            int charsetStart = result.IndexOf("charset=");            if (charsetStart > 0)            {              charsetStart += 8;              result = result.Substring(charsetStart' result.Length - charsetStart);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,TranscodeToXml,The following statement contains a magic number: if (!_dontStripUnlikelys && GetInnerText(articleContentElement).Length < 250)        {          try          {            _dontStripUnlikelys = true;              return TranscodeToXml(htmlContent' url' out mainContentExtracted' out extractedTitle' out nextPageUrl);          }          finally          {            _dontStripUnlikelys = false;          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (XElement linkElement in allLinks)        {          string linkHref = (string)linkElement.Attribute("href");            if (string.IsNullOrEmpty(linkHref)           || _MailtoHrefRegex.IsMatch(linkHref))          {            continue;          }            linkHref = Regex.Replace(linkHref' "#.*$"' "");          linkHref = Regex.Replace(linkHref' "/$"' "");            /* If we've already seen this page' then ignore it. */          // This leaves out an already-checked page check' because           // the web transcoder is seperate from the original transcoder          if (linkHref == "" || linkHref == articleBaseUrl || linkHref == url)          {            continue;          }            /* If it's on a different domain' skip it. */          Uri linkHrefUri;            if (Uri.TryCreate(linkHref' UriKind.Absolute' out linkHrefUri) && linkHrefUri.Host != new Uri(articleBaseUrl).Host)          {            continue;          }            string linkText = GetInnerText(linkElement);            /* If the linktext looks like it's not the next page' then skip it */          if (_Extraneous.IsMatch(linkText))          {            continue;          }            /* If the leftovers of the URL after removing the base URL don't contain any digits' it's certainly not a next page link. */          string linkHrefLeftover = linkHref.Replace(articleBaseUrl' "");            if (!Regex.IsMatch(linkHrefLeftover' @"\d"))          {            continue;          }            if (!possiblePagesByLink.Keys.Contains(linkHref))          {            possiblePagesByLink[linkHref] = new LinkData { Score = 0' LinkHref = linkHref' LinkText = linkText };          }          else          {            possiblePagesByLink[linkHref].LinkText += " | " + linkText;          }            LinkData linkObj = possiblePagesByLink[linkHref];            /*           * If the articleBaseUrl isn't part of this URL' penalize this link. It could still be the link' but the odds are lower.           * Example: http://www.actionscript.org/resources/articles/745/1/JavaScript-and-VBScript-Injection-in-ActionScript-3/Page1.html           */          if (linkHref.IndexOf(articleBaseUrl' StringComparison.OrdinalIgnoreCase) == -1)          {            linkObj.Score -= 25;          }            string linkData = linkText + " " + linkElement.GetClass() + " " + linkElement.GetId();            if (_NextLink.IsMatch(linkData)          && !_NextStoryLink.IsMatch(linkData))          {            linkObj.Score += 50;          }            if (_PageRegex.IsMatch(linkData))          {            linkObj.Score += 25;          }            /* If we already matched on "next"' last is probably fine. If we didn't' then it's bad. Penalize. */          /* -65 is enough to negate any bonuses gotten from a > or � in the text */          if (Regex.IsMatch(linkData' "(first|last)"' RegexOptions.IgnoreCase)           && !_NextLink.IsMatch(linkObj.LinkText))          {            linkObj.Score -= 65;          }            if (_NegativeWeightRegex.IsMatch(linkData) || _Extraneous.IsMatch(linkData))          {            linkObj.Score -= 50;          }            if (_PrevLink.IsMatch(linkData))          {            linkObj.Score -= 200;          }            double urlComparity = StringCompare(url' linkHref);            /* If the next page differs from the original too much */          if (urlComparity < 80)          {            linkObj.Score -= 200;          }          else if (urlComparity > 95 && url.Length <= linkHref.Length)          {            try            {              string originalLinkHrefNumber = Regex.Match(url.Replace(articleBaseUrl' "")' @"\d+").Value;              string linkHrefNumber = Regex.Match(linkHref.Replace(articleBaseUrl' "")' @"\d+").Value;                if (originalLinkHrefNumber == "")              {                originalLinkHrefNumber = "0";              }                if (originalLinkHrefNumber != null && linkHrefNumber != null && linkHrefNumber.Length < 3 && linkHref.EndsWith(linkHrefNumber) && Convert.ToByte(originalLinkHrefNumber) < Convert.ToByte(linkHrefNumber))              {                linkObj.Score += 75;              }            }            catch { }          }            /* If any ancestor node contains page or paging or paginat */          XElement parentNode = linkElement.Parent;          bool positiveNodeMatch = false;          bool negativeNodeMatch = false;            while (parentNode != null)          {            string parentNodeClassAndId = parentNode.GetClass() + " " + parentNode.GetId();              if (!positiveNodeMatch && (_PageRegex.IsMatch(parentNodeClassAndId) || _NextLink.IsMatch(parentNodeClassAndId)))            {              positiveNodeMatch = true;              linkObj.Score += 25;            }              if (!negativeNodeMatch && (_NegativeWeightRegex.IsMatch(parentNodeClassAndId) || _NegativeLinkParentRegex.IsMatch(parentNodeClassAndId)))            {              if (!_PositiveWeightRegex.IsMatch(parentNodeClassAndId))              {                linkObj.Score -= 25;                negativeNodeMatch = true;              }            }              parentNode = parentNode.Parent;          }            /* If any descendant node contains 'next indicator' or 'prev indicator' - adjust the score */          bool positiveDescendantMatch = false;          bool negativeDescendantMatch = false;            foreach (XElement descendantElement in linkElement.Descendants())          {            string descendantData = GetInnerText(descendantElement) + " " + descendantElement.GetClass() + " " + descendantElement.GetId() + " " + descendantElement.GetAttributeValue("alt"' "");              if (!positiveDescendantMatch && _NextLink.IsMatch(descendantData))            {              linkObj.Score += 12.5f;              positiveDescendantMatch = true;            }              if (!negativeDescendantMatch && _PrevLink.IsMatch(descendantData))            {              linkObj.Score -= 100;              negativeDescendantMatch = true;            }          }            /*          * If the URL looks like it has paging in it' add to the score.          * Things like /page/2/' /pagenum/2' ?p=3' ?page=11' ?pagination=34          */          if (Regex.IsMatch(linkHref' @"p(a|g|ag)?(e|ing|ination)?(=|\/)[0-9]{1'2}"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"(page|paging)"' RegexOptions.IgnoreCase)           || Regex.IsMatch(linkHref' @"section"' RegexOptions.IgnoreCase))          {            linkObj.Score += 25;          }            /* If the URL contains negative values' give a slight decrease. */          if (_Extraneous.IsMatch(linkHref))          {            linkObj.Score -= 15;          }            /*           * If the link text can be parsed as a number' give it a minor bonus' with a slight           * bias towards lower numbered pages. This is so that pages that might not have 'next'           * in their text can still get scored' and sorted properly by score.           */          int linkTextAsNumber;          bool isInt = int.TryParse(linkText' out linkTextAsNumber);            if (isInt)          {            /* Punish 1 since we're either already there' or it's probably before what we want anyways. */            if (linkTextAsNumber == 1)            {              linkObj.Score -= 10;            }            else            {              linkObj.Score += Math.Max(0' 10 - linkTextAsNumber);            }          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindNextPageLink,The following statement contains a magic number: foreach (string page in possiblePagesByLink.Keys)        {          if (possiblePagesByLink[page].Score >= 50 && (topPage == null || topPage.Score < possiblePagesByLink[page].Score))          {            topPage = possiblePagesByLink[page];          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,StringCompare,The following statement contains a magic number: if (a == b)        {          return 100;        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,StringCompare,The following statement contains a magic number: return sameCharAtIndex / maxLen * 100;
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindBaseUrl,The following statement contains a magic number: for (int i = 0; i < slashLen; i++)        {          string segment = urlSlashes[i];            /* Split off and save anything that looks like a file type. */          if (segment.IndexOf('.') != -1)          {            string possibleType = segment.Split('.')[1];              /* If the type isn't alpha-only' it's probably not actually a file extension. */            if (!Regex.IsMatch(possibleType' "[^a-zA-Z]"))            {              segment = segment.Split('.')[0];            }          }            /*           * EW-CMS specific segment replacement. Ugly.           * Example: http://www.ew.com/ew/article/0''20313460_20369436'00.html          */          if (segment.IndexOf("'00") != -1)          {            segment = segment.Replace("'00"' "");          }            /* If our first or second segment has anything looking like a page number' remove it. */          var pageNumRegex = new Regex("((_|-)?p[a-z]*|(_|-))[0-9]{1'2}$"' RegexOptions.IgnoreCase);            if (pageNumRegex.IsMatch(segment) && ((i == 1) || (i == 0)))          {            segment = pageNumRegex.Replace(segment' "");          }            /* If this is purely a number' and it's the first or second segment' it's probably a page number. Remove it. */          bool del = (i < 2 && Regex.IsMatch(segment' @"^[\d]{1'2}$"));            /* If this is the first segment and it's just "index'" remove it. */          if (i == 0 && segment.ToLower() == "index")          {            del = true;          }            /* If tour first or second segment is smaller than 3 characters' and the first segment was purely alphas' remove it. */          // TODO: Check these "purely alpha" regexes.  They don't seem right.          if (i < 2 && segment.Length < 3 && !Regex.IsMatch(urlSlashes[0]' "[a-z]"' RegexOptions.IgnoreCase))          {            del = true;          }            /* If it's not marked for deletion' push it to cleanedSegments */          if (!del)          {            cleanedSegments.Add(segment);          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindBaseUrl,The following statement contains a magic number: for (int i = 0; i < slashLen; i++)        {          string segment = urlSlashes[i];            /* Split off and save anything that looks like a file type. */          if (segment.IndexOf('.') != -1)          {            string possibleType = segment.Split('.')[1];              /* If the type isn't alpha-only' it's probably not actually a file extension. */            if (!Regex.IsMatch(possibleType' "[^a-zA-Z]"))            {              segment = segment.Split('.')[0];            }          }            /*           * EW-CMS specific segment replacement. Ugly.           * Example: http://www.ew.com/ew/article/0''20313460_20369436'00.html          */          if (segment.IndexOf("'00") != -1)          {            segment = segment.Replace("'00"' "");          }            /* If our first or second segment has anything looking like a page number' remove it. */          var pageNumRegex = new Regex("((_|-)?p[a-z]*|(_|-))[0-9]{1'2}$"' RegexOptions.IgnoreCase);            if (pageNumRegex.IsMatch(segment) && ((i == 1) || (i == 0)))          {            segment = pageNumRegex.Replace(segment' "");          }            /* If this is purely a number' and it's the first or second segment' it's probably a page number. Remove it. */          bool del = (i < 2 && Regex.IsMatch(segment' @"^[\d]{1'2}$"));            /* If this is the first segment and it's just "index'" remove it. */          if (i == 0 && segment.ToLower() == "index")          {            del = true;          }            /* If tour first or second segment is smaller than 3 characters' and the first segment was purely alphas' remove it. */          // TODO: Check these "purely alpha" regexes.  They don't seem right.          if (i < 2 && segment.Length < 3 && !Regex.IsMatch(urlSlashes[0]' "[a-z]"' RegexOptions.IgnoreCase))          {            del = true;          }            /* If it's not marked for deletion' push it to cleanedSegments */          if (!del)          {            cleanedSegments.Add(segment);          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindBaseUrl,The following statement contains a magic number: for (int i = 0; i < slashLen; i++)        {          string segment = urlSlashes[i];            /* Split off and save anything that looks like a file type. */          if (segment.IndexOf('.') != -1)          {            string possibleType = segment.Split('.')[1];              /* If the type isn't alpha-only' it's probably not actually a file extension. */            if (!Regex.IsMatch(possibleType' "[^a-zA-Z]"))            {              segment = segment.Split('.')[0];            }          }            /*           * EW-CMS specific segment replacement. Ugly.           * Example: http://www.ew.com/ew/article/0''20313460_20369436'00.html          */          if (segment.IndexOf("'00") != -1)          {            segment = segment.Replace("'00"' "");          }            /* If our first or second segment has anything looking like a page number' remove it. */          var pageNumRegex = new Regex("((_|-)?p[a-z]*|(_|-))[0-9]{1'2}$"' RegexOptions.IgnoreCase);            if (pageNumRegex.IsMatch(segment) && ((i == 1) || (i == 0)))          {            segment = pageNumRegex.Replace(segment' "");          }            /* If this is purely a number' and it's the first or second segment' it's probably a page number. Remove it. */          bool del = (i < 2 && Regex.IsMatch(segment' @"^[\d]{1'2}$"));            /* If this is the first segment and it's just "index'" remove it. */          if (i == 0 && segment.ToLower() == "index")          {            del = true;          }            /* If tour first or second segment is smaller than 3 characters' and the first segment was purely alphas' remove it. */          // TODO: Check these "purely alpha" regexes.  They don't seem right.          if (i < 2 && segment.Length < 3 && !Regex.IsMatch(urlSlashes[0]' "[a-z]"' RegexOptions.IgnoreCase))          {            del = true;          }            /* If it's not marked for deletion' push it to cleanedSegments */          if (!del)          {            cleanedSegments.Add(segment);          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,FindCandidatesForArticleContent,The following statement contains a magic number: foreach (XElement paraElement in paraElements)        {          string innerText = GetInnerText(paraElement);            if (innerText.Length < _MinParagraphLength)          {            continue;          }            XElement parentElement = paraElement.Parent;          XElement grandParentElement = parentElement != null ? parentElement.Parent : null;          int score = 1; // 1 point for having a paragraph            // Add points for any comma-segments within this paragraph.          score += GetSegmentsCount(innerText' ''');            // For every PARAGRAPH_SEGMENT_LENGTH characters in this paragraph' add another point. Up to MAX_POINTS_FOR_SEGMENTS_COUNT points.          score += Math.Min(innerText.Length / _ParagraphSegmentLength' _MaxPointsForSegmentsCount);            // Add the score to the parent.          if (parentElement != null && !"html".Equals(parentElement.Name.LocalName' StringComparison.OrdinalIgnoreCase))          {            candidateElements.Add(parentElement);            AddPointsToElementScore(parentElement' score);          }            // Add half the score to the grandparent.          if (grandParentElement != null && !"html".Equals(grandParentElement.Name.LocalName' StringComparison.OrdinalIgnoreCase))          {            candidateElements.Add(grandParentElement);            AddPointsToElementScore(grandParentElement' score / 2);          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,GetClassWeight,The following statement contains a magic number: if (elementClass.Length > 0)        {          if (_NegativeWeightRegex.IsMatch(elementClass))          {            weight -= 25;          }            if (_PositiveWeightRegex.IsMatch(elementClass))          {            weight += 25;          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,GetClassWeight,The following statement contains a magic number: if (elementClass.Length > 0)        {          if (_NegativeWeightRegex.IsMatch(elementClass))          {            weight -= 25;          }            if (_PositiveWeightRegex.IsMatch(elementClass))          {            weight += 25;          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,GetClassWeight,The following statement contains a magic number: if (elementId.Length > 0)        {          if (_NegativeWeightRegex.IsMatch(elementId))          {            weight -= 25;          }            if (_PositiveWeightRegex.IsMatch(elementId))          {            weight += 25;          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,GetClassWeight,The following statement contains a magic number: if (elementId.Length > 0)        {          if (_NegativeWeightRegex.IsMatch(elementId))          {            weight -= 25;          }            if (_PositiveWeightRegex.IsMatch(elementId))          {            weight += 25;          }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,CleanConditionally,The following statement contains a magic number: foreach (XElement element in elements)        {          int weight = GetClassWeight(element);          float score = GetElementScore(element);            if (weight + score < 0.0f)          {            elementsToRemove.Add(element);            continue;          }            if (ElementLooksLikeParagraphDiv(element))          {            // leave the element - it's probably just a div pretending to be a paragraph            continue;          }            /* If there are not very many commas and the number of non-paragraph elements           * is more than paragraphs or other ominous signs' remove the element. */          string elementInnerText = GetInnerText(element);            if (GetSegmentsCount(elementInnerText' ''') < _MinCommaSegments)          {            int psCount = element.GetElementsByTagName("p").Count();            int imgsCount = element.GetElementsByTagName("img").Count();            int lisCount = element.GetElementsByTagName("li").Count();            int inputsCount = element.GetElementsByTagName("input").Count();              if (checkImageContainer && imgsCount > 0 && _LikelyImageContainerRegex.IsMatch(element.GetClass()))            {              continue;            }              // while counting embeds we omit video-embeds            int embedsCount =              element.GetElementsByTagName("embed")                .Count(embedElement => !_VideoRegex.IsMatch(embedElement.GetAttributeValue("src"' "")));              float linksDensity = GetLinksDensity(element);            int innerTextLength = elementInnerText.Length;            string elementNameLower = elementName.Trim().ToLower();            bool remove = (imgsCount > psCount)                       || (lisCount - _LisCountTreshold > psCount && elementNameLower != "ul" && elementNameLower != "ol")                       || (inputsCount > psCount / 3)                       || (innerTextLength < _MinInnerTextLength && (imgsCount == 0 || imgsCount > _MaxImagesInShortSegmentsCount))                       || (weight < _ClassWeightTreshold && linksDensity > _MaxDensityForElementsWithSmallerClassWeight)                       || (weight >= _ClassWeightTreshold && linksDensity > _MaxDensityForElementsWithGreaterClassWeight)                       || (embedsCount > _MaxEmbedsCount || (embedsCount == _MaxEmbedsCount && innerTextLength < _MinInnerTextLengthInElementsWithEmbed));              if (remove)            {              elementsToRemove.Add(element);            }            }        }
Magic Number,ReadSharp.Ports.NReadability,NReadabilityTranscoder,C:\repos\ceee_ReadSharp\PortablePorts\NReadability\NReadabilityTranscoder.cs,CleanHeaders,The following statement contains a magic number: for (int headerLevel = 1; headerLevel < 7; headerLevel++)        {          IEnumerable<XElement> headerElements = element.GetElementsByTagName("h" + headerLevel);            foreach (XElement headerElement in headerElements)          {            if (GetClassWeight(headerElement) < 0             || GetLinksDensity(headerElement) > _MaxHeaderLinksDensity)            {              elementsToRemove.Add(headerElement);            }          }        }
