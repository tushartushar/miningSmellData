Implementation smell,Namespace,Class,File,Method,Description
Long Method,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The method has 116 lines of code.
Long Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The method has 108 lines of code.
Long Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The method has 220 lines of code.
Long Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The method has 319 lines of code.
Long Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The method has 164 lines of code.
Long Method,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The method has 156 lines of code.
Complex Method,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,OnLoad,Cyclomatic complexity of the method is 9
Complex Method,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,Cyclomatic complexity of the method is 9
Complex Method,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,getAvailableScience,Cyclomatic complexity of the method is 9
Complex Method,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,scanFromAllVessels,Cyclomatic complexity of the method is 8
Complex Method,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,Cyclomatic complexity of the method is 24
Complex Method,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,Cyclomatic complexity of the method is 12
Complex Method,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,Cyclomatic complexity of the method is 17
Complex Method,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,Cyclomatic complexity of the method is 11
Complex Method,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,OnUpdate,Cyclomatic complexity of the method is 14
Complex Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,orbitIconForVesselType,Cyclomatic complexity of the method is 11
Complex Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,Cyclomatic complexity of the method is 62
Complex Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,Cyclomatic complexity of the method is 27
Complex Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,Cyclomatic complexity of the method is 22
Complex Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,Cyclomatic complexity of the method is 16
Complex Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,Cyclomatic complexity of the method is 48
Complex Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,Cyclomatic complexity of the method is 68
Complex Method,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,Cyclomatic complexity of the method is 42
Complex Method,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,Cyclomatic complexity of the method is 10
Complex Method,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,Cyclomatic complexity of the method is 21
Complex Method,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,Cyclomatic complexity of the method is 14
Complex Method,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,Cyclomatic complexity of the method is 33
Complex Method,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,setup,Cyclomatic complexity of the method is 10
Complex Method,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,Cyclomatic complexity of the method is 11
Long Parameter List,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The method has 6 parameters.
Long Parameter List,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The method has 6 parameters.
Long Parameter List,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The method has 6 parameters.
Long Parameter List,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The method has 6 parameters.
Long Parameter List,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The method has 5 parameters.
Long Parameter List,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The method has 6 parameters.
Long Statement,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,getAvailableScience,The length of the statement  "	print ("[SCANsat] coverage " + coverage.ToString ("F1") + "' science cap " + su.scienceCap.ToString ("F1") + "' subject value " + su.subjectValue.ToString ("F2") + "' science value " + su.scientificValue.ToString ("F2") + "' science " + su.science.ToString ("F2")); " is 265.
Long Statement,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getAnomalies,The length of the statement  "			anomalies [i] = new SCANanomaly (sites [i].name' body.GetLongitude (sites [i].transform.position)' body.GetLatitude (sites [i].transform.position)' sites [i]); " is 159.
Long Statement,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The length of the statement  "			if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) { " is 223.
Long Statement,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,OnStart,The length of the statement  "	print ("[SCANsat] sensorType: " + sensorType.ToString () + " fov: " + fov.ToString () + " min_alt: " + min_alt.ToString () + " max_alt: " + max_alt.ToString () + " best_alt: " + best_alt.ToString () + " power: " + power.ToString ()); " is 233.
Long Statement,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The length of the statement  "			map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value)); " is 149.
Long Statement,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,ReviewDataItem,The length of the statement  "	expDialog = ExperimentsResultDialog.DisplayResult (new ExperimentResultDialogPage (part' sd' 1f' 0f' false' ""' true' false' DumpData' KeepData' TransmitData' null)); " is 166.
Long Statement,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,ReviewData,The length of the statement  "	expDialog = ExperimentsResultDialog.DisplayResult (new ExperimentResultDialogPage (part' sd' 1f' 0f' false' ""' true' false' DumpData' KeepData' TransmitData' null)); " is 166.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The length of the statement  "						string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)"; " is 160.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The length of the statement  "		if (data.isCovered (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude' SCANdata.SCANtype.AltimetryHiRes)) { " is 131.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The length of the statement  "		if (data.isCovered (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude' SCANdata.SCANtype.Biome)) { " is 122.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The length of the statement  "			GUILayout.Label (data.getBiomeName (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude)' style_readout); " is 127.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The length of the statement  "	SCANcontroller.controller.scan_background = GUILayout.Toggle (SCANcontroller.controller.scan_background' "Scan all active celestials"); " is 135.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The length of the statement  "		data.disabled = !GUILayout.Toggle (!data.disabled' body.bodyName + " (" + data.getCoveragePercentage (SCANdata.SCANtype.Nothing).ToString ("N1") + "%)"); " is 153.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The length of the statement  "	string txt = "Sensors: " + SCANcontroller.activeSensors.ToString () + " Vessels: " + SCANcontroller.activeVessels.ToString () + " Passes: " + SCANcontroller.controller.actualPasses.ToString (); " is 193.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The length of the statement  "		if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) { " is 171.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The length of the statement  "			if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) { " is 137.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The length of the statement  "			if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) { " is 137.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The length of the statement  "			if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) { " is 184.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The length of the statement  "		infotext = stat_alo + "LO" + ac + stat_ahi + "HI" + ac + stat_biome + "BIO" + ac + stat_ano + "ANOM" + ac + stat_btdt + "BTDT" + ac; " is 132.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The length of the statement  "	pos_infobox = GUILayout.Window (47110001' pos_infobox' gui_infobox_build' title' GUILayout.Width (32)' GUILayout.Height (32)); " is 126.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The length of the statement  "		pos_bigmap = GUILayout.Window (47110002' pos_bigmap' gui_bigmap_build' "Map of " + vessel.mainBody.theName + rendering' GUILayout.Width (360)' GUILayout.Height (180)); " is 167.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The length of the statement  "		pos_instruments = GUILayout.Window (47110003' pos_instruments' gui_instruments_build' "S.C.A.N. Instruments"' GUILayout.Width (200)' GUILayout.Height (60)); " is 156.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The length of the statement  "		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180)); " is 145.
Long Statement,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The length of the statement  "			pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180)); " is 145.
Long Statement,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,The length of the statement  "		GUI.Label (r' left (distanceString ((FlightGlobals.ActiveVessel.transform.position - lookvec).magnitude)' chars)' style); " is 121.
Complex Conditional,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,registerPass,The conditional expression  "ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180"  is complex.
Complex Conditional,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,isCovered,The conditional expression  "ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180"  is complex.
Complex Conditional,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,isCoveredByAll,The conditional expression  "ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180"  is complex.
Complex Conditional,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The conditional expression  "(x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)"  is complex.
Complex Conditional,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getBiomeIndex,The conditional expression  "u < 0 || v < 0 || u >= 360 || v >= 180"  is complex.
Complex Conditional,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The conditional expression  "(off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]"  is complex.
Complex Conditional,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The conditional expression  "lat < 0 || lon < 0 || lat > 180 || lon > 360"  is complex.
Complex Conditional,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The conditional expression  "lat < 0 || lon < 0 || lat > 180 || lon > 360"  is complex.
Complex Conditional,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The conditional expression  "lat < 0 || lon < 0 || lat > 180 || lon > 360"  is complex.
Complex Conditional,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The conditional expression  "lat < 0 || lon < 0 || lat > 180 || lon > 360"  is complex.
Complex Conditional,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The conditional expression  "n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)"  is complex.
Complex Conditional,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The conditional expression  "mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging"  is complex.
Complex Conditional,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The conditional expression  "mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y"  is complex.
Complex Conditional,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The conditional expression  "mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90"  is complex.
Complex Conditional,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getLegend,The conditional expression  "legend != null && legendMin == min && legendMax == max && legendScheme == scheme"  is complex.
Complex Conditional,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The conditional expression  "double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180"  is complex.
Complex Conditional,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The conditional expression  "(i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)"  is complex.
Complex Conditional,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The conditional expression  "(i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)"  is complex.
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: foreach (SCANdata.SCANtype sensor in Enum.GetValues (typeof(SCANdata.SCANtype))) {  	if (countBits ((int)sensor) != 1)  		continue;  	if ((sensor & sensors) == SCANdata.SCANtype.Nothing)  		continue;  	double this_fov = fov' this_min_alt = min_alt' this_max_alt = max_alt' this_best_alt = best_alt;  	if (this_max_alt <= 0) {  		this_min_alt = 5000;  		this_max_alt = 500000;  		this_best_alt = 200000;  		this_fov = 5;  		if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  			this_fov = 3;  		if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  			this_min_alt = 0;  			this_max_alt = 2000;  			this_best_alt = 0;  			this_fov = 1;  		}  	}  	if (!sv.sensors.ContainsKey (sensor))  		sv.sensors [sensor] = new SCANsensor ();  	SCANsensor s = sv.sensors [sensor];  	s.sensor = sensor;  	s.fov = this_fov;  	s.min_alt = this_min_alt;  	s.max_alt = this_max_alt;  	s.best_alt = this_best_alt;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: foreach (SCANdata.SCANtype sensor in Enum.GetValues (typeof(SCANdata.SCANtype))) {  	if (countBits ((int)sensor) != 1)  		continue;  	if ((sensor & sensors) == SCANdata.SCANtype.Nothing)  		continue;  	double this_fov = fov' this_min_alt = min_alt' this_max_alt = max_alt' this_best_alt = best_alt;  	if (this_max_alt <= 0) {  		this_min_alt = 5000;  		this_max_alt = 500000;  		this_best_alt = 200000;  		this_fov = 5;  		if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  			this_fov = 3;  		if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  			this_min_alt = 0;  			this_max_alt = 2000;  			this_best_alt = 0;  			this_fov = 1;  		}  	}  	if (!sv.sensors.ContainsKey (sensor))  		sv.sensors [sensor] = new SCANsensor ();  	SCANsensor s = sv.sensors [sensor];  	s.sensor = sensor;  	s.fov = this_fov;  	s.min_alt = this_min_alt;  	s.max_alt = this_max_alt;  	s.best_alt = this_best_alt;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: foreach (SCANdata.SCANtype sensor in Enum.GetValues (typeof(SCANdata.SCANtype))) {  	if (countBits ((int)sensor) != 1)  		continue;  	if ((sensor & sensors) == SCANdata.SCANtype.Nothing)  		continue;  	double this_fov = fov' this_min_alt = min_alt' this_max_alt = max_alt' this_best_alt = best_alt;  	if (this_max_alt <= 0) {  		this_min_alt = 5000;  		this_max_alt = 500000;  		this_best_alt = 200000;  		this_fov = 5;  		if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  			this_fov = 3;  		if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  			this_min_alt = 0;  			this_max_alt = 2000;  			this_best_alt = 0;  			this_fov = 1;  		}  	}  	if (!sv.sensors.ContainsKey (sensor))  		sv.sensors [sensor] = new SCANsensor ();  	SCANsensor s = sv.sensors [sensor];  	s.sensor = sensor;  	s.fov = this_fov;  	s.min_alt = this_min_alt;  	s.max_alt = this_max_alt;  	s.best_alt = this_best_alt;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: foreach (SCANdata.SCANtype sensor in Enum.GetValues (typeof(SCANdata.SCANtype))) {  	if (countBits ((int)sensor) != 1)  		continue;  	if ((sensor & sensors) == SCANdata.SCANtype.Nothing)  		continue;  	double this_fov = fov' this_min_alt = min_alt' this_max_alt = max_alt' this_best_alt = best_alt;  	if (this_max_alt <= 0) {  		this_min_alt = 5000;  		this_max_alt = 500000;  		this_best_alt = 200000;  		this_fov = 5;  		if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  			this_fov = 3;  		if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  			this_min_alt = 0;  			this_max_alt = 2000;  			this_best_alt = 0;  			this_fov = 1;  		}  	}  	if (!sv.sensors.ContainsKey (sensor))  		sv.sensors [sensor] = new SCANsensor ();  	SCANsensor s = sv.sensors [sensor];  	s.sensor = sensor;  	s.fov = this_fov;  	s.min_alt = this_min_alt;  	s.max_alt = this_max_alt;  	s.best_alt = this_best_alt;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: foreach (SCANdata.SCANtype sensor in Enum.GetValues (typeof(SCANdata.SCANtype))) {  	if (countBits ((int)sensor) != 1)  		continue;  	if ((sensor & sensors) == SCANdata.SCANtype.Nothing)  		continue;  	double this_fov = fov' this_min_alt = min_alt' this_max_alt = max_alt' this_best_alt = best_alt;  	if (this_max_alt <= 0) {  		this_min_alt = 5000;  		this_max_alt = 500000;  		this_best_alt = 200000;  		this_fov = 5;  		if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  			this_fov = 3;  		if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  			this_min_alt = 0;  			this_max_alt = 2000;  			this_best_alt = 0;  			this_fov = 1;  		}  	}  	if (!sv.sensors.ContainsKey (sensor))  		sv.sensors [sensor] = new SCANsensor ();  	SCANsensor s = sv.sensors [sensor];  	s.sensor = sensor;  	s.fov = this_fov;  	s.min_alt = this_min_alt;  	s.max_alt = this_max_alt;  	s.best_alt = this_best_alt;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: foreach (SCANdata.SCANtype sensor in Enum.GetValues (typeof(SCANdata.SCANtype))) {  	if (countBits ((int)sensor) != 1)  		continue;  	if ((sensor & sensors) == SCANdata.SCANtype.Nothing)  		continue;  	double this_fov = fov' this_min_alt = min_alt' this_max_alt = max_alt' this_best_alt = best_alt;  	if (this_max_alt <= 0) {  		this_min_alt = 5000;  		this_max_alt = 500000;  		this_best_alt = 200000;  		this_fov = 5;  		if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  			this_fov = 3;  		if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  			this_min_alt = 0;  			this_max_alt = 2000;  			this_best_alt = 0;  			this_fov = 1;  		}  	}  	if (!sv.sensors.ContainsKey (sensor))  		sv.sensors [sensor] = new SCANsensor ();  	SCANsensor s = sv.sensors [sensor];  	s.sensor = sensor;  	s.fov = this_fov;  	s.min_alt = this_min_alt;  	s.max_alt = this_max_alt;  	s.best_alt = this_best_alt;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: if (this_max_alt <= 0) {  	this_min_alt = 5000;  	this_max_alt = 500000;  	this_best_alt = 200000;  	this_fov = 5;  	if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  		this_fov = 3;  	if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		this_min_alt = 0;  		this_max_alt = 2000;  		this_best_alt = 0;  		this_fov = 1;  	}  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: if (this_max_alt <= 0) {  	this_min_alt = 5000;  	this_max_alt = 500000;  	this_best_alt = 200000;  	this_fov = 5;  	if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  		this_fov = 3;  	if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		this_min_alt = 0;  		this_max_alt = 2000;  		this_best_alt = 0;  		this_fov = 1;  	}  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: if (this_max_alt <= 0) {  	this_min_alt = 5000;  	this_max_alt = 500000;  	this_best_alt = 200000;  	this_fov = 5;  	if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  		this_fov = 3;  	if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		this_min_alt = 0;  		this_max_alt = 2000;  		this_best_alt = 0;  		this_fov = 1;  	}  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: if (this_max_alt <= 0) {  	this_min_alt = 5000;  	this_max_alt = 500000;  	this_best_alt = 200000;  	this_fov = 5;  	if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  		this_fov = 3;  	if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		this_min_alt = 0;  		this_max_alt = 2000;  		this_best_alt = 0;  		this_fov = 1;  	}  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: if (this_max_alt <= 0) {  	this_min_alt = 5000;  	this_max_alt = 500000;  	this_best_alt = 200000;  	this_fov = 5;  	if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  		this_fov = 3;  	if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		this_min_alt = 0;  		this_max_alt = 2000;  		this_best_alt = 0;  		this_fov = 1;  	}  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: if (this_max_alt <= 0) {  	this_min_alt = 5000;  	this_max_alt = 500000;  	this_best_alt = 200000;  	this_fov = 5;  	if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  		this_fov = 3;  	if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		this_min_alt = 0;  		this_max_alt = 2000;  		this_best_alt = 0;  		this_fov = 1;  	}  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: this_min_alt = 5000;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: this_max_alt = 500000;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: this_best_alt = 200000;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: this_fov = 5;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: if ((sensor & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing)  	this_fov = 3;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: this_fov = 3;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: if ((sensor & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  	this_min_alt = 0;  	this_max_alt = 2000;  	this_best_alt = 0;  	this_fov = 1;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,registerSensor,The following statement contains a magic number: this_max_alt = 2000;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,getAvailableScience,The following statement contains a magic number: if (science > 95)  	science = 100;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,getAvailableScience,The following statement contains a magic number: if (science > 95)  	science = 100;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,getAvailableScience,The following statement contains a magic number: science = 100;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,getAvailableScience,The following statement contains a magic number: if (science < 30)  	science = 0;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,fixLatitude,The following statement contains a magic number: return (lat + 90 + 180) % 180 - 90;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,fixLatitude,The following statement contains a magic number: return (lat + 90 + 180) % 180 - 90;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,fixLatitude,The following statement contains a magic number: return (lat + 90 + 180) % 180 - 90;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,fixLatitude,The following statement contains a magic number: return (lat + 90 + 180) % 180 - 90;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,fixLongitude,The following statement contains a magic number: return (lon + 180 + 360) % 360 - 180;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,fixLongitude,The following statement contains a magic number: return (lon + 180 + 360) % 360 - 180;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,fixLongitude,The following statement contains a magic number: return (lon + 180 + 360) % 360 - 180;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,fixLongitude,The following statement contains a magic number: return (lon + 180 + 360) % 360 - 180;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: if (res > 0) {  	if (double.IsNaN (UT))  		goto dequeue;  	if (o.ObT <= 0)  		goto dequeue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		goto dequeue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (v.mainBody.rotates) {  		rotation = (360 * ((UT - scan_UT) / v.mainBody.rotationPeriod)) % 360;  	}  	alt = v.mainBody.GetAltitude (pos);  	lat = fixLatitude (v.mainBody.GetLatitude (pos));  	lon = fixLongitude (v.mainBody.GetLongitude (pos) - rotation);  	if (alt < 0)  		alt = 0;  	if (res > maxRes)  		maxRes = (int)res;  }  else {  	alt = v.heightFromTerrain;  	if (alt < 0)  		alt = v.altitude;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: if (res > 0) {  	if (double.IsNaN (UT))  		goto dequeue;  	if (o.ObT <= 0)  		goto dequeue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		goto dequeue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (v.mainBody.rotates) {  		rotation = (360 * ((UT - scan_UT) / v.mainBody.rotationPeriod)) % 360;  	}  	alt = v.mainBody.GetAltitude (pos);  	lat = fixLatitude (v.mainBody.GetLatitude (pos));  	lon = fixLongitude (v.mainBody.GetLongitude (pos) - rotation);  	if (alt < 0)  		alt = 0;  	if (res > maxRes)  		maxRes = (int)res;  }  else {  	alt = v.heightFromTerrain;  	if (alt < 0)  		alt = v.altitude;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: if (v.mainBody.rotates) {  	rotation = (360 * ((UT - scan_UT) / v.mainBody.rotationPeriod)) % 360;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: if (v.mainBody.rotates) {  	rotation = (360 * ((UT - scan_UT) / v.mainBody.rotationPeriod)) % 360;  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: rotation = (360 * ((UT - scan_UT) / v.mainBody.rotationPeriod)) % 360;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: rotation = (360 * ((UT - scan_UT) / v.mainBody.rotationPeriod)) % 360;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: foreach (SCANsensor sensor in knownVessels [v.id].sensors.Values) {  	if (res <= 0) {  		if (data.getCoverage (sensor.sensor) > 0)  			uncovered = false;  	}  	sensor.inRange = false;  	sensor.bestRange = false;  	if (alt < sensor.min_alt)  		continue;  	if (alt > Math.Min (sensor.max_alt' soi_radius))  		continue;  	sensor.inRange = true;  	double fov = sensor.fov;  	double ba = Math.Min (sensor.best_alt' soi_radius);  	if (alt < ba)  		fov = (alt / ba) * fov;  	else  		sensor.bestRange = true;  	double surfscale = 600000d / v.mainBody.Radius;  	if (surfscale < 1)  		surfscale = 1;  	surfscale = Math.Sqrt (surfscale);  	fov *= surfscale;  	if (fov > 20)  		fov = 20;  	int f = (int)Math.Truncate (fov);  	int f1 = f + (int)Math.Round (fov - f);  	for (int x = -f; x <= f1; ++x) {  		for (int y = -f; y <= f1; ++y) {  			data.registerPass (lon + x' lat + y' sensor.sensor);  		}  	}  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: foreach (SCANsensor sensor in knownVessels [v.id].sensors.Values) {  	if (res <= 0) {  		if (data.getCoverage (sensor.sensor) > 0)  			uncovered = false;  	}  	sensor.inRange = false;  	sensor.bestRange = false;  	if (alt < sensor.min_alt)  		continue;  	if (alt > Math.Min (sensor.max_alt' soi_radius))  		continue;  	sensor.inRange = true;  	double fov = sensor.fov;  	double ba = Math.Min (sensor.best_alt' soi_radius);  	if (alt < ba)  		fov = (alt / ba) * fov;  	else  		sensor.bestRange = true;  	double surfscale = 600000d / v.mainBody.Radius;  	if (surfscale < 1)  		surfscale = 1;  	surfscale = Math.Sqrt (surfscale);  	fov *= surfscale;  	if (fov > 20)  		fov = 20;  	int f = (int)Math.Truncate (fov);  	int f1 = f + (int)Math.Round (fov - f);  	for (int x = -f; x <= f1; ++x) {  		for (int y = -f; y <= f1; ++y) {  			data.registerPass (lon + x' lat + y' sensor.sensor);  		}  	}  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: if (fov > 20)  	fov = 20;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: if (fov > 20)  	fov = 20;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: fov = 20;  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: if (startUT > UT) {  	scanQueue.Enqueue ((startUT + UT) / 2);  	scanQueue.Enqueue (startUT);  	scanQueue.Enqueue (UT);  	scanQueue.Enqueue (lat);  	scanQueue.Enqueue (lon);  	scanQueue.Enqueue (res + 1);  }  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: scanQueue.Enqueue ((startUT + UT) / 2);  
Magic Number,SCANsat,SCANcontroller,C:\repos\thatfool_SCAN\SCANcontroller.cs,doScanPass,The following statement contains a magic number: UT = (lastUT + UT) / 2;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,registerPass,The following statement contains a magic number: if (ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180)  	return;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,registerPass,The following statement contains a magic number: if (ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180)  	return;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,isCovered,The following statement contains a magic number: if (ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180)  	return false;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,isCovered,The following statement contains a magic number: if (ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180)  	return false;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,isCoveredByAll,The following statement contains a magic number: if (ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180)  	return false;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,isCoveredByAll,The following statement contains a magic number: if (ilon < 0 || ilat < 0 || ilon >= 360 || ilat >= 180)  	return false;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateCoverage,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	SCANtype t = (SCANtype)(1 << i);  	int cc = 0;  	for (int x = 0; x < 360; ++x) {  		for (int y = 0; y < 180; ++y) {  			if ((coverage [x' y] & (byte)t) == 0)  				++cc;  		}  	}  	coverage_count [i] = cc;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateCoverage,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	SCANtype t = (SCANtype)(1 << i);  	int cc = 0;  	for (int x = 0; x < 360; ++x) {  		for (int y = 0; y < 180; ++y) {  			if ((coverage [x' y] & (byte)t) == 0)  				++cc;  		}  	}  	coverage_count [i] = cc;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateCoverage,The following statement contains a magic number: for (int i = 0; i < 6; ++i) {  	SCANtype t = (SCANtype)(1 << i);  	int cc = 0;  	for (int x = 0; x < 360; ++x) {  		for (int y = 0; y < 180; ++y) {  			if ((coverage [x' y] & (byte)t) == 0)  				++cc;  		}  	}  	coverage_count [i] = cc;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateCoverage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	for (int y = 0; y < 180; ++y) {  		if ((coverage [x' y] & (byte)t) == 0)  			++cc;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateCoverage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	for (int y = 0; y < 180; ++y) {  		if ((coverage [x' y] & (byte)t) == 0)  			++cc;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateCoverage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	if ((coverage [x' y] & (byte)t) == 0)  		++cc;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoverage,The following statement contains a magic number: if ((type & SCANtype.Biome) != SCANtype.Nothing)  	uncov += coverage_count [3];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoverage,The following statement contains a magic number: uncov += coverage_count [3];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoverage,The following statement contains a magic number: if ((type & SCANtype.Anomaly) != SCANtype.Nothing)  	uncov += coverage_count [4];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoverage,The following statement contains a magic number: uncov += coverage_count [4];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoverage,The following statement contains a magic number: if ((type & SCANtype.AnomalyDetail) != SCANtype.Nothing)  	uncov += coverage_count [5];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoverage,The following statement contains a magic number: uncov += coverage_count [5];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoveragePercentage,The following statement contains a magic number: if (cov <= 0) {  	cov = 100;  }  else {  	cov = Math.Min (99.9d' 100 - cov * 100d / (360d * 180d * SCANcontroller.countBits ((int)type)));  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoveragePercentage,The following statement contains a magic number: if (cov <= 0) {  	cov = 100;  }  else {  	cov = Math.Min (99.9d' 100 - cov * 100d / (360d * 180d * SCANcontroller.countBits ((int)type)));  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoveragePercentage,The following statement contains a magic number: cov = 100;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getCoveragePercentage,The following statement contains a magic number: cov = Math.Min (99.9d' 100 - cov * 100d / (360d * 180d * SCANcontroller.countBits ((int)type)));  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,deserialize,The following statement contains a magic number: try {  	blob = blob.Replace ("-"' "/").Replace ("_"' "=");  	byte[] bytes = Convert.FromBase64String (blob);  	bytes = CLZF2.Decompress (bytes);  	MemoryStream mem = new MemoryStream (bytes' false);  	BinaryFormatter binf = new BinaryFormatter ();  	coverage = (byte['])binf.Deserialize (mem);  }  catch (Exception e) {  	coverage = new byte[360' 180];  	heightmap = new float[360' 180];  	throw e;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,deserialize,The following statement contains a magic number: try {  	blob = blob.Replace ("-"' "/").Replace ("_"' "=");  	byte[] bytes = Convert.FromBase64String (blob);  	bytes = CLZF2.Decompress (bytes);  	MemoryStream mem = new MemoryStream (bytes' false);  	BinaryFormatter binf = new BinaryFormatter ();  	coverage = (byte['])binf.Deserialize (mem);  }  catch (Exception e) {  	coverage = new byte[360' 180];  	heightmap = new float[360' 180];  	throw e;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,deserialize,The following statement contains a magic number: try {  	blob = blob.Replace ("-"' "/").Replace ("_"' "=");  	byte[] bytes = Convert.FromBase64String (blob);  	bytes = CLZF2.Decompress (bytes);  	MemoryStream mem = new MemoryStream (bytes' false);  	BinaryFormatter binf = new BinaryFormatter ();  	coverage = (byte['])binf.Deserialize (mem);  }  catch (Exception e) {  	coverage = new byte[360' 180];  	heightmap = new float[360' 180];  	throw e;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,deserialize,The following statement contains a magic number: try {  	blob = blob.Replace ("-"' "/").Replace ("_"' "=");  	byte[] bytes = Convert.FromBase64String (blob);  	bytes = CLZF2.Decompress (bytes);  	MemoryStream mem = new MemoryStream (bytes' false);  	BinaryFormatter binf = new BinaryFormatter ();  	coverage = (byte['])binf.Deserialize (mem);  }  catch (Exception e) {  	coverage = new byte[360' 180];  	heightmap = new float[360' 180];  	throw e;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,deserialize,The following statement contains a magic number: coverage = new byte[360' 180];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,deserialize,The following statement contains a magic number: coverage = new byte[360' 180];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,deserialize,The following statement contains a magic number: heightmap = new float[360' 180];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,deserialize,The following statement contains a magic number: heightmap = new float[360' 180];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,reset,The following statement contains a magic number: coverage = new byte[360' 180];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,reset,The following statement contains a magic number: coverage = new byte[360' 180];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,reset,The following statement contains a magic number: heightmap = new float[360' 180];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,reset,The following statement contains a magic number: heightmap = new float[360' 180];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: for (int y = 0; y < map_small.height; y++) {  	for (int x = 0; x < map_small.width; x++) {  		if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  			map_small.SetPixel (x' y' Color.white);  		}  		else {  			map_small.SetPixel (x' y' Color.grey);  		}  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: for (int y = 0; y < map_small.height; y++) {  	for (int x = 0; x < map_small.width; x++) {  		if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  			map_small.SetPixel (x' y' Color.white);  		}  		else {  			map_small.SetPixel (x' y' Color.grey);  		}  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: for (int y = 0; y < map_small.height; y++) {  	for (int x = 0; x < map_small.width; x++) {  		if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  			map_small.SetPixel (x' y' Color.white);  		}  		else {  			map_small.SetPixel (x' y' Color.grey);  		}  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: for (int y = 0; y < map_small.height; y++) {  	for (int x = 0; x < map_small.width; x++) {  		if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  			map_small.SetPixel (x' y' Color.white);  		}  		else {  			map_small.SetPixel (x' y' Color.grey);  		}  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: for (int x = 0; x < map_small.width; x++) {  	if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  		map_small.SetPixel (x' y' Color.white);  	}  	else {  		map_small.SetPixel (x' y' Color.grey);  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: for (int x = 0; x < map_small.width; x++) {  	if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  		map_small.SetPixel (x' y' Color.white);  	}  	else {  		map_small.SetPixel (x' y' Color.grey);  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: for (int x = 0; x < map_small.width; x++) {  	if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  		map_small.SetPixel (x' y' Color.white);  	}  	else {  		map_small.SetPixel (x' y' Color.grey);  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: for (int x = 0; x < map_small.width; x++) {  	if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  		map_small.SetPixel (x' y' Color.white);  	}  	else {  		map_small.SetPixel (x' y' Color.grey);  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  	map_small.SetPixel (x' y' Color.white);  }  else {  	map_small.SetPixel (x' y' Color.grey);  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  	map_small.SetPixel (x' y' Color.white);  }  else {  	map_small.SetPixel (x' y' Color.grey);  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  	map_small.SetPixel (x' y' Color.white);  }  else {  	map_small.SetPixel (x' y' Color.grey);  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,resetImages,The following statement contains a magic number: if ((x % 30 == 0 && y % 3 > 0) || (y % 30 == 0 && x % 3 > 0)) {  	map_small.SetPixel (x' y' Color.white);  }  else {  	map_small.SetPixel (x' y' Color.grey);  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateImages,The following statement contains a magic number: if (redline == null) {  	redline = new Color[360];  	for (int i = 0; i < 360; i++)  		redline [i] = Color.red;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateImages,The following statement contains a magic number: if (redline == null) {  	redline = new Color[360];  	for (int i = 0; i < 360; i++)  		redline [i] = Color.red;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateImages,The following statement contains a magic number: redline = new Color[360];  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateImages,The following statement contains a magic number: for (int i = 0; i < 360; i++)  	redline [i] = Color.red;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateImages,The following statement contains a magic number: if (scanline < 179) {  	map_small.SetPixels (0' scanline + 1' 360' 1' redline);  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateImages,The following statement contains a magic number: if (scanline < 179) {  	map_small.SetPixels (0' scanline + 1' 360' 1' redline);  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,updateImages,The following statement contains a magic number: map_small.SetPixels (0' scanline + 1' 360' 1' redline);  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getBiomeIndex,The following statement contains a magic number: if (u < 0 || v < 0 || u >= 360 || v >= 180)  	return -1;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,getBiomeIndex,The following statement contains a magic number: if (u < 0 || v < 0 || u >= 360 || v >= 180)  	return -1;  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: for (int ilon = 0; ilon < 360; ilon += 1) {  	int scheme = 0;  	float val = heightmap [ilon' scanline];  	if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  		if (body.pqsController == null) {  			heightmap [ilon' scanline] = 0;  			cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		else {  			// convert to radial vector  			double rlon = Mathf.Deg2Rad * (ilon - 180);  			double rlat = Mathf.Deg2Rad * (scanline - 90);  			Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  			// query terrain controller for elevation at this point  			val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  			if (val == 0)  				val = -0.001f;  			// this is terrible  			heightmap [ilon' scanline] = val;  		}  	}  	Color c = Color.black;  	if (val != 0) {  		if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  			c = SCANmap.heightToColor (val' scheme);  		else  			c = SCANmap.heightToColor (val' 1);  	}  	else {  		c = Color.grey;  		if (scanline % 30 == 0 && ilon % 3 == 0) {  			c = Color.white;  		}  		else if (ilon % 30 == 0 && scanline % 3 == 0) {  			c = Color.white;  		}  	}  	if (type != SCANtype.Nothing) {  		if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  			c = Color.Lerp (c' Color.black' 0.5f);  		}  	}  	cols_height_map_small [ilon] = c;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  	if (body.pqsController == null) {  		heightmap [ilon' scanline] = 0;  		cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	else {  		// convert to radial vector  		double rlon = Mathf.Deg2Rad * (ilon - 180);  		double rlat = Mathf.Deg2Rad * (scanline - 90);  		Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  		// query terrain controller for elevation at this point  		val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  		if (val == 0)  			val = -0.001f;  		// this is terrible  		heightmap [ilon' scanline] = val;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  	if (body.pqsController == null) {  		heightmap [ilon' scanline] = 0;  		cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	else {  		// convert to radial vector  		double rlon = Mathf.Deg2Rad * (ilon - 180);  		double rlat = Mathf.Deg2Rad * (scanline - 90);  		Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  		// query terrain controller for elevation at this point  		val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  		if (val == 0)  			val = -0.001f;  		// this is terrible  		heightmap [ilon' scanline] = val;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  	if (body.pqsController == null) {  		heightmap [ilon' scanline] = 0;  		cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	else {  		// convert to radial vector  		double rlon = Mathf.Deg2Rad * (ilon - 180);  		double rlat = Mathf.Deg2Rad * (scanline - 90);  		Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  		// query terrain controller for elevation at this point  		val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  		if (val == 0)  			val = -0.001f;  		// this is terrible  		heightmap [ilon' scanline] = val;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val == 0 && isCovered (ilon - 180' scanline - 90' SCANtype.Altimetry)) {  	if (body.pqsController == null) {  		heightmap [ilon' scanline] = 0;  		cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	else {  		// convert to radial vector  		double rlon = Mathf.Deg2Rad * (ilon - 180);  		double rlat = Mathf.Deg2Rad * (scanline - 90);  		Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  		// query terrain controller for elevation at this point  		val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  		if (val == 0)  			val = -0.001f;  		// this is terrible  		heightmap [ilon' scanline] = val;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (body.pqsController == null) {  	heightmap [ilon' scanline] = 0;  	cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  	continue;  }  else {  	// convert to radial vector  	double rlon = Mathf.Deg2Rad * (ilon - 180);  	double rlat = Mathf.Deg2Rad * (scanline - 90);  	Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  	// query terrain controller for elevation at this point  	val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  	if (val == 0)  		val = -0.001f;  	// this is terrible  	heightmap [ilon' scanline] = val;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (body.pqsController == null) {  	heightmap [ilon' scanline] = 0;  	cols_height_map_small [ilon] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  	continue;  }  else {  	// convert to radial vector  	double rlon = Mathf.Deg2Rad * (ilon - 180);  	double rlat = Mathf.Deg2Rad * (scanline - 90);  	Vector3d rad = new Vector3d (Math.Cos (rlat) * Math.Cos (rlon)' Math.Sin (rlat)' Math.Cos (rlat) * Math.Sin (rlon));  	// query terrain controller for elevation at this point  	val = (float)Math.Round (body.pqsController.GetSurfaceHeight (rad) - body.pqsController.radius' 1);  	if (val == 0)  		val = -0.001f;  	// this is terrible  	heightmap [ilon' scanline] = val;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val != 0) {  	if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  		c = SCANmap.heightToColor (val' scheme);  	else  		c = SCANmap.heightToColor (val' 1);  }  else {  	c = Color.grey;  	if (scanline % 30 == 0 && ilon % 3 == 0) {  		c = Color.white;  	}  	else if (ilon % 30 == 0 && scanline % 3 == 0) {  		c = Color.white;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val != 0) {  	if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  		c = SCANmap.heightToColor (val' scheme);  	else  		c = SCANmap.heightToColor (val' 1);  }  else {  	c = Color.grey;  	if (scanline % 30 == 0 && ilon % 3 == 0) {  		c = Color.white;  	}  	else if (ilon % 30 == 0 && scanline % 3 == 0) {  		c = Color.white;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val != 0) {  	if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  		c = SCANmap.heightToColor (val' scheme);  	else  		c = SCANmap.heightToColor (val' 1);  }  else {  	c = Color.grey;  	if (scanline % 30 == 0 && ilon % 3 == 0) {  		c = Color.white;  	}  	else if (ilon % 30 == 0 && scanline % 3 == 0) {  		c = Color.white;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val != 0) {  	if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  		c = SCANmap.heightToColor (val' scheme);  	else  		c = SCANmap.heightToColor (val' 1);  }  else {  	c = Color.grey;  	if (scanline % 30 == 0 && ilon % 3 == 0) {  		c = Color.white;  	}  	else if (ilon % 30 == 0 && scanline % 3 == 0) {  		c = Color.white;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val != 0) {  	if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  		c = SCANmap.heightToColor (val' scheme);  	else  		c = SCANmap.heightToColor (val' 1);  }  else {  	c = Color.grey;  	if (scanline % 30 == 0 && ilon % 3 == 0) {  		c = Color.white;  	}  	else if (ilon % 30 == 0 && scanline % 3 == 0) {  		c = Color.white;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (val != 0) {  	if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  		c = SCANmap.heightToColor (val' scheme);  	else  		c = SCANmap.heightToColor (val' 1);  }  else {  	c = Color.grey;  	if (scanline % 30 == 0 && ilon % 3 == 0) {  		c = Color.white;  	}  	else if (ilon % 30 == 0 && scanline % 3 == 0) {  		c = Color.white;  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  	c = SCANmap.heightToColor (val' scheme);  else  	c = SCANmap.heightToColor (val' 1);  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (isCovered (ilon - 180' scanline - 90' SCANtype.AltimetryHiRes))  	c = SCANmap.heightToColor (val' scheme);  else  	c = SCANmap.heightToColor (val' 1);  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (scanline % 30 == 0 && ilon % 3 == 0) {  	c = Color.white;  }  else if (ilon % 30 == 0 && scanline % 3 == 0) {  	c = Color.white;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (scanline % 30 == 0 && ilon % 3 == 0) {  	c = Color.white;  }  else if (ilon % 30 == 0 && scanline % 3 == 0) {  	c = Color.white;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (scanline % 30 == 0 && ilon % 3 == 0) {  	c = Color.white;  }  else if (ilon % 30 == 0 && scanline % 3 == 0) {  	c = Color.white;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (scanline % 30 == 0 && ilon % 3 == 0) {  	c = Color.white;  }  else if (ilon % 30 == 0 && scanline % 3 == 0) {  	c = Color.white;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (ilon % 30 == 0 && scanline % 3 == 0) {  	c = Color.white;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (ilon % 30 == 0 && scanline % 3 == 0) {  	c = Color.white;  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (type != SCANtype.Nothing) {  	if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  		c = Color.Lerp (c' Color.black' 0.5f);  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (type != SCANtype.Nothing) {  	if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  		c = Color.Lerp (c' Color.black' 0.5f);  	}  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  	c = Color.Lerp (c' Color.black' 0.5f);  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (!isCoveredByAll (ilon - 180' scanline - 90' type)) {  	c = Color.Lerp (c' Color.black' 0.5f);  }  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: map_small.SetPixels (0' scanline' 360' 1' cols_height_map_small);  
Magic Number,SCANsat,SCANdata,C:\repos\thatfool_SCAN\SCANdata.cs,drawHeightScanline,The following statement contains a magic number: if (scanline >= 180) {  	scanstep += 1;  	scanline = 0;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,Compress,The following statement contains a magic number: while (byteCount == 0) {  	outputByteCountGuess *= 2;  	tempBuffer = new byte[outputByteCountGuess];  	byteCount = lzf_compress (inputBytes' ref tempBuffer);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,Compress,The following statement contains a magic number: outputByteCountGuess *= 2;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,Decompress,The following statement contains a magic number: while (byteCount == 0) {  	outputByteCountGuess *= 2;  	tempBuffer = new byte[outputByteCountGuess];  	byteCount = lzf_decompress (inputBytes' ref tempBuffer);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,Decompress,The following statement contains a magic number: outputByteCountGuess *= 2;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: for (; ;) {  	if (iidx < inputLength - 2) {  		hval = (hval << 8) | input [iidx + 2];  		hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  		reference = HashTable [hslot];  		HashTable [hslot] = (long)iidx;  		if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  			/* match found at *reference++ */uint len = 2;  			uint maxlen = (uint)inputLength - iidx - len;  			maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  			if (oidx + lit + 1 + 3 >= outputLength)  				return 0;  			do  				len++;  			while (len < maxlen && input [reference + len] == input [iidx + len]);  			if (lit != 0) {  				output [oidx++] = (byte)(lit - 1);  				lit = -lit;  				do  					output [oidx++] = input [iidx + lit];  				while ((++lit) != 0);  			}  			len -= 2;  			iidx++;  			if (len < 7) {  				output [oidx++] = (byte)((off >> 8) + (len << 5));  			}  			else {  				output [oidx++] = (byte)((off >> 8) + (7 << 5));  				output [oidx++] = (byte)(len - 7);  			}  			output [oidx++] = (byte)off;  			iidx += len - 1;  			hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			hval = (hval << 8) | input [iidx + 2];  			HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  			iidx++;  			continue;  		}  	}  	else if (iidx == inputLength)  		break;  	/* one more literal byte we must copy */lit++;  	iidx++;  	if (lit == MAX_LIT) {  		if (oidx + 1 + MAX_LIT >= outputLength)  			return 0;  		output [oidx++] = (byte)(MAX_LIT - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (iidx < inputLength - 2) {  	hval = (hval << 8) | input [iidx + 2];  	hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  	reference = HashTable [hslot];  	HashTable [hslot] = (long)iidx;  	if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  		/* match found at *reference++ */uint len = 2;  		uint maxlen = (uint)inputLength - iidx - len;  		maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  		if (oidx + lit + 1 + 3 >= outputLength)  			return 0;  		do  			len++;  		while (len < maxlen && input [reference + len] == input [iidx + len]);  		if (lit != 0) {  			output [oidx++] = (byte)(lit - 1);  			lit = -lit;  			do  				output [oidx++] = input [iidx + lit];  			while ((++lit) != 0);  		}  		len -= 2;  		iidx++;  		if (len < 7) {  			output [oidx++] = (byte)((off >> 8) + (len << 5));  		}  		else {  			output [oidx++] = (byte)((off >> 8) + (7 << 5));  			output [oidx++] = (byte)(len - 7);  		}  		output [oidx++] = (byte)off;  		iidx += len - 1;  		hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		hval = (hval << 8) | input [iidx + 2];  		HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  		iidx++;  		continue;  	}  }  else if (iidx == inputLength)  	break;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hslot = ((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if ((off = iidx - reference - 1) < MAX_OFF && iidx + 4 < inputLength && reference > 0 && input [reference + 0] == input [iidx + 0] && input [reference + 1] == input [iidx + 1] && input [reference + 2] == input [iidx + 2]) {  	/* match found at *reference++ */uint len = 2;  	uint maxlen = (uint)inputLength - iidx - len;  	maxlen = maxlen > MAX_REF ? MAX_REF : maxlen;  	if (oidx + lit + 1 + 3 >= outputLength)  		return 0;  	do  		len++;  	while (len < maxlen && input [reference + len] == input [iidx + len]);  	if (lit != 0) {  		output [oidx++] = (byte)(lit - 1);  		lit = -lit;  		do  			output [oidx++] = input [iidx + lit];  		while ((++lit) != 0);  	}  	len -= 2;  	iidx++;  	if (len < 7) {  		output [oidx++] = (byte)((off >> 8) + (len << 5));  	}  	else {  		output [oidx++] = (byte)((off >> 8) + (7 << 5));  		output [oidx++] = (byte)(len - 7);  	}  	output [oidx++] = (byte)off;  	iidx += len - 1;  	hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	hval = (hval << 8) | input [iidx + 2];  	HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  	iidx++;  	continue;  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (oidx + lit + 1 + 3 >= outputLength)  	return 0;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: len -= 2;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: if (len < 7) {  	output [oidx++] = (byte)((off >> 8) + (len << 5));  }  else {  	output [oidx++] = (byte)((off >> 8) + (7 << 5));  	output [oidx++] = (byte)(len - 7);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (len << 5));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (len << 5));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: output [oidx++] = (byte)((off >> 8) + (7 << 5));  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: output [oidx++] = (byte)(len - 7);  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hval = (uint)(((input [iidx]) << 8) | input [iidx + 1]);  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: hval = (hval << 8) | input [iidx + 2];  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_compress,The following statement contains a magic number: HashTable [((hval ^ (hval << 5)) >> (int)(((3 * 8 - HLOG)) - hval * 5) & (HSIZE - 1))] = iidx;  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5)) {  		/* literal run */ctrl++;  		if (oidx + ctrl > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else {  		/* back reference */uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5)) {  		/* literal run */ctrl++;  		if (oidx + ctrl > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else {  		/* back reference */uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5)) {  		/* literal run */ctrl++;  		if (oidx + ctrl > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else {  		/* back reference */uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5)) {  		/* literal run */ctrl++;  		if (oidx + ctrl > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else {  		/* back reference */uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: do {  	uint ctrl = input [iidx++];  	if (ctrl < (1 << 5)) {  		/* literal run */ctrl++;  		if (oidx + ctrl > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		do  			output [oidx++] = input [iidx++];  		while ((--ctrl) != 0);  	}  	else {  		/* back reference */uint len = ctrl >> 5;  		int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  		if (len == 7)  			len += input [iidx++];  		reference -= input [iidx++];  		if (oidx + len + 2 > outputLength) {  			//SET_ERRNO (E2BIG);  			return 0;  		}  		if (reference < 0) {  			//SET_ERRNO (EINVAL);  			return 0;  		}  		output [oidx++] = output [reference++];  		output [oidx++] = output [reference++];  		do  			output [oidx++] = output [reference++];  		while ((--len) != 0);  	}  }  while (iidx < inputLength);  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5)) {  	/* literal run */ctrl++;  	if (oidx + ctrl > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else {  	/* back reference */uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5)) {  	/* literal run */ctrl++;  	if (oidx + ctrl > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else {  	/* back reference */uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5)) {  	/* literal run */ctrl++;  	if (oidx + ctrl > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else {  	/* back reference */uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5)) {  	/* literal run */ctrl++;  	if (oidx + ctrl > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else {  	/* back reference */uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: if (ctrl < (1 << 5)) {  	/* literal run */ctrl++;  	if (oidx + ctrl > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	do  		output [oidx++] = input [iidx++];  	while ((--ctrl) != 0);  }  else {  	/* back reference */uint len = ctrl >> 5;  	int reference = (int)(oidx - ((ctrl & 0x1f) << 8) - 1);  	if (len == 7)  		len += input [iidx++];  	reference -= input [iidx++];  	if (oidx + len + 2 > outputLength) {  		//SET_ERRNO (E2BIG);  		return 0;  	}  	if (reference < 0) {  		//SET_ERRNO (EINVAL);  		return 0;  	}  	output [oidx++] = output [reference++];  	output [oidx++] = output [reference++];  	do  		output [oidx++] = output [reference++];  	while ((--len) != 0);  }  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: if (len == 7)  	len += input [iidx++];  
Magic Number,SCANsat,CLZF2,C:\repos\thatfool_SCAN\CLZF2.cs,lzf_decompress,The following statement contains a magic number: if (oidx + len + 2 > outputLength) {  	//SET_ERRNO (E2BIG);  	return 0;  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The following statement contains a magic number: if (map != null) {  	for (int i = 0; i < 1000; ++i) {  		map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value));  	}  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The following statement contains a magic number: if (map != null) {  	for (int i = 0; i < 1000; ++i) {  		map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value));  	}  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The following statement contains a magic number: if (map != null) {  	for (int i = 0; i < 1000; ++i) {  		map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value));  	}  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The following statement contains a magic number: for (int i = 0; i < 1000; ++i) {  	map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value));  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The following statement contains a magic number: for (int i = 0; i < 1000; ++i) {  	map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value));  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The following statement contains a magic number: for (int i = 0; i < 1000; ++i) {  	map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value));  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The following statement contains a magic number: map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value));  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,addStatic,The following statement contains a magic number: map.SetPixel (UnityEngine.Random.Range (0' 360)' UnityEngine.Random.Range (0' 180)' Color.Lerp (Color.black' Color.white' UnityEngine.Random.value));  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,OnUpdate,The following statement contains a magic number: if (scanning && sensorType >= 0) {  	if (sensorType == 0 || SCANcontroller.controller.isVesselKnown (vessel.id' (SCANdata.SCANtype)sensorType)) {  		if (TimeWarp.CurrentRate < 1500) {  			// would need large buffer batteries' just not very smooth  			float p = power * TimeWarp.deltaTime;  			float e = part.RequestResource ("ElectricCharge"' p);  			if (e < p) {  				stopScan ();  				powerIsProblem = true;  			}  			else {  				startScan ();  				powerIsProblem = false;  			}  		}  		else if (powerIsProblem) {  			startScan ();  			powerIsProblem = false;  		}  	}  	else {  		stopScan ();  	}  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,OnUpdate,The following statement contains a magic number: if (sensorType == 0 || SCANcontroller.controller.isVesselKnown (vessel.id' (SCANdata.SCANtype)sensorType)) {  	if (TimeWarp.CurrentRate < 1500) {  		// would need large buffer batteries' just not very smooth  		float p = power * TimeWarp.deltaTime;  		float e = part.RequestResource ("ElectricCharge"' p);  		if (e < p) {  			stopScan ();  			powerIsProblem = true;  		}  		else {  			startScan ();  			powerIsProblem = false;  		}  	}  	else if (powerIsProblem) {  		startScan ();  		powerIsProblem = false;  	}  }  else {  	stopScan ();  }  
Magic Number,SCANsat,SCANsat,C:\repos\thatfool_SCAN\SCANsat.cs,OnUpdate,The following statement contains a magic number: if (TimeWarp.CurrentRate < 1500) {  	// would need large buffer batteries' just not very smooth  	float p = power * TimeWarp.deltaTime;  	float e = part.RequestResource ("ElectricCharge"' p);  	if (e < p) {  		stopScan ();  		powerIsProblem = true;  	}  	else {  		startScan ();  		powerIsProblem = false;  	}  }  else if (powerIsProblem) {  	startScan ();  	powerIsProblem = false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: pos_icon.x = x - width / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: pos_icon.y = y - width / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: tc_icon.x = 0.2f * ((int)icon % 5);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: tc_icon.y = 0.2f * (4 - (int)icon / 5);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: tc_icon.y = 0.2f * (4 - (int)icon / 5);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: if (outline) {  	GUI.color = Color.black;  	pos_icon.x -= 1;  	GUI.DrawTextureWithTexCoords (pos_icon' MapView.OrbitIconsMap' tc_icon);  	pos_icon.x += 2;  	GUI.DrawTextureWithTexCoords (pos_icon' MapView.OrbitIconsMap' tc_icon);  	pos_icon.x -= 1;  	pos_icon.y -= 1;  	GUI.DrawTextureWithTexCoords (pos_icon' MapView.OrbitIconsMap' tc_icon);  	pos_icon.y += 2;  	GUI.DrawTextureWithTexCoords (pos_icon' MapView.OrbitIconsMap' tc_icon);  	pos_icon.y -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: if (outline) {  	GUI.color = Color.black;  	pos_icon.x -= 1;  	GUI.DrawTextureWithTexCoords (pos_icon' MapView.OrbitIconsMap' tc_icon);  	pos_icon.x += 2;  	GUI.DrawTextureWithTexCoords (pos_icon' MapView.OrbitIconsMap' tc_icon);  	pos_icon.x -= 1;  	pos_icon.y -= 1;  	GUI.DrawTextureWithTexCoords (pos_icon' MapView.OrbitIconsMap' tc_icon);  	pos_icon.y += 2;  	GUI.DrawTextureWithTexCoords (pos_icon' MapView.OrbitIconsMap' tc_icon);  	pos_icon.y -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: pos_icon.x += 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbitIcon,The following statement contains a magic number: pos_icon.y += 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The following statement contains a magic number: if (aligned) {  	Vector2 sz = style_label.CalcSize (new GUIContent (txt.Substring (0' 1)));  	r.x -= sz.x / 2;  	r.y -= sz.y / 2;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The following statement contains a magic number: if (aligned) {  	Vector2 sz = style_label.CalcSize (new GUIContent (txt.Substring (0' 1)));  	r.x -= sz.x / 2;  	r.y -= sz.y / 2;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The following statement contains a magic number: r.x -= sz.x / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The following statement contains a magic number: r.y -= sz.y / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The following statement contains a magic number: if (outline) {  	r.x -= 1;  	GUI.Label (r' txt' style_label);  	r.x += 2;  	GUI.Label (r' txt' style_label);  	r.x -= 1;  	r.y -= 1;  	GUI.Label (r' txt' style_label);  	r.y += 2;  	GUI.Label (r' txt' style_label);  	r.y -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The following statement contains a magic number: if (outline) {  	r.x -= 1;  	GUI.Label (r' txt' style_label);  	r.x += 2;  	GUI.Label (r' txt' style_label);  	r.x -= 1;  	r.y -= 1;  	GUI.Label (r' txt' style_label);  	r.y += 2;  	GUI.Label (r' txt' style_label);  	r.y -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The following statement contains a magic number: r.x += 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLabel,The following statement contains a magic number: r.y += 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (vessel.longitude' vessel.latitude) + 90) % 180;  	lon = (map.projectLongitude (vessel.longitude' vessel.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (vessel.longitude' vessel.latitude) + 90) % 180;  	lon = (map.projectLongitude (vessel.longitude' vessel.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (vessel.longitude' vessel.latitude) + 90) % 180;  	lon = (map.projectLongitude (vessel.longitude' vessel.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (vessel.longitude' vessel.latitude) + 90) % 180;  	lon = (map.projectLongitude (vessel.longitude' vessel.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (vessel.longitude' vessel.latitude) + 90) % 180;  	lon = (map.projectLongitude (vessel.longitude' vessel.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (vessel.longitude' vessel.latitude) + 90) % 180;  	lon = (map.projectLongitude (vessel.longitude' vessel.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: lat = (map.projectLatitude (vessel.longitude' vessel.latitude) + 90) % 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: lat = (map.projectLatitude (vessel.longitude' vessel.latitude) + 90) % 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: lon = (map.projectLongitude (vessel.longitude' vessel.latitude) + 180) % 360;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: lon = (map.projectLongitude (vessel.longitude' vessel.latitude) + 180) % 360;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  	return;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  	return;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (vessel == FlightGlobals.ActiveVessel && (int)(Time.realtimeSinceStartup % 2) == 0) {  	col = cb_yellow;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (vessel.vesselType == VesselType.Flag)  	sz = 24;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: sz = 24;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: if (maprect.width < 360)  	return;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawVesselLabel,The following statement contains a magic number: r.x += 12;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (anomaly.longitude' anomaly.latitude) + 90) % 180;  	lon = (map.projectLongitude (anomaly.longitude' anomaly.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (anomaly.longitude' anomaly.latitude) + 90) % 180;  	lon = (map.projectLongitude (anomaly.longitude' anomaly.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (anomaly.longitude' anomaly.latitude) + 90) % 180;  	lon = (map.projectLongitude (anomaly.longitude' anomaly.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (anomaly.longitude' anomaly.latitude) + 90) % 180;  	lon = (map.projectLongitude (anomaly.longitude' anomaly.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (anomaly.longitude' anomaly.latitude) + 90) % 180;  	lon = (map.projectLongitude (anomaly.longitude' anomaly.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: if (map != null) {  	lat = (map.projectLatitude (anomaly.longitude' anomaly.latitude) + 90) % 180;  	lon = (map.projectLongitude (anomaly.longitude' anomaly.latitude) + 180) % 360;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: lat = (map.projectLatitude (anomaly.longitude' anomaly.latitude) + 90) % 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: lat = (map.projectLatitude (anomaly.longitude' anomaly.latitude) + 90) % 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: lon = (map.projectLongitude (anomaly.longitude' anomaly.latitude) + 180) % 360;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: lon = (map.projectLongitude (anomaly.longitude' anomaly.latitude) + 180) % 360;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  	return;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawAnomalyLabel,The following statement contains a magic number: if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  	return;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,readableLabel,The following statement contains a magic number: r.x += 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,readableLabel,The following statement contains a magic number: r.y += 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,toDMS,The following statement contains a magic number: thing = (thing - Math.Floor (thing)) * 60;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,toDMS,The following statement contains a magic number: thing = (thing - Math.Floor (thing)) * 60;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: test_image = new Texture2D (360' 180' TextureFormat.RGB24' false);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: test_image = new Texture2D (360' 180' TextureFormat.RGB24' false);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int y = 0; y < 180; ++y) {  	for (int x = 0; x < 360; ++x) {  		Color c = Color.black;  		if (y < 120) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.grey;  				break;  			case 1:  				c = Color.yellow;  				break;  			case 2:  				c = Color.cyan;  				break;  			case 3:  				c = Color.green;  				break;  			case 4:  				c = Color.magenta;  				break;  			case 5:  				c = Color.red;  				break;  			default:  				c = Color.blue;  				break;  			}  		}  		else if (y < 150) {  			switch ((int)(x / 51)) {  			case 0:  				c = Color.blue;  				break;  			case 1:  				c = Color.black;  				break;  			case 2:  				c = Color.magenta;  				break;  			case 3:  				c = Color.black;  				break;  			case 4:  				c = Color.cyan;  				break;  			case 5:  				c = Color.black;  				break;  			default:  				c = Color.grey;  				break;  			}  		}  		else {  			switch ((int)(x / 60)) {  			case 0:  				c = XKCDColors.DarkTeal;  				break;  			case 1:  				c = Color.white;  				break;  			case 2:  				c = XKCDColors.DarkPurple;  				break;  			case 3:  				c = XKCDColors.DarkGrey;  				break;  			case 4:  				c = Color.grey;  				break;  			default:  				c = Color.black;  				break;  			}  		}  		pix [pos++] = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: for (int x = 0; x < 360; ++x) {  	Color c = Color.black;  	if (y < 120) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.grey;  			break;  		case 1:  			c = Color.yellow;  			break;  		case 2:  			c = Color.cyan;  			break;  		case 3:  			c = Color.green;  			break;  		case 4:  			c = Color.magenta;  			break;  		case 5:  			c = Color.red;  			break;  		default:  			c = Color.blue;  			break;  		}  	}  	else if (y < 150) {  		switch ((int)(x / 51)) {  		case 0:  			c = Color.blue;  			break;  		case 1:  			c = Color.black;  			break;  		case 2:  			c = Color.magenta;  			break;  		case 3:  			c = Color.black;  			break;  		case 4:  			c = Color.cyan;  			break;  		case 5:  			c = Color.black;  			break;  		default:  			c = Color.grey;  			break;  		}  	}  	else {  		switch ((int)(x / 60)) {  		case 0:  			c = XKCDColors.DarkTeal;  			break;  		case 1:  			c = Color.white;  			break;  		case 2:  			c = XKCDColors.DarkPurple;  			break;  		case 3:  			c = XKCDColors.DarkGrey;  			break;  		case 4:  			c = Color.grey;  			break;  		default:  			c = Color.black;  			break;  		}  	}  	pix [pos++] = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 120) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.grey;  		break;  	case 1:  		c = Color.yellow;  		break;  	case 2:  		c = Color.cyan;  		break;  	case 3:  		c = Color.green;  		break;  	case 4:  		c = Color.magenta;  		break;  	case 5:  		c = Color.red;  		break;  	default:  		c = Color.blue;  		break;  	}  }  else if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.grey;  	break;  case 1:  	c = Color.yellow;  	break;  case 2:  	c = Color.cyan;  	break;  case 3:  	c = Color.green;  	break;  case 4:  	c = Color.magenta;  	break;  case 5:  	c = Color.red;  	break;  default:  	c = Color.blue;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.grey;  	break;  case 1:  	c = Color.yellow;  	break;  case 2:  	c = Color.cyan;  	break;  case 3:  	c = Color.green;  	break;  case 4:  	c = Color.magenta;  	break;  case 5:  	c = Color.red;  	break;  default:  	c = Color.blue;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.grey;  	break;  case 1:  	c = Color.yellow;  	break;  case 2:  	c = Color.cyan;  	break;  case 3:  	c = Color.green;  	break;  case 4:  	c = Color.magenta;  	break;  case 5:  	c = Color.red;  	break;  default:  	c = Color.blue;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.grey;  	break;  case 1:  	c = Color.yellow;  	break;  case 2:  	c = Color.cyan;  	break;  case 3:  	c = Color.green;  	break;  case 4:  	c = Color.magenta;  	break;  case 5:  	c = Color.red;  	break;  default:  	c = Color.blue;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.grey;  	break;  case 1:  	c = Color.yellow;  	break;  case 2:  	c = Color.cyan;  	break;  case 3:  	c = Color.green;  	break;  case 4:  	c = Color.magenta;  	break;  case 5:  	c = Color.red;  	break;  default:  	c = Color.blue;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: if (y < 150) {  	switch ((int)(x / 51)) {  	case 0:  		c = Color.blue;  		break;  	case 1:  		c = Color.black;  		break;  	case 2:  		c = Color.magenta;  		break;  	case 3:  		c = Color.black;  		break;  	case 4:  		c = Color.cyan;  		break;  	case 5:  		c = Color.black;  		break;  	default:  		c = Color.grey;  		break;  	}  }  else {  	switch ((int)(x / 60)) {  	case 0:  		c = XKCDColors.DarkTeal;  		break;  	case 1:  		c = Color.white;  		break;  	case 2:  		c = XKCDColors.DarkPurple;  		break;  	case 3:  		c = XKCDColors.DarkGrey;  		break;  	case 4:  		c = Color.grey;  		break;  	default:  		c = Color.black;  		break;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.blue;  	break;  case 1:  	c = Color.black;  	break;  case 2:  	c = Color.magenta;  	break;  case 3:  	c = Color.black;  	break;  case 4:  	c = Color.cyan;  	break;  case 5:  	c = Color.black;  	break;  default:  	c = Color.grey;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.blue;  	break;  case 1:  	c = Color.black;  	break;  case 2:  	c = Color.magenta;  	break;  case 3:  	c = Color.black;  	break;  case 4:  	c = Color.cyan;  	break;  case 5:  	c = Color.black;  	break;  default:  	c = Color.grey;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.blue;  	break;  case 1:  	c = Color.black;  	break;  case 2:  	c = Color.magenta;  	break;  case 3:  	c = Color.black;  	break;  case 4:  	c = Color.cyan;  	break;  case 5:  	c = Color.black;  	break;  default:  	c = Color.grey;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.blue;  	break;  case 1:  	c = Color.black;  	break;  case 2:  	c = Color.magenta;  	break;  case 3:  	c = Color.black;  	break;  case 4:  	c = Color.cyan;  	break;  case 5:  	c = Color.black;  	break;  default:  	c = Color.grey;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 51)) {  case 0:  	c = Color.blue;  	break;  case 1:  	c = Color.black;  	break;  case 2:  	c = Color.magenta;  	break;  case 3:  	c = Color.black;  	break;  case 4:  	c = Color.cyan;  	break;  case 5:  	c = Color.black;  	break;  default:  	c = Color.grey;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 60)) {  case 0:  	c = XKCDColors.DarkTeal;  	break;  case 1:  	c = Color.white;  	break;  case 2:  	c = XKCDColors.DarkPurple;  	break;  case 3:  	c = XKCDColors.DarkGrey;  	break;  case 4:  	c = Color.grey;  	break;  default:  	c = Color.black;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 60)) {  case 0:  	c = XKCDColors.DarkTeal;  	break;  case 1:  	c = Color.white;  	break;  case 2:  	c = XKCDColors.DarkPurple;  	break;  case 3:  	c = XKCDColors.DarkGrey;  	break;  case 4:  	c = Color.grey;  	break;  default:  	c = Color.black;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 60)) {  case 0:  	c = XKCDColors.DarkTeal;  	break;  case 1:  	c = Color.white;  	break;  case 2:  	c = XKCDColors.DarkPurple;  	break;  case 3:  	c = XKCDColors.DarkGrey;  	break;  case 4:  	c = Color.grey;  	break;  default:  	c = Color.black;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,getTestImage,The following statement contains a magic number: switch ((int)(x / 60)) {  case 0:  	c = XKCDColors.DarkTeal;  	break;  case 1:  	c = Color.white;  	break;  case 2:  	c = XKCDColors.DarkPurple;  	break;  case 3:  	c = XKCDColors.DarkGrey;  	break;  case 4:  	c = Color.grey;  	break;  default:  	c = Color.black;  	break;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode > 0) {  	GUILayout.BeginVertical ();  	if (notMappingToday) {  		GUILayout.Label (getTestImage ());  	}  	else {  		GUILayout.Label (data.map_small);  	}  	Rect maprect = GUILayoutUtility.GetLastRect ();  	maprect.width = data.map_small.width;  	maprect.height = data.map_small.height;  	if (infotext != null) {  		GUILayout.BeginVertical ();  		readableLabel (infotext' Color.white);  		GUILayout.EndVertical ();  	}  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (GUILayout.Button ("Big Map")) {  		bigmap_visible = !bigmap_visible;  		if (!bigmap_visible)  			spotmap = null;  	}  	if (GUILayout.Button ("Instruments")) {  		instruments_visible = !instruments_visible;  	}  	if (GUILayout.Button ("Settings")) {  		settings_visible = !settings_visible;  	}  	GUILayout.EndHorizontal ();  	if (!notMappingToday) {  		int count = 1;  		foreach (Vessel v in FlightGlobals.Vessels) {  			if (v == null)  				continue;  			if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  				if (v.mainBody == vessel.mainBody) {  					float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  					float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  					if (minimode == 1) {  						drawVesselLabel (maprect' null' -1' v);  						continue;  					}  					float alt = v.heightFromTerrain;  					if (alt < 0)  						alt = (float)v.altitude;  					string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  					Color col = XKCDColors.LightGrey;  					if (v == FlightGlobals.ActiveVessel)  						col = c_good;  					GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  					if (readableLabel (text' col)) {  						if (Event.current.clickCount > 1) {  							Event.current.Use ();  							FlightGlobals.SetActiveVessel (v);  							ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  						}  					}  					GUILayout.EndHorizontal ();  					drawVesselLabel (maprect' null' count' v);  					count += 1;  				}  			}  		}  	}  	GUILayout.EndVertical ();  	r = new Rect (pos_infobox.width - 50' 0' 22' 22);  	style_button.normal.textColor = cb_yellow;  	if (minimode == 2) {  		if (GUI.Button (r' "-"' style_button))  			minimode = 1;  	}  	else {  		if (GUI.Button (r' "+"' style_button))  			minimode = 2;  	}  	r.x += 25;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  		minimode = (minimode == 0 ? 2 : -minimode);  }  else {  	GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  	r = GUILayoutUtility.GetLastRect ();  	drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  	if (Event.current.isMouse) {  		if (Event.current.type == EventType.MouseUp) {  			if (icon_dragging) {  				icon_dragging = false;  			}  			else {  				if (r.Contains (Event.current.mousePosition)) {  					minimode = (minimode == 0 ? 2 : -minimode);  				}  			}  		}  		else if (Event.current.type == EventType.MouseDrag) {  			icon_dragging = true;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (!notMappingToday) {  	int count = 1;  	foreach (Vessel v in FlightGlobals.Vessels) {  		if (v == null)  			continue;  		if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  			if (v.mainBody == vessel.mainBody) {  				float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  				float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  				if (minimode == 1) {  					drawVesselLabel (maprect' null' -1' v);  					continue;  				}  				float alt = v.heightFromTerrain;  				if (alt < 0)  					alt = (float)v.altitude;  				string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  				Color col = XKCDColors.LightGrey;  				if (v == FlightGlobals.ActiveVessel)  					col = c_good;  				GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  				if (readableLabel (text' col)) {  					if (Event.current.clickCount > 1) {  						Event.current.Use ();  						FlightGlobals.SetActiveVessel (v);  						ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  					}  				}  				GUILayout.EndHorizontal ();  				drawVesselLabel (maprect' null' count' v);  				count += 1;  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: foreach (Vessel v in FlightGlobals.Vessels) {  	if (v == null)  		continue;  	if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  		if (v.mainBody == vessel.mainBody) {  			float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  			float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  			if (minimode == 1) {  				drawVesselLabel (maprect' null' -1' v);  				continue;  			}  			float alt = v.heightFromTerrain;  			if (alt < 0)  				alt = (float)v.altitude;  			string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  			Color col = XKCDColors.LightGrey;  			if (v == FlightGlobals.ActiveVessel)  				col = c_good;  			GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  			if (readableLabel (text' col)) {  				if (Event.current.clickCount > 1) {  					Event.current.Use ();  					FlightGlobals.SetActiveVessel (v);  					ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  				}  			}  			GUILayout.EndHorizontal ();  			drawVesselLabel (maprect' null' count' v);  			count += 1;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (SCANcontroller.controller.isVesselKnown (v) || v == FlightGlobals.ActiveVessel) {  	if (v.mainBody == vessel.mainBody) {  		float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  		float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  		if (minimode == 1) {  			drawVesselLabel (maprect' null' -1' v);  			continue;  		}  		float alt = v.heightFromTerrain;  		if (alt < 0)  			alt = (float)v.altitude;  		string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  		Color col = XKCDColors.LightGrey;  		if (v == FlightGlobals.ActiveVessel)  			col = c_good;  		GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  		if (readableLabel (text' col)) {  			if (Event.current.clickCount > 1) {  				Event.current.Use ();  				FlightGlobals.SetActiveVessel (v);  				ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  			}  		}  		GUILayout.EndHorizontal ();  		drawVesselLabel (maprect' null' count' v);  		count += 1;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (v.mainBody == vessel.mainBody) {  	float lon = (float)(v.longitude + 360 + 180) % 360 - 180;  	float lat = (float)(v.latitude + 180 + 90) % 180 - 90;  	if (minimode == 1) {  		drawVesselLabel (maprect' null' -1' v);  		continue;  	}  	float alt = v.heightFromTerrain;  	if (alt < 0)  		alt = (float)v.altitude;  	string text = "[" + count.ToString () + "] <b>" + v.vesselName + "</b> (" + lat.ToString ("F1") + "'" + lon.ToString ("F1") + "; " + alt.ToString ("N1") + "m)";  	Color col = XKCDColors.LightGrey;  	if (v == FlightGlobals.ActiveVessel)  		col = c_good;  	GUILayout.BeginHorizontal (GUILayout.ExpandWidth (true));  	if (readableLabel (text' col)) {  		if (Event.current.clickCount > 1) {  			Event.current.Use ();  			FlightGlobals.SetActiveVessel (v);  			ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  		}  	}  	GUILayout.EndHorizontal ();  	drawVesselLabel (maprect' null' count' v);  	count += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (readableLabel (text' col)) {  	if (Event.current.clickCount > 1) {  		Event.current.Use ();  		FlightGlobals.SetActiveVessel (v);  		ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (Event.current.clickCount > 1) {  	Event.current.Use ();  	FlightGlobals.SetActiveVessel (v);  	ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: ScreenMessages.PostScreenMessage (v.vesselName' 5' ScreenMessageStyle.UPPER_CENTER);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: r = new Rect (pos_infobox.width - 50' 0' 22' 22);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: r = new Rect (pos_infobox.width - 50' 0' 22' 22);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: r = new Rect (pos_infobox.width - 50' 0' 22' 22);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode == 2) {  	if (GUI.Button (r' "-"' style_button))  		minimode = 1;  }  else {  	if (GUI.Button (r' "+"' style_button))  		minimode = 2;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (minimode == 2) {  	if (GUI.Button (r' "-"' style_button))  		minimode = 1;  }  else {  	if (GUI.Button (r' "+"' style_button))  		minimode = 2;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (GUI.Button (r' "+"' style_button))  	minimode = 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: minimode = 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: r.x += 25;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (GUI.Button (r' SCANcontroller.controller.closeBox' style_button))  	minimode = (minimode == 0 ? 2 : -minimode);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: minimode = (minimode == 0 ? 2 : -minimode);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: GUILayout.Label (""' GUILayout.Width (32)' GUILayout.Height (32));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: drawOrbitIcon ((int)(r.x + r.width / 2)' (int)(r.y + r.height / 2)' OrbitIcon.Probe' minicolor' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (icon_dragging) {  			icon_dragging = false;  		}  		else {  			if (r.Contains (Event.current.mousePosition)) {  				minimode = (minimode == 0 ? 2 : -minimode);  			}  		}  	}  	else if (Event.current.type == EventType.MouseDrag) {  		icon_dragging = true;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (icon_dragging) {  		icon_dragging = false;  	}  	else {  		if (r.Contains (Event.current.mousePosition)) {  			minimode = (minimode == 0 ? 2 : -minimode);  		}  	}  }  else if (Event.current.type == EventType.MouseDrag) {  	icon_dragging = true;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (icon_dragging) {  	icon_dragging = false;  }  else {  	if (r.Contains (Event.current.mousePosition)) {  		minimode = (minimode == 0 ? 2 : -minimode);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: if (r.Contains (Event.current.mousePosition)) {  	minimode = (minimode == 0 ? 2 : -minimode);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_infobox_build,The following statement contains a magic number: minimode = (minimode == 0 ? 2 : -minimode);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: style_readout.fontSize = 40;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (maptraq_frame >= Time.frameCount - 5) {  	if (data.isCovered (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude' SCANdata.SCANtype.AltimetryHiRes)) {  		sensors |= SCANdata.SCANtype.Altimetry;  	}  	if (data.isCovered (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude' SCANdata.SCANtype.Biome)) {  		sensors |= SCANdata.SCANtype.Biome;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (notMappingToday) {  	style_readout.normal.textColor = c_bad;  	GUILayout.Label ("NO DATA"' style_readout);  }  else {  	if ((sensors & SCANdata.SCANtype.Biome) != SCANdata.SCANtype.Nothing) {  		GUILayout.Label (data.getBiomeName (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude)' style_readout);  		++parts;  	}  	if ((sensors & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing) {  		double h = FlightGlobals.ActiveVessel.heightFromTerrain;  		if (h < 0)  			h = FlightGlobals.ActiveVessel.altitude;  		GUILayout.Label (h.ToString ("N2") + "m"' style_readout);  		++parts;  	}  	if ((sensors & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		SCANdata.SCANanomaly nearest = null;  		double nearest_dist = -1;  		foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  			if (!a.known)  				continue;  			double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  			if (d < nearest_dist || nearest_dist < 0) {  				if (d < 50000) {  					nearest = a;  					nearest_dist = d;  				}  			}  		}  		if (nearest != null) {  			string txt = "Anomaly";  			if (nearest.detail)  				txt = nearest.name;  			txt += " " + distanceString (nearest_dist);  			GUILayout.Label (txt' style_readout);  			++parts;  			if (anomalyView == null)  				anomalyView = new RemoteView ();  			if (anomalyView != null) {  				if (nearest.mod != null) {  					if (anomalyView.lookat != nearest.mod.gameObject)  						anomalyView.setup (320' 240' nearest.mod.gameObject);  					Texture t = anomalyView.getTexture ();  					if (t != null) {  						GUILayout.Label (anomalyView.getTexture ());  						style_overlay.fontSize = 36;  						style_overlay.normal.textColor = cb_skyBlue;  						style_overlay.fontStyle = FontStyle.Bold;  						anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  					}  				}  			}  		}  	}  	if (parts <= 0) {  		style_readout.normal.textColor = c_bad;  		GUILayout.Label ("NO DATA"' style_readout);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (notMappingToday) {  	style_readout.normal.textColor = c_bad;  	GUILayout.Label ("NO DATA"' style_readout);  }  else {  	if ((sensors & SCANdata.SCANtype.Biome) != SCANdata.SCANtype.Nothing) {  		GUILayout.Label (data.getBiomeName (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude)' style_readout);  		++parts;  	}  	if ((sensors & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing) {  		double h = FlightGlobals.ActiveVessel.heightFromTerrain;  		if (h < 0)  			h = FlightGlobals.ActiveVessel.altitude;  		GUILayout.Label (h.ToString ("N2") + "m"' style_readout);  		++parts;  	}  	if ((sensors & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		SCANdata.SCANanomaly nearest = null;  		double nearest_dist = -1;  		foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  			if (!a.known)  				continue;  			double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  			if (d < nearest_dist || nearest_dist < 0) {  				if (d < 50000) {  					nearest = a;  					nearest_dist = d;  				}  			}  		}  		if (nearest != null) {  			string txt = "Anomaly";  			if (nearest.detail)  				txt = nearest.name;  			txt += " " + distanceString (nearest_dist);  			GUILayout.Label (txt' style_readout);  			++parts;  			if (anomalyView == null)  				anomalyView = new RemoteView ();  			if (anomalyView != null) {  				if (nearest.mod != null) {  					if (anomalyView.lookat != nearest.mod.gameObject)  						anomalyView.setup (320' 240' nearest.mod.gameObject);  					Texture t = anomalyView.getTexture ();  					if (t != null) {  						GUILayout.Label (anomalyView.getTexture ());  						style_overlay.fontSize = 36;  						style_overlay.normal.textColor = cb_skyBlue;  						style_overlay.fontStyle = FontStyle.Bold;  						anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  					}  				}  			}  		}  	}  	if (parts <= 0) {  		style_readout.normal.textColor = c_bad;  		GUILayout.Label ("NO DATA"' style_readout);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (notMappingToday) {  	style_readout.normal.textColor = c_bad;  	GUILayout.Label ("NO DATA"' style_readout);  }  else {  	if ((sensors & SCANdata.SCANtype.Biome) != SCANdata.SCANtype.Nothing) {  		GUILayout.Label (data.getBiomeName (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude)' style_readout);  		++parts;  	}  	if ((sensors & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing) {  		double h = FlightGlobals.ActiveVessel.heightFromTerrain;  		if (h < 0)  			h = FlightGlobals.ActiveVessel.altitude;  		GUILayout.Label (h.ToString ("N2") + "m"' style_readout);  		++parts;  	}  	if ((sensors & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		SCANdata.SCANanomaly nearest = null;  		double nearest_dist = -1;  		foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  			if (!a.known)  				continue;  			double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  			if (d < nearest_dist || nearest_dist < 0) {  				if (d < 50000) {  					nearest = a;  					nearest_dist = d;  				}  			}  		}  		if (nearest != null) {  			string txt = "Anomaly";  			if (nearest.detail)  				txt = nearest.name;  			txt += " " + distanceString (nearest_dist);  			GUILayout.Label (txt' style_readout);  			++parts;  			if (anomalyView == null)  				anomalyView = new RemoteView ();  			if (anomalyView != null) {  				if (nearest.mod != null) {  					if (anomalyView.lookat != nearest.mod.gameObject)  						anomalyView.setup (320' 240' nearest.mod.gameObject);  					Texture t = anomalyView.getTexture ();  					if (t != null) {  						GUILayout.Label (anomalyView.getTexture ());  						style_overlay.fontSize = 36;  						style_overlay.normal.textColor = cb_skyBlue;  						style_overlay.fontStyle = FontStyle.Bold;  						anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  					}  				}  			}  		}  	}  	if (parts <= 0) {  		style_readout.normal.textColor = c_bad;  		GUILayout.Label ("NO DATA"' style_readout);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (notMappingToday) {  	style_readout.normal.textColor = c_bad;  	GUILayout.Label ("NO DATA"' style_readout);  }  else {  	if ((sensors & SCANdata.SCANtype.Biome) != SCANdata.SCANtype.Nothing) {  		GUILayout.Label (data.getBiomeName (FlightGlobals.ActiveVessel.longitude' FlightGlobals.ActiveVessel.latitude)' style_readout);  		++parts;  	}  	if ((sensors & SCANdata.SCANtype.AltimetryHiRes) != SCANdata.SCANtype.Nothing) {  		double h = FlightGlobals.ActiveVessel.heightFromTerrain;  		if (h < 0)  			h = FlightGlobals.ActiveVessel.altitude;  		GUILayout.Label (h.ToString ("N2") + "m"' style_readout);  		++parts;  	}  	if ((sensors & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  		SCANdata.SCANanomaly nearest = null;  		double nearest_dist = -1;  		foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  			if (!a.known)  				continue;  			double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  			if (d < nearest_dist || nearest_dist < 0) {  				if (d < 50000) {  					nearest = a;  					nearest_dist = d;  				}  			}  		}  		if (nearest != null) {  			string txt = "Anomaly";  			if (nearest.detail)  				txt = nearest.name;  			txt += " " + distanceString (nearest_dist);  			GUILayout.Label (txt' style_readout);  			++parts;  			if (anomalyView == null)  				anomalyView = new RemoteView ();  			if (anomalyView != null) {  				if (nearest.mod != null) {  					if (anomalyView.lookat != nearest.mod.gameObject)  						anomalyView.setup (320' 240' nearest.mod.gameObject);  					Texture t = anomalyView.getTexture ();  					if (t != null) {  						GUILayout.Label (anomalyView.getTexture ());  						style_overlay.fontSize = 36;  						style_overlay.normal.textColor = cb_skyBlue;  						style_overlay.fontStyle = FontStyle.Bold;  						anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  					}  				}  			}  		}  	}  	if (parts <= 0) {  		style_readout.normal.textColor = c_bad;  		GUILayout.Label ("NO DATA"' style_readout);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if ((sensors & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  	SCANdata.SCANanomaly nearest = null;  	double nearest_dist = -1;  	foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  		if (!a.known)  			continue;  		double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  		if (d < nearest_dist || nearest_dist < 0) {  			if (d < 50000) {  				nearest = a;  				nearest_dist = d;  			}  		}  	}  	if (nearest != null) {  		string txt = "Anomaly";  		if (nearest.detail)  			txt = nearest.name;  		txt += " " + distanceString (nearest_dist);  		GUILayout.Label (txt' style_readout);  		++parts;  		if (anomalyView == null)  			anomalyView = new RemoteView ();  		if (anomalyView != null) {  			if (nearest.mod != null) {  				if (anomalyView.lookat != nearest.mod.gameObject)  					anomalyView.setup (320' 240' nearest.mod.gameObject);  				Texture t = anomalyView.getTexture ();  				if (t != null) {  					GUILayout.Label (anomalyView.getTexture ());  					style_overlay.fontSize = 36;  					style_overlay.normal.textColor = cb_skyBlue;  					style_overlay.fontStyle = FontStyle.Bold;  					anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  				}  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if ((sensors & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  	SCANdata.SCANanomaly nearest = null;  	double nearest_dist = -1;  	foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  		if (!a.known)  			continue;  		double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  		if (d < nearest_dist || nearest_dist < 0) {  			if (d < 50000) {  				nearest = a;  				nearest_dist = d;  			}  		}  	}  	if (nearest != null) {  		string txt = "Anomaly";  		if (nearest.detail)  			txt = nearest.name;  		txt += " " + distanceString (nearest_dist);  		GUILayout.Label (txt' style_readout);  		++parts;  		if (anomalyView == null)  			anomalyView = new RemoteView ();  		if (anomalyView != null) {  			if (nearest.mod != null) {  				if (anomalyView.lookat != nearest.mod.gameObject)  					anomalyView.setup (320' 240' nearest.mod.gameObject);  				Texture t = anomalyView.getTexture ();  				if (t != null) {  					GUILayout.Label (anomalyView.getTexture ());  					style_overlay.fontSize = 36;  					style_overlay.normal.textColor = cb_skyBlue;  					style_overlay.fontStyle = FontStyle.Bold;  					anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  				}  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if ((sensors & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  	SCANdata.SCANanomaly nearest = null;  	double nearest_dist = -1;  	foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  		if (!a.known)  			continue;  		double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  		if (d < nearest_dist || nearest_dist < 0) {  			if (d < 50000) {  				nearest = a;  				nearest_dist = d;  			}  		}  	}  	if (nearest != null) {  		string txt = "Anomaly";  		if (nearest.detail)  			txt = nearest.name;  		txt += " " + distanceString (nearest_dist);  		GUILayout.Label (txt' style_readout);  		++parts;  		if (anomalyView == null)  			anomalyView = new RemoteView ();  		if (anomalyView != null) {  			if (nearest.mod != null) {  				if (anomalyView.lookat != nearest.mod.gameObject)  					anomalyView.setup (320' 240' nearest.mod.gameObject);  				Texture t = anomalyView.getTexture ();  				if (t != null) {  					GUILayout.Label (anomalyView.getTexture ());  					style_overlay.fontSize = 36;  					style_overlay.normal.textColor = cb_skyBlue;  					style_overlay.fontStyle = FontStyle.Bold;  					anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  				}  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if ((sensors & SCANdata.SCANtype.AnomalyDetail) != SCANdata.SCANtype.Nothing) {  	SCANdata.SCANanomaly nearest = null;  	double nearest_dist = -1;  	foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  		if (!a.known)  			continue;  		double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  		if (d < nearest_dist || nearest_dist < 0) {  			if (d < 50000) {  				nearest = a;  				nearest_dist = d;  			}  		}  	}  	if (nearest != null) {  		string txt = "Anomaly";  		if (nearest.detail)  			txt = nearest.name;  		txt += " " + distanceString (nearest_dist);  		GUILayout.Label (txt' style_readout);  		++parts;  		if (anomalyView == null)  			anomalyView = new RemoteView ();  		if (anomalyView != null) {  			if (nearest.mod != null) {  				if (anomalyView.lookat != nearest.mod.gameObject)  					anomalyView.setup (320' 240' nearest.mod.gameObject);  				Texture t = anomalyView.getTexture ();  				if (t != null) {  					GUILayout.Label (anomalyView.getTexture ());  					style_overlay.fontSize = 36;  					style_overlay.normal.textColor = cb_skyBlue;  					style_overlay.fontStyle = FontStyle.Bold;  					anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  				}  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: foreach (SCANdata.SCANanomaly a in data.getAnomalies ()) {  	if (!a.known)  		continue;  	double d = (a.mod.transform.position - FlightGlobals.ActiveVessel.transform.position).magnitude;  	if (d < nearest_dist || nearest_dist < 0) {  		if (d < 50000) {  			nearest = a;  			nearest_dist = d;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (d < nearest_dist || nearest_dist < 0) {  	if (d < 50000) {  		nearest = a;  		nearest_dist = d;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (d < 50000) {  	nearest = a;  	nearest_dist = d;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (nearest != null) {  	string txt = "Anomaly";  	if (nearest.detail)  		txt = nearest.name;  	txt += " " + distanceString (nearest_dist);  	GUILayout.Label (txt' style_readout);  	++parts;  	if (anomalyView == null)  		anomalyView = new RemoteView ();  	if (anomalyView != null) {  		if (nearest.mod != null) {  			if (anomalyView.lookat != nearest.mod.gameObject)  				anomalyView.setup (320' 240' nearest.mod.gameObject);  			Texture t = anomalyView.getTexture ();  			if (t != null) {  				GUILayout.Label (anomalyView.getTexture ());  				style_overlay.fontSize = 36;  				style_overlay.normal.textColor = cb_skyBlue;  				style_overlay.fontStyle = FontStyle.Bold;  				anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (nearest != null) {  	string txt = "Anomaly";  	if (nearest.detail)  		txt = nearest.name;  	txt += " " + distanceString (nearest_dist);  	GUILayout.Label (txt' style_readout);  	++parts;  	if (anomalyView == null)  		anomalyView = new RemoteView ();  	if (anomalyView != null) {  		if (nearest.mod != null) {  			if (anomalyView.lookat != nearest.mod.gameObject)  				anomalyView.setup (320' 240' nearest.mod.gameObject);  			Texture t = anomalyView.getTexture ();  			if (t != null) {  				GUILayout.Label (anomalyView.getTexture ());  				style_overlay.fontSize = 36;  				style_overlay.normal.textColor = cb_skyBlue;  				style_overlay.fontStyle = FontStyle.Bold;  				anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (nearest != null) {  	string txt = "Anomaly";  	if (nearest.detail)  		txt = nearest.name;  	txt += " " + distanceString (nearest_dist);  	GUILayout.Label (txt' style_readout);  	++parts;  	if (anomalyView == null)  		anomalyView = new RemoteView ();  	if (anomalyView != null) {  		if (nearest.mod != null) {  			if (anomalyView.lookat != nearest.mod.gameObject)  				anomalyView.setup (320' 240' nearest.mod.gameObject);  			Texture t = anomalyView.getTexture ();  			if (t != null) {  				GUILayout.Label (anomalyView.getTexture ());  				style_overlay.fontSize = 36;  				style_overlay.normal.textColor = cb_skyBlue;  				style_overlay.fontStyle = FontStyle.Bold;  				anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (anomalyView != null) {  	if (nearest.mod != null) {  		if (anomalyView.lookat != nearest.mod.gameObject)  			anomalyView.setup (320' 240' nearest.mod.gameObject);  		Texture t = anomalyView.getTexture ();  		if (t != null) {  			GUILayout.Label (anomalyView.getTexture ());  			style_overlay.fontSize = 36;  			style_overlay.normal.textColor = cb_skyBlue;  			style_overlay.fontStyle = FontStyle.Bold;  			anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (anomalyView != null) {  	if (nearest.mod != null) {  		if (anomalyView.lookat != nearest.mod.gameObject)  			anomalyView.setup (320' 240' nearest.mod.gameObject);  		Texture t = anomalyView.getTexture ();  		if (t != null) {  			GUILayout.Label (anomalyView.getTexture ());  			style_overlay.fontSize = 36;  			style_overlay.normal.textColor = cb_skyBlue;  			style_overlay.fontStyle = FontStyle.Bold;  			anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (anomalyView != null) {  	if (nearest.mod != null) {  		if (anomalyView.lookat != nearest.mod.gameObject)  			anomalyView.setup (320' 240' nearest.mod.gameObject);  		Texture t = anomalyView.getTexture ();  		if (t != null) {  			GUILayout.Label (anomalyView.getTexture ());  			style_overlay.fontSize = 36;  			style_overlay.normal.textColor = cb_skyBlue;  			style_overlay.fontStyle = FontStyle.Bold;  			anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (nearest.mod != null) {  	if (anomalyView.lookat != nearest.mod.gameObject)  		anomalyView.setup (320' 240' nearest.mod.gameObject);  	Texture t = anomalyView.getTexture ();  	if (t != null) {  		GUILayout.Label (anomalyView.getTexture ());  		style_overlay.fontSize = 36;  		style_overlay.normal.textColor = cb_skyBlue;  		style_overlay.fontStyle = FontStyle.Bold;  		anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (nearest.mod != null) {  	if (anomalyView.lookat != nearest.mod.gameObject)  		anomalyView.setup (320' 240' nearest.mod.gameObject);  	Texture t = anomalyView.getTexture ();  	if (t != null) {  		GUILayout.Label (anomalyView.getTexture ());  		style_overlay.fontSize = 36;  		style_overlay.normal.textColor = cb_skyBlue;  		style_overlay.fontStyle = FontStyle.Bold;  		anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (nearest.mod != null) {  	if (anomalyView.lookat != nearest.mod.gameObject)  		anomalyView.setup (320' 240' nearest.mod.gameObject);  	Texture t = anomalyView.getTexture ();  	if (t != null) {  		GUILayout.Label (anomalyView.getTexture ());  		style_overlay.fontSize = 36;  		style_overlay.normal.textColor = cb_skyBlue;  		style_overlay.fontStyle = FontStyle.Bold;  		anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (anomalyView.lookat != nearest.mod.gameObject)  	anomalyView.setup (320' 240' nearest.mod.gameObject);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (anomalyView.lookat != nearest.mod.gameObject)  	anomalyView.setup (320' 240' nearest.mod.gameObject);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: anomalyView.setup (320' 240' nearest.mod.gameObject);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: anomalyView.setup (320' 240' nearest.mod.gameObject);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: if (t != null) {  	GUILayout.Label (anomalyView.getTexture ());  	style_overlay.fontSize = 36;  	style_overlay.normal.textColor = cb_skyBlue;  	style_overlay.fontStyle = FontStyle.Bold;  	anomalyView.drawOverlay (GUILayoutUtility.GetLastRect ()' style_overlay' nearest.detail);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_instruments_build,The following statement contains a magic number: style_overlay.fontSize = 36;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,distanceString,The following statement contains a magic number: if (dist < 5000)  	return dist.ToString ("N1") + "m";  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: GUILayout.Space (8);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: GUILayout.Space (16);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: foreach (CelestialBody body in FlightGlobals.Bodies) {  	if (count == 0)  		GUILayout.BeginVertical ();  	SCANdata data = SCANcontroller.controller.getData (body);  	data.disabled = !GUILayout.Toggle (!data.disabled' body.bodyName + " (" + data.getCoveragePercentage (SCANdata.SCANtype.Nothing).ToString ("N1") + "%)");  	if (count >= 4) {  		GUILayout.EndVertical ();  		count = 0;  	}  	else {  		++count;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: if (count >= 4) {  	GUILayout.EndVertical ();  	count = 0;  }  else {  	++count;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: GUILayout.Space (16);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: GUILayout.Space (16);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: if (GUILayout.Button ("Reset window positions")) {  	pos_bigmap.x = 0;  	pos_bigmap.y = 0;  	SCANcontroller.controller.map_x = 100;  	SCANcontroller.controller.map_y = 50;  	SCANcontroller.controller.map_width = 0;  	pos_infobox.x = 0;  	pos_infobox.y = 0;  	pos_instruments.x = -1;  	pos_instruments.y = 0;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: if (GUILayout.Button ("Reset window positions")) {  	pos_bigmap.x = 0;  	pos_bigmap.y = 0;  	SCANcontroller.controller.map_x = 100;  	SCANcontroller.controller.map_y = 50;  	SCANcontroller.controller.map_width = 0;  	pos_infobox.x = 0;  	pos_infobox.y = 0;  	pos_instruments.x = -1;  	pos_instruments.y = 0;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: SCANcontroller.controller.map_x = 100;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: SCANcontroller.controller.map_y = 50;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_settings_build,The following statement contains a magic number: GUILayout.Space (16);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: try {  	if (double.IsNaN (o.getObtAtUT (UT)))  		return false;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return false;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	return true;  }  catch (Exception) {  	return false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: try {  	if (double.IsNaN (o.getObtAtUT (UT)))  		return false;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return false;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	return true;  }  catch (Exception) {  	return false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: try {  	if (double.IsNaN (o.getObtAtUT (UT)))  		return false;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return false;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	return true;  }  catch (Exception) {  	return false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: try {  	if (double.IsNaN (o.getObtAtUT (UT)))  		return false;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return false;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	return true;  }  catch (Exception) {  	return false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: try {  	if (double.IsNaN (o.getObtAtUT (UT)))  		return false;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return false;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	return true;  }  catch (Exception) {  	return false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: try {  	if (double.IsNaN (o.getObtAtUT (UT)))  		return false;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return false;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	return true;  }  catch (Exception) {  	return false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: try {  	if (double.IsNaN (o.getObtAtUT (UT)))  		return false;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return false;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	return true;  }  catch (Exception) {  	return false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: try {  	if (double.IsNaN (o.getObtAtUT (UT)))  		return false;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		return false;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	return true;  }  catch (Exception) {  	return false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: if (vessel.mainBody.rotates) {  	rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: if (vessel.mainBody.rotates) {  	rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: rotation = (360 * (dT / vessel.mainBody.rotationPeriod)) % 360;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  	return false;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,mapPosAtT,The following statement contains a magic number: if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  	return false;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = -steps; i < steps; ++i) {  	if (i < 0)  		UT = startUT - (steps + i) * (o.period / steps);  	else  		UT = startUT + i * o.period * 1f / steps;  	if (double.IsNaN (UT))  		continue;  	if (UT < o.StartUT && o.StartUT != startUT)  		continue;  	if (UT > o.EndUT)  		continue;  	if (double.IsNaN (o.getObtAtUT (UT)))  		continue;  	Vector3d pos = o.getPositionAtUT (UT);  	double rotation = 0;  	if (vessel.mainBody.rotates) {  		rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  	}  	double alt = (vessel.mainBody.GetAltitude (pos));  	if (alt < 0) {  		if (i < 0) {  			i = 0;  			continue;  		}  		break;  	}  	double lo = (vessel.mainBody.GetLongitude (pos) - rotation);  	double la = (vessel.mainBody.GetLatitude (pos));  	double lon = (map.projectLongitude (lo' la) + 180) % 360;  	double lat = (map.projectLatitude (lo' la) + 90) % 180;  	lat = map.scaleLatitude (lat);  	lon = map.scaleLongitude (lon);  	if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  		continue;  	lon = lon * maprect.width / 360f;  	lat = maprect.height - lat * maprect.height / 180f;  	r.x = maprect.x + (float)lon;  	r.y = maprect.y + (float)lat;  	col = cb_skyBlue;  	if (i < 0) {  		col = cb_orange;  	}  	else {  		if (vessel.mainBody.atmosphere) {  			if (vessel.mainBody.maxAtmosphereAltitude >= alt) {  				if (!ath) {  					ath = true;  					// do something when it flips?  				}  				col = cb_reddishPurple;  			}  		}  	}  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.mainBody.rotates) {  	rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.mainBody.rotates) {  	rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: rotation = (360 * ((UT - startUT) / vessel.mainBody.rotationPeriod)) % 360;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  	continue;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (lat < 0 || lon < 0 || lat > 180 || lon > 360)  	continue;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (o.ApA > 0 && mapPosAtT (maprect' map' ref r' vessel' o' o.timeToAp)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' cb_skyBlue' 32' true);  	r.x += 24;  	r.y -= 12;  	if (!lite)  		drawLabel (r' cb_skyBlue' o.ApA.ToString ("N1")' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (o.ApA > 0 && mapPosAtT (maprect' map' ref r' vessel' o' o.timeToAp)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' cb_skyBlue' 32' true);  	r.x += 24;  	r.y -= 12;  	if (!lite)  		drawLabel (r' cb_skyBlue' o.ApA.ToString ("N1")' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (o.ApA > 0 && mapPosAtT (maprect' map' ref r' vessel' o' o.timeToAp)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' cb_skyBlue' 32' true);  	r.x += 24;  	r.y -= 12;  	if (!lite)  		drawLabel (r' cb_skyBlue' o.ApA.ToString ("N1")' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' cb_skyBlue' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: r.x += 24;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: r.y -= 12;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (o.PeA > 0 && mapPosAtT (maprect' map' ref r' vessel' o' o.timeToPe)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' cb_skyBlue' 32' true);  	r.x += 24;  	r.y -= 12;  	if (!lite)  		drawLabel (r' cb_skyBlue' o.PeA.ToString ("N1")' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (o.PeA > 0 && mapPosAtT (maprect' map' ref r' vessel' o' o.timeToPe)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' cb_skyBlue' 32' true);  	r.x += 24;  	r.y -= 12;  	if (!lite)  		drawLabel (r' cb_skyBlue' o.PeA.ToString ("N1")' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (o.PeA > 0 && mapPosAtT (maprect' map' ref r' vessel' o' o.timeToPe)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' cb_skyBlue' 32' true);  	r.x += 24;  	r.y -= 12;  	if (!lite)  		drawLabel (r' cb_skyBlue' o.PeA.ToString ("N1")' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' cb_skyBlue' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: r.x += 24;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: r.y -= 12;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.patchedConicSolver.maneuverNodes.Count > 0) {  	ManeuverNode n = vessel.patchedConicSolver.maneuverNodes [0];  	if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  		col = cb_reddishPurple;  		if (SCANcontroller.controller.colours != 1)  			col = XKCDColors.PurplyPink;  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  		Orbit nuo = n.nextPatch;  		for (int i = 0; i < steps; ++i) {  			double T = n.UT - startUT + i * nuo.period / steps;  			if (T + startUT > nuo.EndUT)  				break;  			if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  				drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  			}  		}  		if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  		}  		else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  		}  		if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  		}  		if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.patchedConicSolver.maneuverNodes.Count > 0) {  	ManeuverNode n = vessel.patchedConicSolver.maneuverNodes [0];  	if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  		col = cb_reddishPurple;  		if (SCANcontroller.controller.colours != 1)  			col = XKCDColors.PurplyPink;  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  		Orbit nuo = n.nextPatch;  		for (int i = 0; i < steps; ++i) {  			double T = n.UT - startUT + i * nuo.period / steps;  			if (T + startUT > nuo.EndUT)  				break;  			if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  				drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  			}  		}  		if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  		}  		else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  		}  		if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  		}  		if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.patchedConicSolver.maneuverNodes.Count > 0) {  	ManeuverNode n = vessel.patchedConicSolver.maneuverNodes [0];  	if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  		col = cb_reddishPurple;  		if (SCANcontroller.controller.colours != 1)  			col = XKCDColors.PurplyPink;  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  		Orbit nuo = n.nextPatch;  		for (int i = 0; i < steps; ++i) {  			double T = n.UT - startUT + i * nuo.period / steps;  			if (T + startUT > nuo.EndUT)  				break;  			if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  				drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  			}  		}  		if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  		}  		else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  		}  		if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  		}  		if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.patchedConicSolver.maneuverNodes.Count > 0) {  	ManeuverNode n = vessel.patchedConicSolver.maneuverNodes [0];  	if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  		col = cb_reddishPurple;  		if (SCANcontroller.controller.colours != 1)  			col = XKCDColors.PurplyPink;  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  		Orbit nuo = n.nextPatch;  		for (int i = 0; i < steps; ++i) {  			double T = n.UT - startUT + i * nuo.period / steps;  			if (T + startUT > nuo.EndUT)  				break;  			if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  				drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  			}  		}  		if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  		}  		else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  		}  		if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  		}  		if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.patchedConicSolver.maneuverNodes.Count > 0) {  	ManeuverNode n = vessel.patchedConicSolver.maneuverNodes [0];  	if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  		col = cb_reddishPurple;  		if (SCANcontroller.controller.colours != 1)  			col = XKCDColors.PurplyPink;  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  		Orbit nuo = n.nextPatch;  		for (int i = 0; i < steps; ++i) {  			double T = n.UT - startUT + i * nuo.period / steps;  			if (T + startUT > nuo.EndUT)  				break;  			if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  				drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  			}  		}  		if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  		}  		else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  		}  		if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  		}  		if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.patchedConicSolver.maneuverNodes.Count > 0) {  	ManeuverNode n = vessel.patchedConicSolver.maneuverNodes [0];  	if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  		col = cb_reddishPurple;  		if (SCANcontroller.controller.colours != 1)  			col = XKCDColors.PurplyPink;  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  		Orbit nuo = n.nextPatch;  		for (int i = 0; i < steps; ++i) {  			double T = n.UT - startUT + i * nuo.period / steps;  			if (T + startUT > nuo.EndUT)  				break;  			if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  				drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  			}  		}  		if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  		}  		else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  		}  		if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  		}  		if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  	col = cb_reddishPurple;  	if (SCANcontroller.controller.colours != 1)  		col = XKCDColors.PurplyPink;  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  	Orbit nuo = n.nextPatch;  	for (int i = 0; i < steps; ++i) {  		double T = n.UT - startUT + i * nuo.period / steps;  		if (T + startUT > nuo.EndUT)  			break;  		if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  		}  	}  	if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  	}  	else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  	}  	if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  	}  	if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  	col = cb_reddishPurple;  	if (SCANcontroller.controller.colours != 1)  		col = XKCDColors.PurplyPink;  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  	Orbit nuo = n.nextPatch;  	for (int i = 0; i < steps; ++i) {  		double T = n.UT - startUT + i * nuo.period / steps;  		if (T + startUT > nuo.EndUT)  			break;  		if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  		}  	}  	if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  	}  	else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  	}  	if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  	}  	if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  	col = cb_reddishPurple;  	if (SCANcontroller.controller.colours != 1)  		col = XKCDColors.PurplyPink;  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  	Orbit nuo = n.nextPatch;  	for (int i = 0; i < steps; ++i) {  		double T = n.UT - startUT + i * nuo.period / steps;  		if (T + startUT > nuo.EndUT)  			break;  		if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  		}  	}  	if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  	}  	else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  	}  	if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  	}  	if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  	col = cb_reddishPurple;  	if (SCANcontroller.controller.colours != 1)  		col = XKCDColors.PurplyPink;  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  	Orbit nuo = n.nextPatch;  	for (int i = 0; i < steps; ++i) {  		double T = n.UT - startUT + i * nuo.period / steps;  		if (T + startUT > nuo.EndUT)  			break;  		if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  		}  	}  	if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  	}  	else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  	}  	if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  	}  	if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  	col = cb_reddishPurple;  	if (SCANcontroller.controller.colours != 1)  		col = XKCDColors.PurplyPink;  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  	Orbit nuo = n.nextPatch;  	for (int i = 0; i < steps; ++i) {  		double T = n.UT - startUT + i * nuo.period / steps;  		if (T + startUT > nuo.EndUT)  			break;  		if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  		}  	}  	if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  	}  	else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  	}  	if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  	}  	if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (n.patch == vessel.orbit && n.nextPatch != null && n.nextPatch.activePatch && n.UT > startUT - o.period && mapPosAtT (maprect' map' ref r' vessel' o' n.UT - startUT)) {  	col = cb_reddishPurple;  	if (SCANcontroller.controller.colours != 1)  		col = XKCDColors.PurplyPink;  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  	Orbit nuo = n.nextPatch;  	for (int i = 0; i < steps; ++i) {  		double T = n.UT - startUT + i * nuo.period / steps;  		if (T + startUT > nuo.EndUT)  			break;  		if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  			drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  		}  	}  	if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  	}  	else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  	}  	if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  	}  	if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.ManeuverNode' col' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < steps; ++i) {  	double T = n.UT - startUT + i * nuo.period / steps;  	if (T + startUT > nuo.EndUT)  		break;  	if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  		drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (mapPosAtT (maprect' map' ref r' vessel' nuo' T)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Planet' col' 8' false);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  }  else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (nuo.patchEndTransition == Orbit.PatchTransitionType.ESCAPE) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  }  else if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Exit' col' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (nuo.patchEndTransition == Orbit.PatchTransitionType.ENCOUNTER) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Encounter' col' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (nuo.timeToAp > 0 && n.UT + nuo.timeToAp < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToAp)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Ap' col' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (nuo.timeToPe > 0 && n.UT + nuo.timeToPe < nuo.EndUT && mapPosAtT (maprect' map' ref r' vessel' nuo' n.UT - startUT + nuo.timeToPe)) {  	drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: drawOrbitIcon ((int)r.x' (int)r.y' OrbitIcon.Pe' col' 32' true);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_frame <= 0) {  	// predict equatorial crossings for the next 100 loops  	double TAAN = 360f - o.argumentOfPeriapsis;  	// true anomaly at ascending node  	double TADN = (TAAN + 180) % 360;  	// true anomaly at descending node  	double MAAN = meanForTrue (TAAN' o.eccentricity);  	double MADN = meanForTrue (TADN' o.eccentricity);  	double tAN = (((MAAN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	double tDN = (((MADN - o.meanAnomaly * Mathf.Rad2Deg + 360) % 360) / 360f * o.period + startUT);  	int eqh = 16;  	if (eq_an_map == null || eq_dn_map == null || eq_an_map.Length != overlay_static.width) {  		eq_an_map = new int[overlay_static.width];  		eq_dn_map = new int[overlay_static.width];  	}  	if (eq_map == null || eq_map.width != eq_an_map.Length) {  		eq_map = new Texture2D (eq_an_map.Length' eqh' TextureFormat.ARGB32' false);  	}  	for (int i = 0; i < eq_an_map.Length; ++i) {  		eq_an_map [i] = 0;  		eq_dn_map [i] = 0;  	}  	for (int i = 0; i < 100; ++i) {  		double UTAN = tAN + o.period * i;  		double UTDN = tDN + o.period * i;  		if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  			continue;  		Vector3d pAN = o.getPositionAtUT (UTAN);  		Vector3d pDN = o.getPositionAtUT (UTDN);  		double rotAN = 0' rotDN = 0;  		if (vessel.mainBody.rotates) {  			rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  			rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		}  		double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  		double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  		int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  		int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  		if (lonAN >= 0 && lonAN < eq_an_map.Length)  			eq_an_map [lonAN] += 1;  		if (lonDN >= 0 && lonDN < eq_dn_map.Length)  			eq_dn_map [lonDN] += 1;  	}  	Color[] pix = eq_map.GetPixels (0' 0' eq_an_map.Length' eqh);  	Color cAN = cb_skyBlue' cDN = cb_orange;  	for (int y = 0; y < eqh; ++y) {  		Color lc = Color.clear;  		for (int x = 0; x < eq_an_map.Length; ++x) {  			Color c = Color.clear;  			float scale = 0;  			if (y < eqh / 2) {  				c = cDN;  				scale = eq_dn_map [x];  			}  			else {  				c = cAN;  				scale = eq_an_map [x];  			}  			if (scale >= 1) {  				if (y == 0 || y == eqh - 1) {  					c = Color.black;  				}  				else {  					if (lc == Color.clear)  						pix [y * eq_an_map.Length + x - 1] = Color.black;  					scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  					c = Color.Lerp (c' Color.white' scale);  				}  			}  			else {  				c = Color.clear;  				if (lc != Color.clear && lc != Color.black)  					c = Color.black;  			}  			pix [y * eq_an_map.Length + x] = c;  			lc = c;  		}  	}  	eq_map.SetPixels (0' 0' eq_an_map.Length' eqh' pix);  	eq_map.Apply ();  	eq_frame = 4;  }  else {  	eq_frame -= 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int i = 0; i < 100; ++i) {  	double UTAN = tAN + o.period * i;  	double UTDN = tDN + o.period * i;  	if (double.IsNaN (UTAN) || double.IsNaN (UTDN))  		continue;  	Vector3d pAN = o.getPositionAtUT (UTAN);  	Vector3d pDN = o.getPositionAtUT (UTDN);  	double rotAN = 0' rotDN = 0;  	if (vessel.mainBody.rotates) {  		rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  		rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	}  	double loAN = vessel.mainBody.GetLongitude (pAN) - rotAN;  	double loDN = vessel.mainBody.GetLongitude (pDN) - rotDN;  	int lonAN = (int)(((map.projectLongitude (loAN' 0) + 180) % 360) * eq_an_map.Length / 360f);  	int lonDN = (int)(((map.projectLongitude (loDN' 0) + 180) % 360) * eq_dn_map.Length / 360f);  	if (lonAN >= 0 && lonAN < eq_an_map.Length)  		eq_an_map [lonAN] += 1;  	if (lonDN >= 0 && lonDN < eq_dn_map.Length)  		eq_dn_map [lonDN] += 1;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.mainBody.rotates) {  	rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.mainBody.rotates) {  	rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.mainBody.rotates) {  	rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (vessel.mainBody.rotates) {  	rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  	rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: rotAN = ((360 * ((UTAN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: rotDN = ((360 * ((UTDN - startUT) / vessel.mainBody.rotationPeriod)) % 360);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int y = 0; y < eqh; ++y) {  	Color lc = Color.clear;  	for (int x = 0; x < eq_an_map.Length; ++x) {  		Color c = Color.clear;  		float scale = 0;  		if (y < eqh / 2) {  			c = cDN;  			scale = eq_dn_map [x];  		}  		else {  			c = cAN;  			scale = eq_an_map [x];  		}  		if (scale >= 1) {  			if (y == 0 || y == eqh - 1) {  				c = Color.black;  			}  			else {  				if (lc == Color.clear)  					pix [y * eq_an_map.Length + x - 1] = Color.black;  				scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  				c = Color.Lerp (c' Color.white' scale);  			}  		}  		else {  			c = Color.clear;  			if (lc != Color.clear && lc != Color.black)  				c = Color.black;  		}  		pix [y * eq_an_map.Length + x] = c;  		lc = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int y = 0; y < eqh; ++y) {  	Color lc = Color.clear;  	for (int x = 0; x < eq_an_map.Length; ++x) {  		Color c = Color.clear;  		float scale = 0;  		if (y < eqh / 2) {  			c = cDN;  			scale = eq_dn_map [x];  		}  		else {  			c = cAN;  			scale = eq_an_map [x];  		}  		if (scale >= 1) {  			if (y == 0 || y == eqh - 1) {  				c = Color.black;  			}  			else {  				if (lc == Color.clear)  					pix [y * eq_an_map.Length + x - 1] = Color.black;  				scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  				c = Color.Lerp (c' Color.white' scale);  			}  		}  		else {  			c = Color.clear;  			if (lc != Color.clear && lc != Color.black)  				c = Color.black;  		}  		pix [y * eq_an_map.Length + x] = c;  		lc = c;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int x = 0; x < eq_an_map.Length; ++x) {  	Color c = Color.clear;  	float scale = 0;  	if (y < eqh / 2) {  		c = cDN;  		scale = eq_dn_map [x];  	}  	else {  		c = cAN;  		scale = eq_an_map [x];  	}  	if (scale >= 1) {  		if (y == 0 || y == eqh - 1) {  			c = Color.black;  		}  		else {  			if (lc == Color.clear)  				pix [y * eq_an_map.Length + x - 1] = Color.black;  			scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  			c = Color.Lerp (c' Color.white' scale);  		}  	}  	else {  		c = Color.clear;  		if (lc != Color.clear && lc != Color.black)  			c = Color.black;  	}  	pix [y * eq_an_map.Length + x] = c;  	lc = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: for (int x = 0; x < eq_an_map.Length; ++x) {  	Color c = Color.clear;  	float scale = 0;  	if (y < eqh / 2) {  		c = cDN;  		scale = eq_dn_map [x];  	}  	else {  		c = cAN;  		scale = eq_an_map [x];  	}  	if (scale >= 1) {  		if (y == 0 || y == eqh - 1) {  			c = Color.black;  		}  		else {  			if (lc == Color.clear)  				pix [y * eq_an_map.Length + x - 1] = Color.black;  			scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  			c = Color.Lerp (c' Color.white' scale);  		}  	}  	else {  		c = Color.clear;  		if (lc != Color.clear && lc != Color.black)  			c = Color.black;  	}  	pix [y * eq_an_map.Length + x] = c;  	lc = c;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (y < eqh / 2) {  	c = cDN;  	scale = eq_dn_map [x];  }  else {  	c = cAN;  	scale = eq_an_map [x];  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (scale >= 1) {  	if (y == 0 || y == eqh - 1) {  		c = Color.black;  	}  	else {  		if (lc == Color.clear)  			pix [y * eq_an_map.Length + x - 1] = Color.black;  		scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  		c = Color.Lerp (c' Color.white' scale);  	}  }  else {  	c = Color.clear;  	if (lc != Color.clear && lc != Color.black)  		c = Color.black;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (y == 0 || y == eqh - 1) {  	c = Color.black;  }  else {  	if (lc == Color.clear)  		pix [y * eq_an_map.Length + x - 1] = Color.black;  	scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  	c = Color.Lerp (c' Color.white' scale);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: scale = Mathf.Clamp (scale - 1' 0' 10) / 10f;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: eq_frame = 4;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_map != null) {  	r.x = maprect.x;  	r.y = maprect.y + maprect.height / 2 + -eq_map.height / 2;  	r.width = eq_map.width;  	r.height = eq_map.height;  	GUI.DrawTexture (r' eq_map);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: if (eq_map != null) {  	r.x = maprect.x;  	r.y = maprect.y + maprect.height / 2 + -eq_map.height / 2;  	r.width = eq_map.width;  	r.height = eq_map.height;  	GUI.DrawTexture (r' eq_map);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: r.y = maprect.y + maprect.height / 2 + -eq_map.height / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawOrbit,The following statement contains a magic number: r.y = maprect.y + maprect.height / 2 + -eq_map.height / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,meanForTrue,The following statement contains a magic number: if (TA > Math.PI)  	EA = 2 * Math.PI - EA;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,meanForTrue,The following statement contains a magic number: EA = 2 * Math.PI - EA;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lat = -90; lat < 90; lat += 2) {  	for (double lon = -180; lon < 180; lon += 2) {  		if (lat % 30 == 0 || lon % 30 == 0) {  			x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  			y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  			drawDot (x' y' Color.white' overlay_static);  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: lat += 2
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: for (double lon = -180; lon < 180; lon += 2) {  	if (lat % 30 == 0 || lon % 30 == 0) {  		x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  		y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  		drawDot (x' y' Color.white' overlay_static);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: lon += 2
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: if (lat % 30 == 0 || lon % 30 == 0) {  	x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  	y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  	drawDot (x' y' Color.white' overlay_static);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: if (lat % 30 == 0 || lon % 30 == 0) {  	x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  	y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  	drawDot (x' y' Color.white' overlay_static);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: if (lat % 30 == 0 || lon % 30 == 0) {  	x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  	y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  	drawDot (x' y' Color.white' overlay_static);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: if (lat % 30 == 0 || lon % 30 == 0) {  	x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  	y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  	drawDot (x' y' Color.white' overlay_static);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: if (lat % 30 == 0 || lon % 30 == 0) {  	x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  	y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  	drawDot (x' y' Color.white' overlay_static);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: if (lat % 30 == 0 || lon % 30 == 0) {  	x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  	y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  	drawDot (x' y' Color.white' overlay_static);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: x = (int)(map.mapscale * ((map.projectLongitude (lon' lat) + 180) % 360));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawGrid,The following statement contains a magic number: y = (int)(map.mapscale * ((map.projectLatitude (lon' lat) + 90) % 180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLegendLabel,The following statement contains a magic number: lr.x -= dim.x / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLegend,The following statement contains a magic number: if (bigmap.mapmode == 0 && SCANcontroller.controller.legend) {  	GUILayout.Label (""' GUILayout.ExpandWidth (true));  	Rect r = GUILayoutUtility.GetLastRect ();  	r.width -= 64;  	GUI.DrawTexture (r' SCANmap.getLegend (-1500f' 9000f' SCANcontroller.controller.colours));  	for (float val = -1000f; val < 9000f; val += 1000f) {  		drawLegendLabel (r' val' -1500f' 9000f);  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,drawLegend,The following statement contains a magic number: r.width -= 64;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging && !repainting) {  	if (Input.GetMouseButtonUp (0)) {  		bigmap_dragging = false;  		if (bigmap_drag_w < 400)  			bigmap_drag_w = 400;  		bigmap.setWidth ((int)bigmap_drag_w);  		overlay_static = null;  		SCANcontroller.controller.map_width = bigmap.mapwidth;  	}  	else {  		float xx = Input.mousePosition.x;  		bigmap_drag_w += xx - bigmap_drag_x;  		bigmap_drag_x = xx;  	}  	if (Event.current.isMouse)  		Event.current.Use ();  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging && !repainting) {  	if (Input.GetMouseButtonUp (0)) {  		bigmap_dragging = false;  		if (bigmap_drag_w < 400)  			bigmap_drag_w = 400;  		bigmap.setWidth ((int)bigmap_drag_w);  		overlay_static = null;  		SCANcontroller.controller.map_width = bigmap.mapwidth;  	}  	else {  		float xx = Input.mousePosition.x;  		bigmap_drag_w += xx - bigmap_drag_x;  		bigmap_drag_x = xx;  	}  	if (Event.current.isMouse)  		Event.current.Use ();  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Input.GetMouseButtonUp (0)) {  	bigmap_dragging = false;  	if (bigmap_drag_w < 400)  		bigmap_drag_w = 400;  	bigmap.setWidth ((int)bigmap_drag_w);  	overlay_static = null;  	SCANcontroller.controller.map_width = bigmap.mapwidth;  }  else {  	float xx = Input.mousePosition.x;  	bigmap_drag_w += xx - bigmap_drag_x;  	bigmap_drag_x = xx;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Input.GetMouseButtonUp (0)) {  	bigmap_dragging = false;  	if (bigmap_drag_w < 400)  		bigmap_drag_w = 400;  	bigmap.setWidth ((int)bigmap_drag_w);  	overlay_static = null;  	SCANcontroller.controller.map_width = bigmap.mapwidth;  }  else {  	float xx = Input.mousePosition.x;  	bigmap_drag_w += xx - bigmap_drag_x;  	bigmap_drag_x = xx;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_drag_w < 400)  	bigmap_drag_w = 400;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_drag_w < 400)  	bigmap_drag_w = 400;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: bigmap_drag_w = 400;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (dw < 400)  	dw = 400;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (dw < 400)  	dw = 400;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: dw = 400;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap.projection == SCANmap.MapProjection.Polar) {  	rc.x = maprect.x + maprect.width / 2 - maprect.width / 8;  	rc.y = maprect.y + maprect.height / 8;  	drawLabel (rc' Color.white' "S"' true' true);  	rc.x = maprect.x + maprect.width / 2 + maprect.width / 8;  	drawLabel (rc' Color.white' "N"' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap.projection == SCANmap.MapProjection.Polar) {  	rc.x = maprect.x + maprect.width / 2 - maprect.width / 8;  	rc.y = maprect.y + maprect.height / 8;  	drawLabel (rc' Color.white' "S"' true' true);  	rc.x = maprect.x + maprect.width / 2 + maprect.width / 8;  	drawLabel (rc' Color.white' "N"' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap.projection == SCANmap.MapProjection.Polar) {  	rc.x = maprect.x + maprect.width / 2 - maprect.width / 8;  	rc.y = maprect.y + maprect.height / 8;  	drawLabel (rc' Color.white' "S"' true' true);  	rc.x = maprect.x + maprect.width / 2 + maprect.width / 8;  	drawLabel (rc' Color.white' "N"' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap.projection == SCANmap.MapProjection.Polar) {  	rc.x = maprect.x + maprect.width / 2 - maprect.width / 8;  	rc.y = maprect.y + maprect.height / 8;  	drawLabel (rc' Color.white' "S"' true' true);  	rc.x = maprect.x + maprect.width / 2 + maprect.width / 8;  	drawLabel (rc' Color.white' "N"' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap.projection == SCANmap.MapProjection.Polar) {  	rc.x = maprect.x + maprect.width / 2 - maprect.width / 8;  	rc.y = maprect.y + maprect.height / 8;  	drawLabel (rc' Color.white' "S"' true' true);  	rc.x = maprect.x + maprect.width / 2 + maprect.width / 8;  	drawLabel (rc' Color.white' "N"' true' true);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: rc.x = maprect.x + maprect.width / 2 - maprect.width / 8;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: rc.x = maprect.x + maprect.width / 2 - maprect.width / 8;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: rc.y = maprect.y + maprect.height / 8;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: rc.x = maprect.x + maprect.width / 2 + maprect.width / 8;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: rc.x = maprect.x + maprect.width / 2 + maprect.width / 8;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: GUILayout.BeginHorizontal (GUILayout.Width (300));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: style_button.normal.textColor = bigmap.mapmode == 2 ? c_good : Color.white;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (GUILayout.Button ("Biome"' style_button)) {  	bigmap.resetMap (2);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: bigmap.resetMap (2);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= 0 && my >= 0 && mx < map.width && my < map.height && !bigmap_dragging) {  	double mlo = (mx * 360f / map.width) - 180;  	double mla = 90 - (my * 180f / map.height);  	mlon = bigmap.unprojectLongitude (mlo' mla);  	mlat = bigmap.unprojectLatitude (mlo' mla);  	if (spotmap != null) {  		if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  			in_spotmap = true;  			mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  			mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  			if (mlat > 90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = 180 - mlat;  			}  			else if (mlat < -90) {  				mlon = (mlon + 360) % 360 - 180;  				mlat = -180 - mlat;  			}  		}  	}  	if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  		in_map = true;  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "LO ");  			else  				info += colored (c_good' "LO ");  		}  		else  			info += "<color=\"grey\">LO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			if (vessel.mainBody.pqsController == null)  				info += colored (c_ugly' "HI ");  			else  				info += colored (c_good' "HI ");  		}  		else  			info += "<color=\"grey\">HI</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  				info += colored (c_ugly' "BIO ");  			else  				info += colored (c_good' "BIO ");  		}  		else  			info += "<color=\"grey\">BIO</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  			info += colored (c_good' "ANOM ");  		else  			info += "<color=\"grey\">ANOM</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  			info += colored (c_good' "BTDT ");  		else  			info += "<color=\"grey\">BTDT</color> ";  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  			info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  		}  		else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  			info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  		}  		if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  			info += data.getBiomeName (mlon' mlat) + " ";  		}  		info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  		if (in_spotmap)  			info += " " + spotmap.mapscale.ToString ("F1") + "x";  	}  	else {  		info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  		// uncomment for debugging projections  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  		in_spotmap = true;  		mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  		mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  		if (mlat > 90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = 180 - mlat;  		}  		else if (mlat < -90) {  			mlon = (mlon + 360) % 360 - 180;  			mlat = -180 - mlat;  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx >= pos_spotmap.x - maprect.x && my >= pos_spotmap.y - maprect.y && mx <= pos_spotmap.x + pos_spotmap.width - maprect.x && my <= pos_spotmap.y + pos_spotmap.height - maprect.y) {  	in_spotmap = true;  	mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  	mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  	if (mlat > 90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = 180 - mlat;  	}  	else if (mlat < -90) {  		mlon = (mlon + 360) % 360 - 180;  		mlat = -180 - mlat;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlon = spotmap.lon_offset + ((mx - pos_spotmap.x + maprect.x) / spotmap.mapscale) - 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlat = spotmap.lat_offset + ((pos_spotmap.height - (my - pos_spotmap.y + maprect.y)) / spotmap.mapscale) - 90;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat > 90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = 180 - mlat;  }  else if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlon = (mlon + 360) % 360 - 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlon = (mlon + 360) % 360 - 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlon = (mlon + 360) % 360 - 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlat = 180 - mlat;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlat < -90) {  	mlon = (mlon + 360) % 360 - 180;  	mlat = -180 - mlat;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlon = (mlon + 360) % 360 - 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlon = (mlon + 360) % 360 - 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlon = (mlon + 360) % 360 - 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: mlat = -180 - mlat;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  	in_map = true;  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "LO ");  		else  			info += colored (c_good' "LO ");  	}  	else  		info += "<color=\"grey\">LO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "HI ");  		else  			info += colored (c_good' "HI ");  	}  	else  		info += "<color=\"grey\">HI</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  			info += colored (c_ugly' "BIO ");  		else  			info += colored (c_good' "BIO ");  	}  	else  		info += "<color=\"grey\">BIO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  		info += colored (c_good' "ANOM ");  	else  		info += "<color=\"grey\">ANOM</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  		info += colored (c_good' "BTDT ");  	else  		info += "<color=\"grey\">BTDT</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  	}  	else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  	}  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		info += data.getBiomeName (mlon' mlat) + " ";  	}  	info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  	if (in_spotmap)  		info += " " + spotmap.mapscale.ToString ("F1") + "x";  }  else {  	info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  	// uncomment for debugging projections  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  	in_map = true;  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "LO ");  		else  			info += colored (c_good' "LO ");  	}  	else  		info += "<color=\"grey\">LO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "HI ");  		else  			info += colored (c_good' "HI ");  	}  	else  		info += "<color=\"grey\">HI</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  			info += colored (c_ugly' "BIO ");  		else  			info += colored (c_good' "BIO ");  	}  	else  		info += "<color=\"grey\">BIO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  		info += colored (c_good' "ANOM ");  	else  		info += "<color=\"grey\">ANOM</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  		info += colored (c_good' "BTDT ");  	else  		info += "<color=\"grey\">BTDT</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  	}  	else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  	}  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		info += data.getBiomeName (mlon' mlat) + " ";  	}  	info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  	if (in_spotmap)  		info += " " + spotmap.mapscale.ToString ("F1") + "x";  }  else {  	info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  	// uncomment for debugging projections  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  	in_map = true;  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "LO ");  		else  			info += colored (c_good' "LO ");  	}  	else  		info += "<color=\"grey\">LO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "HI ");  		else  			info += colored (c_good' "HI ");  	}  	else  		info += "<color=\"grey\">HI</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  			info += colored (c_ugly' "BIO ");  		else  			info += colored (c_good' "BIO ");  	}  	else  		info += "<color=\"grey\">BIO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  		info += colored (c_good' "ANOM ");  	else  		info += "<color=\"grey\">ANOM</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  		info += colored (c_good' "BTDT ");  	else  		info += "<color=\"grey\">BTDT</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  	}  	else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  	}  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		info += data.getBiomeName (mlon' mlat) + " ";  	}  	info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  	if (in_spotmap)  		info += " " + spotmap.mapscale.ToString ("F1") + "x";  }  else {  	info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  	// uncomment for debugging projections  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  	in_map = true;  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "LO ");  		else  			info += colored (c_good' "LO ");  	}  	else  		info += "<color=\"grey\">LO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "HI ");  		else  			info += colored (c_good' "HI ");  	}  	else  		info += "<color=\"grey\">HI</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  			info += colored (c_ugly' "BIO ");  		else  			info += colored (c_good' "BIO ");  	}  	else  		info += "<color=\"grey\">BIO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  		info += colored (c_good' "ANOM ");  	else  		info += "<color=\"grey\">ANOM</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  		info += colored (c_good' "BTDT ");  	else  		info += "<color=\"grey\">BTDT</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  	}  	else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  	}  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		info += data.getBiomeName (mlon' mlat) + " ";  	}  	info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  	if (in_spotmap)  		info += " " + spotmap.mapscale.ToString ("F1") + "x";  }  else {  	info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  	// uncomment for debugging projections  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  	in_map = true;  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "LO ");  		else  			info += colored (c_good' "LO ");  	}  	else  		info += "<color=\"grey\">LO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "HI ");  		else  			info += colored (c_good' "HI ");  	}  	else  		info += "<color=\"grey\">HI</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  			info += colored (c_ugly' "BIO ");  		else  			info += colored (c_good' "BIO ");  	}  	else  		info += "<color=\"grey\">BIO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  		info += colored (c_good' "ANOM ");  	else  		info += "<color=\"grey\">ANOM</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  		info += colored (c_good' "BTDT ");  	else  		info += "<color=\"grey\">BTDT</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  	}  	else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  	}  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		info += data.getBiomeName (mlon' mlat) + " ";  	}  	info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  	if (in_spotmap)  		info += " " + spotmap.mapscale.ToString ("F1") + "x";  }  else {  	info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  	// uncomment for debugging projections  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mlon >= -180 && mlon <= 180 && mlat >= -90 && mlat <= 90) {  	in_map = true;  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "LO ");  		else  			info += colored (c_good' "LO ");  	}  	else  		info += "<color=\"grey\">LO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		if (vessel.mainBody.pqsController == null)  			info += colored (c_ugly' "HI ");  		else  			info += colored (c_good' "HI ");  	}  	else  		info += "<color=\"grey\">HI</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		if (vessel.mainBody.BiomeMap == null || vessel.mainBody.BiomeMap.Map == null)  			info += colored (c_ugly' "BIO ");  		else  			info += colored (c_good' "BIO ");  	}  	else  		info += "<color=\"grey\">BIO</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Anomaly))  		info += colored (c_good' "ANOM ");  	else  		info += "<color=\"grey\">ANOM</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AnomalyDetail))  		info += colored (c_good' "BTDT ");  	else  		info += "<color=\"grey\">BTDT</color> ";  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  		info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  	}  	else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  		info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  	}  	if (data.isCovered (mlon' mlat' SCANdata.SCANtype.Biome)) {  		info += data.getBiomeName (mlon' mlat) + " ";  	}  	info += "\n" + toDMS (mlat' mlon) + " (lat: " + mlat.ToString ("F2") + " lon: " + mlon.ToString ("F2") + ") ";  	if (in_spotmap)  		info += " " + spotmap.mapscale.ToString ("F1") + "x";  }  else {  	info += " " + mlat.ToString ("F") + " " + mlon.ToString ("F");  	// uncomment for debugging projections  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  	info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  }  else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  	info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryHiRes)) {  	info += "<b>" + data.getElevation (mlon' mlat).ToString ("N2") + "m</b> ";  }  else if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  	info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  	info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (data.isCovered (mlon' mlat' SCANdata.SCANtype.AltimetryLoRes)) {  	info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: info += "<b>~" + (((int)data.getElevation (mlon' mlat) / 500) * 500).ToString () + "m</b> ";  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (maprect.width < 720) {  	GUILayout.EndHorizontal ();  	readableLabel (info' Color.white);  	drawLegend ();  }  else {  	GUILayout.BeginVertical ();  	readableLabel (info' Color.white);  	drawLegend ();  	GUILayout.EndVertical ();  	GUILayout.EndHorizontal ();  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null) {  	spotmap.setBody (vessel.mainBody);  	GUI.Box (pos_spotmap' spotmap.getPartialMap ());  	if (!notMappingToday) {  		drawOrbit (pos_spotmap' spotmap' vessel);  		drawMapLabels (pos_spotmap' vessel' spotmap' data);  	}  	pos_spotmap_x.x = pos_spotmap.x + pos_spotmap.width + 4;  	pos_spotmap_x.y = pos_spotmap.y;  	style_button.normal.textColor = cb_vermillion;  	if (GUI.Button (pos_spotmap_x' SCANcontroller.controller.closeBox' style_button)) {  		spotmap = null;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: pos_spotmap_x.x = pos_spotmap.x + pos_spotmap.width + 4;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.isMouse) {  	if (Event.current.type == EventType.MouseUp) {  		if (bigmap_dragging) {  		}  		else if (Event.current.button == 1) {  			if (in_map || in_spotmap) {  				if (spotmap == null) {  					spotmap = new SCANmap ();  					spotmap.setSize (180' 180);  				}  				if (in_spotmap) {  					spotmap.mapscale = spotmap.mapscale * 1.25f;  				}  				else {  					spotmap.mapscale = 10;  				}  				spotmap.centerAround (mlon' mlat);  				spotmap.resetMap (bigmap.mapmode);  				pos_spotmap.width = 180;  				pos_spotmap.height = 180;  				if (!in_spotmap) {  					pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  					pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  					if (mx > maprect.width / 2)  						pos_spotmap.x -= pos_spotmap.width;  					else  						pos_spotmap.x += pos_spotmap.height;  					pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  					pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  				}  			}  		}  		else if (Event.current.button == 0) {  			if (spotmap != null && in_spotmap) {  				spotmap.mapscale = spotmap.mapscale / 1.25f;  				if (spotmap.mapscale < 10)  					spotmap.mapscale = 10;  				spotmap.resetMap (spotmap.mapmode);  				Event.current.Use ();  			}  		}  		Event.current.Use ();  	}  	else if (Event.current.type == EventType.MouseDown) {  		if (Event.current.button == 0) {  			if (resizer.Contains (Event.current.mousePosition)) {  				bigmap_dragging = true;  				bigmap_drag_x = Input.mousePosition.x;  				bigmap_drag_w = bigmap.mapwidth;  				Event.current.Use ();  			}  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.type == EventType.MouseUp) {  	if (bigmap_dragging) {  	}  	else if (Event.current.button == 1) {  		if (in_map || in_spotmap) {  			if (spotmap == null) {  				spotmap = new SCANmap ();  				spotmap.setSize (180' 180);  			}  			if (in_spotmap) {  				spotmap.mapscale = spotmap.mapscale * 1.25f;  			}  			else {  				spotmap.mapscale = 10;  			}  			spotmap.centerAround (mlon' mlat);  			spotmap.resetMap (bigmap.mapmode);  			pos_spotmap.width = 180;  			pos_spotmap.height = 180;  			if (!in_spotmap) {  				pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  				pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  				if (mx > maprect.width / 2)  					pos_spotmap.x -= pos_spotmap.width;  				else  					pos_spotmap.x += pos_spotmap.height;  				pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  				pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  			}  		}  	}  	else if (Event.current.button == 0) {  		if (spotmap != null && in_spotmap) {  			spotmap.mapscale = spotmap.mapscale / 1.25f;  			if (spotmap.mapscale < 10)  				spotmap.mapscale = 10;  			spotmap.resetMap (spotmap.mapmode);  			Event.current.Use ();  		}  	}  	Event.current.Use ();  }  else if (Event.current.type == EventType.MouseDown) {  	if (Event.current.button == 0) {  		if (resizer.Contains (Event.current.mousePosition)) {  			bigmap_dragging = true;  			bigmap_drag_x = Input.mousePosition.x;  			bigmap_drag_w = bigmap.mapwidth;  			Event.current.Use ();  		}  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (bigmap_dragging) {  }  else if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 1) {  	if (in_map || in_spotmap) {  		if (spotmap == null) {  			spotmap = new SCANmap ();  			spotmap.setSize (180' 180);  		}  		if (in_spotmap) {  			spotmap.mapscale = spotmap.mapscale * 1.25f;  		}  		else {  			spotmap.mapscale = 10;  		}  		spotmap.centerAround (mlon' mlat);  		spotmap.resetMap (bigmap.mapmode);  		pos_spotmap.width = 180;  		pos_spotmap.height = 180;  		if (!in_spotmap) {  			pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  			pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  			if (mx > maprect.width / 2)  				pos_spotmap.x -= pos_spotmap.width;  			else  				pos_spotmap.x += pos_spotmap.height;  			pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  			pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  		}  	}  }  else if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_map || in_spotmap) {  	if (spotmap == null) {  		spotmap = new SCANmap ();  		spotmap.setSize (180' 180);  	}  	if (in_spotmap) {  		spotmap.mapscale = spotmap.mapscale * 1.25f;  	}  	else {  		spotmap.mapscale = 10;  	}  	spotmap.centerAround (mlon' mlat);  	spotmap.resetMap (bigmap.mapmode);  	pos_spotmap.width = 180;  	pos_spotmap.height = 180;  	if (!in_spotmap) {  		pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  		pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  		if (mx > maprect.width / 2)  			pos_spotmap.x -= pos_spotmap.width;  		else  			pos_spotmap.x += pos_spotmap.height;  		pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  		pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_map || in_spotmap) {  	if (spotmap == null) {  		spotmap = new SCANmap ();  		spotmap.setSize (180' 180);  	}  	if (in_spotmap) {  		spotmap.mapscale = spotmap.mapscale * 1.25f;  	}  	else {  		spotmap.mapscale = 10;  	}  	spotmap.centerAround (mlon' mlat);  	spotmap.resetMap (bigmap.mapmode);  	pos_spotmap.width = 180;  	pos_spotmap.height = 180;  	if (!in_spotmap) {  		pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  		pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  		if (mx > maprect.width / 2)  			pos_spotmap.x -= pos_spotmap.width;  		else  			pos_spotmap.x += pos_spotmap.height;  		pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  		pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_map || in_spotmap) {  	if (spotmap == null) {  		spotmap = new SCANmap ();  		spotmap.setSize (180' 180);  	}  	if (in_spotmap) {  		spotmap.mapscale = spotmap.mapscale * 1.25f;  	}  	else {  		spotmap.mapscale = 10;  	}  	spotmap.centerAround (mlon' mlat);  	spotmap.resetMap (bigmap.mapmode);  	pos_spotmap.width = 180;  	pos_spotmap.height = 180;  	if (!in_spotmap) {  		pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  		pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  		if (mx > maprect.width / 2)  			pos_spotmap.x -= pos_spotmap.width;  		else  			pos_spotmap.x += pos_spotmap.height;  		pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  		pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_map || in_spotmap) {  	if (spotmap == null) {  		spotmap = new SCANmap ();  		spotmap.setSize (180' 180);  	}  	if (in_spotmap) {  		spotmap.mapscale = spotmap.mapscale * 1.25f;  	}  	else {  		spotmap.mapscale = 10;  	}  	spotmap.centerAround (mlon' mlat);  	spotmap.resetMap (bigmap.mapmode);  	pos_spotmap.width = 180;  	pos_spotmap.height = 180;  	if (!in_spotmap) {  		pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  		pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  		if (mx > maprect.width / 2)  			pos_spotmap.x -= pos_spotmap.width;  		else  			pos_spotmap.x += pos_spotmap.height;  		pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  		pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_map || in_spotmap) {  	if (spotmap == null) {  		spotmap = new SCANmap ();  		spotmap.setSize (180' 180);  	}  	if (in_spotmap) {  		spotmap.mapscale = spotmap.mapscale * 1.25f;  	}  	else {  		spotmap.mapscale = 10;  	}  	spotmap.centerAround (mlon' mlat);  	spotmap.resetMap (bigmap.mapmode);  	pos_spotmap.width = 180;  	pos_spotmap.height = 180;  	if (!in_spotmap) {  		pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  		pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  		if (mx > maprect.width / 2)  			pos_spotmap.x -= pos_spotmap.width;  		else  			pos_spotmap.x += pos_spotmap.height;  		pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  		pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_map || in_spotmap) {  	if (spotmap == null) {  		spotmap = new SCANmap ();  		spotmap.setSize (180' 180);  	}  	if (in_spotmap) {  		spotmap.mapscale = spotmap.mapscale * 1.25f;  	}  	else {  		spotmap.mapscale = 10;  	}  	spotmap.centerAround (mlon' mlat);  	spotmap.resetMap (bigmap.mapmode);  	pos_spotmap.width = 180;  	pos_spotmap.height = 180;  	if (!in_spotmap) {  		pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  		pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  		if (mx > maprect.width / 2)  			pos_spotmap.x -= pos_spotmap.width;  		else  			pos_spotmap.x += pos_spotmap.height;  		pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  		pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_map || in_spotmap) {  	if (spotmap == null) {  		spotmap = new SCANmap ();  		spotmap.setSize (180' 180);  	}  	if (in_spotmap) {  		spotmap.mapscale = spotmap.mapscale * 1.25f;  	}  	else {  		spotmap.mapscale = 10;  	}  	spotmap.centerAround (mlon' mlat);  	spotmap.resetMap (bigmap.mapmode);  	pos_spotmap.width = 180;  	pos_spotmap.height = 180;  	if (!in_spotmap) {  		pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  		pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  		if (mx > maprect.width / 2)  			pos_spotmap.x -= pos_spotmap.width;  		else  			pos_spotmap.x += pos_spotmap.height;  		pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  		pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_map || in_spotmap) {  	if (spotmap == null) {  		spotmap = new SCANmap ();  		spotmap.setSize (180' 180);  	}  	if (in_spotmap) {  		spotmap.mapscale = spotmap.mapscale * 1.25f;  	}  	else {  		spotmap.mapscale = 10;  	}  	spotmap.centerAround (mlon' mlat);  	spotmap.resetMap (bigmap.mapmode);  	pos_spotmap.width = 180;  	pos_spotmap.height = 180;  	if (!in_spotmap) {  		pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  		pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  		if (mx > maprect.width / 2)  			pos_spotmap.x -= pos_spotmap.width;  		else  			pos_spotmap.x += pos_spotmap.height;  		pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  		pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap == null) {  	spotmap = new SCANmap ();  	spotmap.setSize (180' 180);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap == null) {  	spotmap = new SCANmap ();  	spotmap.setSize (180' 180);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: spotmap.setSize (180' 180);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: spotmap.setSize (180' 180);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (in_spotmap) {  	spotmap.mapscale = spotmap.mapscale * 1.25f;  }  else {  	spotmap.mapscale = 10;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: spotmap.mapscale = 10;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: pos_spotmap.width = 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: pos_spotmap.height = 180;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (!in_spotmap) {  	pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  	pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  	if (mx > maprect.width / 2)  		pos_spotmap.x -= pos_spotmap.width;  	else  		pos_spotmap.x += pos_spotmap.height;  	pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  	pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (!in_spotmap) {  	pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  	pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  	if (mx > maprect.width / 2)  		pos_spotmap.x -= pos_spotmap.width;  	else  		pos_spotmap.x += pos_spotmap.height;  	pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  	pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (!in_spotmap) {  	pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  	pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  	if (mx > maprect.width / 2)  		pos_spotmap.x -= pos_spotmap.width;  	else  		pos_spotmap.x += pos_spotmap.height;  	pos_spotmap.x = Math.Max (maprect.x' Math.Min (maprect.x + maprect.width - pos_spotmap.width' pos_spotmap.x));  	pos_spotmap.y = Math.Max (maprect.y' Math.Min (maprect.y + maprect.height - pos_spotmap.height' pos_spotmap.y));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: pos_spotmap.x = Event.current.mousePosition.x - pos_spotmap.width / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: pos_spotmap.y = Event.current.mousePosition.y - pos_spotmap.height / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (mx > maprect.width / 2)  	pos_spotmap.x -= pos_spotmap.width;  else  	pos_spotmap.x += pos_spotmap.height;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (Event.current.button == 0) {  	if (spotmap != null && in_spotmap) {  		spotmap.mapscale = spotmap.mapscale / 1.25f;  		if (spotmap.mapscale < 10)  			spotmap.mapscale = 10;  		spotmap.resetMap (spotmap.mapmode);  		Event.current.Use ();  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null && in_spotmap) {  	spotmap.mapscale = spotmap.mapscale / 1.25f;  	if (spotmap.mapscale < 10)  		spotmap.mapscale = 10;  	spotmap.resetMap (spotmap.mapmode);  	Event.current.Use ();  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap != null && in_spotmap) {  	spotmap.mapscale = spotmap.mapscale / 1.25f;  	if (spotmap.mapscale < 10)  		spotmap.mapscale = 10;  	spotmap.resetMap (spotmap.mapmode);  	Event.current.Use ();  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap.mapscale < 10)  	spotmap.mapscale = 10;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: if (spotmap.mapscale < 10)  	spotmap.mapscale = 10;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_bigmap_build,The following statement contains a magic number: spotmap.mapscale = 10;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (Time.frameCount - gui_frame_ping > 5) {  	gui_active = false;  	RenderingManager.RemoveFromPostDrawQueue (3' guicb);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (Time.frameCount - gui_frame_ping > 5) {  	gui_active = false;  	RenderingManager.RemoveFromPostDrawQueue (3' guicb);  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: RenderingManager.RemoveFromPostDrawQueue (3' guicb);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (style_headline == null) {  	style_headline = new GUIStyle ();  	style_headline.normal.textColor = XKCDColors.YellowGreen;  	style_headline.alignment = TextAnchor.MiddleCenter;  	style_headline.fontSize = 40;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: style_headline.fontSize = 40;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!repainting) {  	// Unity gets confused if the layout changes between layout and repaint events  	infotext = "";  	string aoff = "<color=\"grey\">";  	string aon = "<color=\"" + colorHex (c_good) + "\">";  	string abad = "<color=\"" + colorHex (c_bad) + "\">";  	string ano = "<color=\"" + colorHex (c_ugly) + "\">";  	string ac = "</color> ";  	string stat_alo = aon' stat_ahi = aon' stat_biome = aon' stat_ano = aon' stat_btdt = aon;  	minicolor = c_good;  	if (sensors == 0)  		minicolor = Color.grey;  	SCANcontroller.SCANsensor s;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryLoRes);  	if (s == null)  		stat_alo = aoff;  	else if (!s.inRange)  		stat_alo = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_alo = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryHiRes);  	if (s == null)  		stat_ahi = aoff;  	else if (!s.inRange)  		stat_ahi = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ahi = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Anomaly);  	if (s == null)  		stat_ano = aoff;  	else if (!s.inRange)  		stat_ano = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ano = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Biome);  	if (s == null)  		stat_biome = aoff;  	else if (!s.inRange)  		stat_biome = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_biome = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AnomalyDetail);  	if (s == null)  		stat_btdt = aoff;  	else if (!s.inRange)  		stat_btdt = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_btdt = abad;  	infotext = stat_alo + "LO" + ac + stat_ahi + "HI" + ac + stat_biome + "BIO" + ac + stat_ano + "ANOM" + ac + stat_btdt + "BTDT" + ac;  	SCANdata.SCANtype active = SCANcontroller.controller.activeSensorsOnVessel (vessel.id);  	if (active != SCANdata.SCANtype.Nothing) {  		double cov = data.getCoveragePercentage (active);  		infotext += " " + cov.ToString ("N1") + "%";  		if (notMappingToday) {  			infotext = abad + "NO POWER" + ac;  		}  	}  	else {  		if (maptraq_frame < Time.frameCount - 5) {  			notMappingToday = true;  			infotext = abad + "NO DATA" + ac;  		}  	}  	title = "S.C.A.N. Planetary Mapping";  	if (minimode <= 0)  		title = " ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!repainting) {  	// Unity gets confused if the layout changes between layout and repaint events  	infotext = "";  	string aoff = "<color=\"grey\">";  	string aon = "<color=\"" + colorHex (c_good) + "\">";  	string abad = "<color=\"" + colorHex (c_bad) + "\">";  	string ano = "<color=\"" + colorHex (c_ugly) + "\">";  	string ac = "</color> ";  	string stat_alo = aon' stat_ahi = aon' stat_biome = aon' stat_ano = aon' stat_btdt = aon;  	minicolor = c_good;  	if (sensors == 0)  		minicolor = Color.grey;  	SCANcontroller.SCANsensor s;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryLoRes);  	if (s == null)  		stat_alo = aoff;  	else if (!s.inRange)  		stat_alo = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_alo = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryHiRes);  	if (s == null)  		stat_ahi = aoff;  	else if (!s.inRange)  		stat_ahi = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ahi = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Anomaly);  	if (s == null)  		stat_ano = aoff;  	else if (!s.inRange)  		stat_ano = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ano = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Biome);  	if (s == null)  		stat_biome = aoff;  	else if (!s.inRange)  		stat_biome = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_biome = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AnomalyDetail);  	if (s == null)  		stat_btdt = aoff;  	else if (!s.inRange)  		stat_btdt = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_btdt = abad;  	infotext = stat_alo + "LO" + ac + stat_ahi + "HI" + ac + stat_biome + "BIO" + ac + stat_ano + "ANOM" + ac + stat_btdt + "BTDT" + ac;  	SCANdata.SCANtype active = SCANcontroller.controller.activeSensorsOnVessel (vessel.id);  	if (active != SCANdata.SCANtype.Nothing) {  		double cov = data.getCoveragePercentage (active);  		infotext += " " + cov.ToString ("N1") + "%";  		if (notMappingToday) {  			infotext = abad + "NO POWER" + ac;  		}  	}  	else {  		if (maptraq_frame < Time.frameCount - 5) {  			notMappingToday = true;  			infotext = abad + "NO DATA" + ac;  		}  	}  	title = "S.C.A.N. Planetary Mapping";  	if (minimode <= 0)  		title = " ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!repainting) {  	// Unity gets confused if the layout changes between layout and repaint events  	infotext = "";  	string aoff = "<color=\"grey\">";  	string aon = "<color=\"" + colorHex (c_good) + "\">";  	string abad = "<color=\"" + colorHex (c_bad) + "\">";  	string ano = "<color=\"" + colorHex (c_ugly) + "\">";  	string ac = "</color> ";  	string stat_alo = aon' stat_ahi = aon' stat_biome = aon' stat_ano = aon' stat_btdt = aon;  	minicolor = c_good;  	if (sensors == 0)  		minicolor = Color.grey;  	SCANcontroller.SCANsensor s;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryLoRes);  	if (s == null)  		stat_alo = aoff;  	else if (!s.inRange)  		stat_alo = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_alo = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryHiRes);  	if (s == null)  		stat_ahi = aoff;  	else if (!s.inRange)  		stat_ahi = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ahi = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Anomaly);  	if (s == null)  		stat_ano = aoff;  	else if (!s.inRange)  		stat_ano = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ano = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Biome);  	if (s == null)  		stat_biome = aoff;  	else if (!s.inRange)  		stat_biome = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_biome = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AnomalyDetail);  	if (s == null)  		stat_btdt = aoff;  	else if (!s.inRange)  		stat_btdt = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_btdt = abad;  	infotext = stat_alo + "LO" + ac + stat_ahi + "HI" + ac + stat_biome + "BIO" + ac + stat_ano + "ANOM" + ac + stat_btdt + "BTDT" + ac;  	SCANdata.SCANtype active = SCANcontroller.controller.activeSensorsOnVessel (vessel.id);  	if (active != SCANdata.SCANtype.Nothing) {  		double cov = data.getCoveragePercentage (active);  		infotext += " " + cov.ToString ("N1") + "%";  		if (notMappingToday) {  			infotext = abad + "NO POWER" + ac;  		}  	}  	else {  		if (maptraq_frame < Time.frameCount - 5) {  			notMappingToday = true;  			infotext = abad + "NO DATA" + ac;  		}  	}  	title = "S.C.A.N. Planetary Mapping";  	if (minimode <= 0)  		title = " ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!repainting) {  	// Unity gets confused if the layout changes between layout and repaint events  	infotext = "";  	string aoff = "<color=\"grey\">";  	string aon = "<color=\"" + colorHex (c_good) + "\">";  	string abad = "<color=\"" + colorHex (c_bad) + "\">";  	string ano = "<color=\"" + colorHex (c_ugly) + "\">";  	string ac = "</color> ";  	string stat_alo = aon' stat_ahi = aon' stat_biome = aon' stat_ano = aon' stat_btdt = aon;  	minicolor = c_good;  	if (sensors == 0)  		minicolor = Color.grey;  	SCANcontroller.SCANsensor s;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryLoRes);  	if (s == null)  		stat_alo = aoff;  	else if (!s.inRange)  		stat_alo = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_alo = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryHiRes);  	if (s == null)  		stat_ahi = aoff;  	else if (!s.inRange)  		stat_ahi = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ahi = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Anomaly);  	if (s == null)  		stat_ano = aoff;  	else if (!s.inRange)  		stat_ano = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ano = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Biome);  	if (s == null)  		stat_biome = aoff;  	else if (!s.inRange)  		stat_biome = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_biome = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AnomalyDetail);  	if (s == null)  		stat_btdt = aoff;  	else if (!s.inRange)  		stat_btdt = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_btdt = abad;  	infotext = stat_alo + "LO" + ac + stat_ahi + "HI" + ac + stat_biome + "BIO" + ac + stat_ano + "ANOM" + ac + stat_btdt + "BTDT" + ac;  	SCANdata.SCANtype active = SCANcontroller.controller.activeSensorsOnVessel (vessel.id);  	if (active != SCANdata.SCANtype.Nothing) {  		double cov = data.getCoveragePercentage (active);  		infotext += " " + cov.ToString ("N1") + "%";  		if (notMappingToday) {  			infotext = abad + "NO POWER" + ac;  		}  	}  	else {  		if (maptraq_frame < Time.frameCount - 5) {  			notMappingToday = true;  			infotext = abad + "NO DATA" + ac;  		}  	}  	title = "S.C.A.N. Planetary Mapping";  	if (minimode <= 0)  		title = " ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!repainting) {  	// Unity gets confused if the layout changes between layout and repaint events  	infotext = "";  	string aoff = "<color=\"grey\">";  	string aon = "<color=\"" + colorHex (c_good) + "\">";  	string abad = "<color=\"" + colorHex (c_bad) + "\">";  	string ano = "<color=\"" + colorHex (c_ugly) + "\">";  	string ac = "</color> ";  	string stat_alo = aon' stat_ahi = aon' stat_biome = aon' stat_ano = aon' stat_btdt = aon;  	minicolor = c_good;  	if (sensors == 0)  		minicolor = Color.grey;  	SCANcontroller.SCANsensor s;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryLoRes);  	if (s == null)  		stat_alo = aoff;  	else if (!s.inRange)  		stat_alo = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_alo = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryHiRes);  	if (s == null)  		stat_ahi = aoff;  	else if (!s.inRange)  		stat_ahi = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ahi = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Anomaly);  	if (s == null)  		stat_ano = aoff;  	else if (!s.inRange)  		stat_ano = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ano = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Biome);  	if (s == null)  		stat_biome = aoff;  	else if (!s.inRange)  		stat_biome = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_biome = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AnomalyDetail);  	if (s == null)  		stat_btdt = aoff;  	else if (!s.inRange)  		stat_btdt = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_btdt = abad;  	infotext = stat_alo + "LO" + ac + stat_ahi + "HI" + ac + stat_biome + "BIO" + ac + stat_ano + "ANOM" + ac + stat_btdt + "BTDT" + ac;  	SCANdata.SCANtype active = SCANcontroller.controller.activeSensorsOnVessel (vessel.id);  	if (active != SCANdata.SCANtype.Nothing) {  		double cov = data.getCoveragePercentage (active);  		infotext += " " + cov.ToString ("N1") + "%";  		if (notMappingToday) {  			infotext = abad + "NO POWER" + ac;  		}  	}  	else {  		if (maptraq_frame < Time.frameCount - 5) {  			notMappingToday = true;  			infotext = abad + "NO DATA" + ac;  		}  	}  	title = "S.C.A.N. Planetary Mapping";  	if (minimode <= 0)  		title = " ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!repainting) {  	// Unity gets confused if the layout changes between layout and repaint events  	infotext = "";  	string aoff = "<color=\"grey\">";  	string aon = "<color=\"" + colorHex (c_good) + "\">";  	string abad = "<color=\"" + colorHex (c_bad) + "\">";  	string ano = "<color=\"" + colorHex (c_ugly) + "\">";  	string ac = "</color> ";  	string stat_alo = aon' stat_ahi = aon' stat_biome = aon' stat_ano = aon' stat_btdt = aon;  	minicolor = c_good;  	if (sensors == 0)  		minicolor = Color.grey;  	SCANcontroller.SCANsensor s;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryLoRes);  	if (s == null)  		stat_alo = aoff;  	else if (!s.inRange)  		stat_alo = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_alo = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AltimetryHiRes);  	if (s == null)  		stat_ahi = aoff;  	else if (!s.inRange)  		stat_ahi = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ahi = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Anomaly);  	if (s == null)  		stat_ano = aoff;  	else if (!s.inRange)  		stat_ano = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_ano = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.Biome);  	if (s == null)  		stat_biome = aoff;  	else if (!s.inRange)  		stat_biome = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_biome = abad;  	s = SCANcontroller.controller.getSensorStatus (vessel' SCANdata.SCANtype.AnomalyDetail);  	if (s == null)  		stat_btdt = aoff;  	else if (!s.inRange)  		stat_btdt = abad;  	else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  		stat_btdt = abad;  	infotext = stat_alo + "LO" + ac + stat_ahi + "HI" + ac + stat_biome + "BIO" + ac + stat_ano + "ANOM" + ac + stat_btdt + "BTDT" + ac;  	SCANdata.SCANtype active = SCANcontroller.controller.activeSensorsOnVessel (vessel.id);  	if (active != SCANdata.SCANtype.Nothing) {  		double cov = data.getCoveragePercentage (active);  		infotext += " " + cov.ToString ("N1") + "%";  		if (notMappingToday) {  			infotext = abad + "NO POWER" + ac;  		}  	}  	else {  		if (maptraq_frame < Time.frameCount - 5) {  			notMappingToday = true;  			infotext = abad + "NO DATA" + ac;  		}  	}  	title = "S.C.A.N. Planetary Mapping";  	if (minimode <= 0)  		title = " ";  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (s == null)  	stat_alo = aoff;  else if (!s.inRange)  	stat_alo = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_alo = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.inRange)  	stat_alo = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_alo = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_alo = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (s == null)  	stat_ahi = aoff;  else if (!s.inRange)  	stat_ahi = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_ahi = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.inRange)  	stat_ahi = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_ahi = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_ahi = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (s == null)  	stat_ano = aoff;  else if (!s.inRange)  	stat_ano = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_ano = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.inRange)  	stat_ano = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_ano = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_ano = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (s == null)  	stat_biome = aoff;  else if (!s.inRange)  	stat_biome = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_biome = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.inRange)  	stat_biome = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_biome = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_biome = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (s == null)  	stat_btdt = aoff;  else if (!s.inRange)  	stat_btdt = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_btdt = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.inRange)  	stat_btdt = abad;  else if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_btdt = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (!s.bestRange && (Time.realtimeSinceStartup % 2 < 1))  	stat_btdt = abad;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (active != SCANdata.SCANtype.Nothing) {  	double cov = data.getCoveragePercentage (active);  	infotext += " " + cov.ToString ("N1") + "%";  	if (notMappingToday) {  		infotext = abad + "NO POWER" + ac;  	}  }  else {  	if (maptraq_frame < Time.frameCount - 5) {  		notMappingToday = true;  		infotext = abad + "NO DATA" + ac;  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (maptraq_frame < Time.frameCount - 5) {  	notMappingToday = true;  	infotext = abad + "NO DATA" + ac;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_infobox = GUILayout.Window (47110001' pos_infobox' gui_infobox_build' title' GUILayout.Width (32)' GUILayout.Height (32));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_infobox = GUILayout.Window (47110001' pos_infobox' gui_infobox_build' title' GUILayout.Width (32)' GUILayout.Height (32));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_infobox = GUILayout.Window (47110001' pos_infobox' gui_infobox_build' title' GUILayout.Width (32)' GUILayout.Height (32));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (bigmap_visible) {  	if (bigmap == null) {  		bigmap = new SCANmap ();  		bigmap.setProjection ((SCANmap.MapProjection)SCANcontroller.controller.projection);  		bigmap.setWidth (SCANcontroller.controller.map_width);  		pos_bigmap.x = SCANcontroller.controller.map_x;  		pos_bigmap.y = SCANcontroller.controller.map_y;  		if (pos_bigmap.x < 0 || pos_bigmap.x >= Screen.width)  			pos_bigmap.x = 0;  		if (pos_bigmap.y < 0 || pos_bigmap.y >= Screen.height)  			pos_bigmap.y = 0;  	}  	else {  		SCANcontroller.controller.map_x = (int)pos_bigmap.x;  		SCANcontroller.controller.map_y = (int)pos_bigmap.y;  	}  	bigmap.setBody (vessel.mainBody);  	string rendering = "";  	if (bigmap_dragging)  		rendering += " [" + bigmap_drag_w + "x" + (bigmap_drag_w / 2) + "]";  	if (!bigmap.isMapComplete ())  		rendering += " [rendering]";  	pos_bigmap = GUILayout.Window (47110002' pos_bigmap' gui_bigmap_build' "Map of " + vessel.mainBody.theName + rendering' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (bigmap_visible) {  	if (bigmap == null) {  		bigmap = new SCANmap ();  		bigmap.setProjection ((SCANmap.MapProjection)SCANcontroller.controller.projection);  		bigmap.setWidth (SCANcontroller.controller.map_width);  		pos_bigmap.x = SCANcontroller.controller.map_x;  		pos_bigmap.y = SCANcontroller.controller.map_y;  		if (pos_bigmap.x < 0 || pos_bigmap.x >= Screen.width)  			pos_bigmap.x = 0;  		if (pos_bigmap.y < 0 || pos_bigmap.y >= Screen.height)  			pos_bigmap.y = 0;  	}  	else {  		SCANcontroller.controller.map_x = (int)pos_bigmap.x;  		SCANcontroller.controller.map_y = (int)pos_bigmap.y;  	}  	bigmap.setBody (vessel.mainBody);  	string rendering = "";  	if (bigmap_dragging)  		rendering += " [" + bigmap_drag_w + "x" + (bigmap_drag_w / 2) + "]";  	if (!bigmap.isMapComplete ())  		rendering += " [rendering]";  	pos_bigmap = GUILayout.Window (47110002' pos_bigmap' gui_bigmap_build' "Map of " + vessel.mainBody.theName + rendering' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (bigmap_visible) {  	if (bigmap == null) {  		bigmap = new SCANmap ();  		bigmap.setProjection ((SCANmap.MapProjection)SCANcontroller.controller.projection);  		bigmap.setWidth (SCANcontroller.controller.map_width);  		pos_bigmap.x = SCANcontroller.controller.map_x;  		pos_bigmap.y = SCANcontroller.controller.map_y;  		if (pos_bigmap.x < 0 || pos_bigmap.x >= Screen.width)  			pos_bigmap.x = 0;  		if (pos_bigmap.y < 0 || pos_bigmap.y >= Screen.height)  			pos_bigmap.y = 0;  	}  	else {  		SCANcontroller.controller.map_x = (int)pos_bigmap.x;  		SCANcontroller.controller.map_y = (int)pos_bigmap.y;  	}  	bigmap.setBody (vessel.mainBody);  	string rendering = "";  	if (bigmap_dragging)  		rendering += " [" + bigmap_drag_w + "x" + (bigmap_drag_w / 2) + "]";  	if (!bigmap.isMapComplete ())  		rendering += " [rendering]";  	pos_bigmap = GUILayout.Window (47110002' pos_bigmap' gui_bigmap_build' "Map of " + vessel.mainBody.theName + rendering' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (bigmap_visible) {  	if (bigmap == null) {  		bigmap = new SCANmap ();  		bigmap.setProjection ((SCANmap.MapProjection)SCANcontroller.controller.projection);  		bigmap.setWidth (SCANcontroller.controller.map_width);  		pos_bigmap.x = SCANcontroller.controller.map_x;  		pos_bigmap.y = SCANcontroller.controller.map_y;  		if (pos_bigmap.x < 0 || pos_bigmap.x >= Screen.width)  			pos_bigmap.x = 0;  		if (pos_bigmap.y < 0 || pos_bigmap.y >= Screen.height)  			pos_bigmap.y = 0;  	}  	else {  		SCANcontroller.controller.map_x = (int)pos_bigmap.x;  		SCANcontroller.controller.map_y = (int)pos_bigmap.y;  	}  	bigmap.setBody (vessel.mainBody);  	string rendering = "";  	if (bigmap_dragging)  		rendering += " [" + bigmap_drag_w + "x" + (bigmap_drag_w / 2) + "]";  	if (!bigmap.isMapComplete ())  		rendering += " [rendering]";  	pos_bigmap = GUILayout.Window (47110002' pos_bigmap' gui_bigmap_build' "Map of " + vessel.mainBody.theName + rendering' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (bigmap_dragging)  	rendering += " [" + bigmap_drag_w + "x" + (bigmap_drag_w / 2) + "]";  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: rendering += " [" + bigmap_drag_w + "x" + (bigmap_drag_w / 2) + "]";  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_bigmap = GUILayout.Window (47110002' pos_bigmap' gui_bigmap_build' "Map of " + vessel.mainBody.theName + rendering' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_bigmap = GUILayout.Window (47110002' pos_bigmap' gui_bigmap_build' "Map of " + vessel.mainBody.theName + rendering' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_bigmap = GUILayout.Window (47110002' pos_bigmap' gui_bigmap_build' "Map of " + vessel.mainBody.theName + rendering' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (instruments_visible) {  	if (pos_instruments.x < 0) {  		pos_instruments.x = pos_infobox.x;  		pos_instruments.y = pos_infobox.y + pos_infobox.height + 8;  	}  	pos_instruments = GUILayout.Window (47110003' pos_instruments' gui_instruments_build' "S.C.A.N. Instruments"' GUILayout.Width (200)' GUILayout.Height (60));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (instruments_visible) {  	if (pos_instruments.x < 0) {  		pos_instruments.x = pos_infobox.x;  		pos_instruments.y = pos_infobox.y + pos_infobox.height + 8;  	}  	pos_instruments = GUILayout.Window (47110003' pos_instruments' gui_instruments_build' "S.C.A.N. Instruments"' GUILayout.Width (200)' GUILayout.Height (60));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (instruments_visible) {  	if (pos_instruments.x < 0) {  		pos_instruments.x = pos_infobox.x;  		pos_instruments.y = pos_infobox.y + pos_infobox.height + 8;  	}  	pos_instruments = GUILayout.Window (47110003' pos_instruments' gui_instruments_build' "S.C.A.N. Instruments"' GUILayout.Width (200)' GUILayout.Height (60));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (instruments_visible) {  	if (pos_instruments.x < 0) {  		pos_instruments.x = pos_infobox.x;  		pos_instruments.y = pos_infobox.y + pos_infobox.height + 8;  	}  	pos_instruments = GUILayout.Window (47110003' pos_instruments' gui_instruments_build' "S.C.A.N. Instruments"' GUILayout.Width (200)' GUILayout.Height (60));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (pos_instruments.x < 0) {  	pos_instruments.x = pos_infobox.x;  	pos_instruments.y = pos_infobox.y + pos_infobox.height + 8;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_instruments.y = pos_infobox.y + pos_infobox.height + 8;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_instruments = GUILayout.Window (47110003' pos_instruments' gui_instruments_build' "S.C.A.N. Instruments"' GUILayout.Width (200)' GUILayout.Height (60));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_instruments = GUILayout.Window (47110003' pos_instruments' gui_instruments_build' "S.C.A.N. Instruments"' GUILayout.Width (200)' GUILayout.Height (60));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_instruments = GUILayout.Window (47110003' pos_instruments' gui_instruments_build' "S.C.A.N. Instruments"' GUILayout.Width (200)' GUILayout.Height (60));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (settings_visible) {  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	if (pos_settings.x < 0 && pos_settings.width > 0) {  		pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  		pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  		pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  	}  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (pos_settings.x < 0 && pos_settings.width > 0) {  	pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  	pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (pos_settings.x < 0 && pos_settings.width > 0) {  	pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  	pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (pos_settings.x < 0 && pos_settings.width > 0) {  	pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  	pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (pos_settings.x < 0 && pos_settings.width > 0) {  	pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  	pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (pos_settings.x < 0 && pos_settings.width > 0) {  	pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  	pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (pos_settings.x < 0 && pos_settings.width > 0) {  	pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  	pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: if (pos_settings.x < 0 && pos_settings.width > 0) {  	pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  	pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  	pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings.x = Screen.width / 2 - pos_settings.width / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings.y = Screen.height / 3 - pos_settings.height / 2;  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_show,The following statement contains a magic number: pos_settings = GUILayout.Window (47110004' pos_settings' gui_settings_build' "S.C.A.N. Settings"' GUILayout.Width (360)' GUILayout.Height (180));  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_ping,The following statement contains a magic number: if (Time.frameCount - gui_frame_draw > 5) {  	// UI isn't working' try turning it off and on again  	RenderingManager.RemoveFromPostDrawQueue (3' guicb);  	gui_active = false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_ping,The following statement contains a magic number: if (Time.frameCount - gui_frame_draw > 5) {  	// UI isn't working' try turning it off and on again  	RenderingManager.RemoveFromPostDrawQueue (3' guicb);  	gui_active = false;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_ping,The following statement contains a magic number: RenderingManager.RemoveFromPostDrawQueue (3' guicb);  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_ping,The following statement contains a magic number: if (!gui_active) {  	RenderingManager.AddToPostDrawQueue (3' guicb);  	gui_active = true;  }  
Magic Number,SCANsat,SCANui,C:\repos\thatfool_SCAN\SCANui.cs,gui_ping,The following statement contains a magic number: RenderingManager.AddToPostDrawQueue (3' guicb);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,heightToColor,The following statement contains a magic number: if (val <= 0) {  	val = (Mathf.Clamp (val' -1500' 0) + 1500) / 1000f;  	c = Color.Lerp (XKCDColors.DarkPurple' XKCDColors.Cerulean' val);  }  else {  	val = (heightGradient.Length - 2) * Mathf.Clamp (val' 0' 7500) / 7500.0f;  	c = Color.Lerp (heightGradient [(int)val]' heightGradient [(int)val + 1]' val - (int)val);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,heightToColor,The following statement contains a magic number: if (val <= 0) {  	val = (Mathf.Clamp (val' -1500' 0) + 1500) / 1000f;  	c = Color.Lerp (XKCDColors.DarkPurple' XKCDColors.Cerulean' val);  }  else {  	val = (heightGradient.Length - 2) * Mathf.Clamp (val' 0' 7500) / 7500.0f;  	c = Color.Lerp (heightGradient [(int)val]' heightGradient [(int)val + 1]' val - (int)val);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,heightToColor,The following statement contains a magic number: if (val <= 0) {  	val = (Mathf.Clamp (val' -1500' 0) + 1500) / 1000f;  	c = Color.Lerp (XKCDColors.DarkPurple' XKCDColors.Cerulean' val);  }  else {  	val = (heightGradient.Length - 2) * Mathf.Clamp (val' 0' 7500) / 7500.0f;  	c = Color.Lerp (heightGradient [(int)val]' heightGradient [(int)val + 1]' val - (int)val);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,heightToColor,The following statement contains a magic number: if (val <= 0) {  	val = (Mathf.Clamp (val' -1500' 0) + 1500) / 1000f;  	c = Color.Lerp (XKCDColors.DarkPurple' XKCDColors.Cerulean' val);  }  else {  	val = (heightGradient.Length - 2) * Mathf.Clamp (val' 0' 7500) / 7500.0f;  	c = Color.Lerp (heightGradient [(int)val]' heightGradient [(int)val + 1]' val - (int)val);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,heightToColor,The following statement contains a magic number: val = (Mathf.Clamp (val' -1500' 0) + 1500) / 1000f;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,heightToColor,The following statement contains a magic number: val = (Mathf.Clamp (val' -1500' 0) + 1500) / 1000f;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,heightToColor,The following statement contains a magic number: val = (heightGradient.Length - 2) * Mathf.Clamp (val' 0' 7500) / 7500.0f;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,heightToColor,The following statement contains a magic number: val = (heightGradient.Length - 2) * Mathf.Clamp (val' 0' 7500) / 7500.0f;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getLegend,The following statement contains a magic number: legend = new Texture2D (256' 1' TextureFormat.RGB24' false);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getLegend,The following statement contains a magic number: for (int x = 0; x < 256; ++x) {  	float val = (x * (max - min)) / 256f + min;  	pix [x] = heightToColor (val' scheme);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: if (w == 0)  	w = 360 * (Screen.width / 360);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: if (w == 0)  	w = 360 * (Screen.width / 360);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: w = 360 * (Screen.width / 360);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: w = 360 * (Screen.width / 360);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: if (w > 360 * 4)  	w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: if (w > 360 * 4)  	w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: if (w > 360 * 4)  	w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: if (w > 360 * 4)  	w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: if (h <= 0)  	h = (int)(180 * mapscale);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setSize,The following statement contains a magic number: h = (int)(180 * mapscale);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w == 0) {  	w = 360 * (int)(Screen.width / 360);  	if (w > 360 * 4)  		w = 360 * 4;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w == 0) {  	w = 360 * (int)(Screen.width / 360);  	if (w > 360 * 4)  		w = 360 * 4;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w == 0) {  	w = 360 * (int)(Screen.width / 360);  	if (w > 360 * 4)  		w = 360 * 4;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w == 0) {  	w = 360 * (int)(Screen.width / 360);  	if (w > 360 * 4)  		w = 360 * 4;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w == 0) {  	w = 360 * (int)(Screen.width / 360);  	if (w > 360 * 4)  		w = 360 * 4;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w == 0) {  	w = 360 * (int)(Screen.width / 360);  	if (w > 360 * 4)  		w = 360 * 4;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: w = 360 * (int)(Screen.width / 360);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: w = 360 * (int)(Screen.width / 360);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w > 360 * 4)  	w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w > 360 * 4)  	w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w > 360 * 4)  	w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w > 360 * 4)  	w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: w = 360 * 4;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w < 360)  	w = 360;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: if (w < 360)  	w = 360;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: w = 360;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,setWidth,The following statement contains a magic number: mapheight = (int)(w / 2);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,centerAround,The following statement contains a magic number: lon_offset = 180 + lon - (mapwidth / mapscale) / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,centerAround,The following statement contains a magic number: lon_offset = 180 + lon - (mapwidth / mapscale) / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,centerAround,The following statement contains a magic number: lat_offset = 90 + lat - (mapheight / mapscale) / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,centerAround,The following statement contains a magic number: lat_offset = 90 + lat - (mapheight / mapscale) / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = (3.0f * lon / 2.0f / Math.PI) * Math.Sqrt (Math.PI * Math.PI / 3.0f - lat * lat);  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	if (lat < 0) {  		lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  	}  	else {  		lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  	}  	return Mathf.Rad2Deg * lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = (3.0f * lon / 2.0f / Math.PI) * Math.Sqrt (Math.PI * Math.PI / 3.0f - lat * lat);  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	if (lat < 0) {  		lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  	}  	else {  		lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  	}  	return Mathf.Rad2Deg * lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = (3.0f * lon / 2.0f / Math.PI) * Math.Sqrt (Math.PI * Math.PI / 3.0f - lat * lat);  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	if (lat < 0) {  		lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  	}  	else {  		lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  	}  	return Mathf.Rad2Deg * lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = (3.0f * lon / 2.0f / Math.PI) * Math.Sqrt (Math.PI * Math.PI / 3.0f - lat * lat);  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	if (lat < 0) {  		lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  	}  	else {  		lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  	}  	return Mathf.Rad2Deg * lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: if (lat < 0) {  	lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  }  else {  	lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: if (lat < 0) {  	lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  }  else {  	lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: if (lat < 0) {  	lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  }  else {  	lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: if (lat < 0) {  	lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  }  else {  	lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) - Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLongitude,The following statement contains a magic number: lon = 1.3 * Math.Cos (lat) * Math.Sin (lon) + Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: switch (projection) {  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	if (lat < 0) {  		lat = 1.3 * Math.Cos (lat) * Math.Cos (lon);  	}  	else {  		lat = -1.3 * Math.Cos (lat) * Math.Cos (lon);  	}  	return Mathf.Rad2Deg * lat;  default:  	return lat;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: switch (projection) {  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	if (lat < 0) {  		lat = 1.3 * Math.Cos (lat) * Math.Cos (lon);  	}  	else {  		lat = -1.3 * Math.Cos (lat) * Math.Cos (lon);  	}  	return Mathf.Rad2Deg * lat;  default:  	return lat;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: if (lat < 0) {  	lat = 1.3 * Math.Cos (lat) * Math.Cos (lon);  }  else {  	lat = -1.3 * Math.Cos (lat) * Math.Cos (lon);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: if (lat < 0) {  	lat = 1.3 * Math.Cos (lat) * Math.Cos (lon);  }  else {  	lat = -1.3 * Math.Cos (lat) * Math.Cos (lon);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lat = 1.3 * Math.Cos (lat) * Math.Cos (lon);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,projectLatitude,The following statement contains a magic number: lat = -1.3 * Math.Cos (lat) * Math.Cos (lon);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lat = 180 - lat;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon += 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lat = -180 - lat;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon += 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: switch (projection) {  case MapProjection.KavrayskiyVII:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	lon = lon / Math.Sqrt (Mathf.PI * Math.PI / 3.0f - lat * lat) * 2.0f * Math.PI / 3.0f;  	return Mathf.Rad2Deg * lon;  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lon = Math.Atan2 ((lon * Math.Sin (c))' (p * Math.Cos (lat0) * Math.Cos (c) - lat * Math.Sin (lat0) * Math.Sin (c)));  	lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  	if (lon <= -180)  		lon = -180;  	return lon;  default:  	return lon;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lon < 0) {  	lon += Math.PI / 2;  	lat0 = -Math.PI / 2;  }  else {  	lon -= Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lon < 0) {  	lon += Math.PI / 2;  	lat0 = -Math.PI / 2;  }  else {  	lon -= Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lon < 0) {  	lon += Math.PI / 2;  	lat0 = -Math.PI / 2;  }  else {  	lon -= Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon += Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lat0 = -Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon -= Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon /= 1.3;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lat /= 1.3;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon = (Mathf.Rad2Deg * lon + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lon <= -180)  	lon = -180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: if (lon <= -180)  	lon = -180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLongitude,The following statement contains a magic number: lon = -180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat > 90) {  	lat = 180 - lat;  	lon += 180;  }  else if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lat = 180 - lat;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon += 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lat < -90) {  	lat = -180 - lat;  	lon += 180;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lat = -180 - lat;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon += 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon = (lon + 3600 + 180) % 360 - 180;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lat = (lat + 1800 + 90) % 180 - 90;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: switch (projection) {  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lat = Math.Asin (Math.Cos (c) * Math.Sin (lat0) + (lat * Math.Sin (c) * Math.Cos (lat0)) / (p));  	return Mathf.Rad2Deg * lat;  default:  	return lat;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: switch (projection) {  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lat = Math.Asin (Math.Cos (c) * Math.Sin (lat0) + (lat * Math.Sin (c) * Math.Cos (lat0)) / (p));  	return Mathf.Rad2Deg * lat;  default:  	return lat;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: switch (projection) {  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lat = Math.Asin (Math.Cos (c) * Math.Sin (lat0) + (lat * Math.Sin (c) * Math.Cos (lat0)) / (p));  	return Mathf.Rad2Deg * lat;  default:  	return lat;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: switch (projection) {  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lat = Math.Asin (Math.Cos (c) * Math.Sin (lat0) + (lat * Math.Sin (c) * Math.Cos (lat0)) / (p));  	return Mathf.Rad2Deg * lat;  default:  	return lat;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: switch (projection) {  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lat = Math.Asin (Math.Cos (c) * Math.Sin (lat0) + (lat * Math.Sin (c) * Math.Cos (lat0)) / (p));  	return Mathf.Rad2Deg * lat;  default:  	return lat;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: switch (projection) {  case MapProjection.Polar:  	lon = Mathf.Deg2Rad * lon;  	lat = Mathf.Deg2Rad * lat;  	double lat0 = Math.PI / 2;  	if (lon < 0) {  		lon += Math.PI / 2;  		lat0 = -Math.PI / 2;  	}  	else {  		lon -= Math.PI / 2;  	}  	lon /= 1.3;  	lat /= 1.3;  	double p = Math.Sqrt (lon * lon + lat * lat);  	double c = Math.Asin (p);  	lat = Math.Asin (Math.Cos (c) * Math.Sin (lat0) + (lat * Math.Sin (c) * Math.Cos (lat0)) / (p));  	return Mathf.Rad2Deg * lat;  default:  	return lat;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lon < 0) {  	lon += Math.PI / 2;  	lat0 = -Math.PI / 2;  }  else {  	lon -= Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lon < 0) {  	lon += Math.PI / 2;  	lat0 = -Math.PI / 2;  }  else {  	lon -= Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: if (lon < 0) {  	lon += Math.PI / 2;  	lat0 = -Math.PI / 2;  }  else {  	lon -= Math.PI / 2;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon += Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lat0 = -Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon -= Math.PI / 2;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lon /= 1.3;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,unprojectLatitude,The following statement contains a magic number: lat /= 1.3;  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,exportPNG,The following statement contains a magic number: if (mapmode == 0)  	mode = "elevation";  else if (mapmode == 1)  	mode = "slope";  else if (mapmode == 2)  	mode = "biome";  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,exportPNG,The following statement contains a magic number: if (mapmode == 1)  	mode = "slope";  else if (mapmode == 2)  	mode = "biome";  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,exportPNG,The following statement contains a magic number: if (mapmode == 2)  	mode = "biome";  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,exportPNG,The following statement contains a magic number: ScreenMessages.PostScreenMessage ("Map saved: " + filename' 5' ScreenMessageStyle.UPPER_CENTER);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: for (int i = 0; i < map.width; i++) {  	int scheme = 0;  	double lat = (mapstep * 1.0f / mapscale) - 90f + lat_offset;  	double lon = (i * 1.0f / mapscale) - 180f + lon_offset;  	double la = lat' lo = lon;  	lat = unprojectLatitude (lo' la);  	lon = unprojectLongitude (lo' la);  	pix [i] = Color.grey;  	if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  		pix [i] = Color.clear;  		continue;  	}  	if (mapmode == 0) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			// high resolution gets a coloured pixel for the actual position  			val = (float)data.getElevation (lon' lat);  			pix [i] = heightToColor (val' scheme);  		}  		else {  			// basic altimetry gets forced greyscale with lower resolution  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  			pix [i] = heightToColor (val' 1);  		}  		/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  	}  	else if (mapmode == 1) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  			continue;  		if (body.pqsController == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		float val;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  			val = (float)data.getElevation (lon' lat);  		}  		else {  			val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		}  		if (mapstep == 0) {  			pix [i] = Color.grey;  		}  		else {  			// This doesn't actually calculate the slope per se' but it's faster  			// than asking for yet more elevation data. Please don't use this  			// code to operate nuclear power plants or rockets.  			double v1 = mapline [i];  			if (i > 0)  				v1 = Math.Max (v1' mapline [i - 1]);  			if (i < mapline.Length - 1)  				v1 = Math.Max (v1' mapline [i + 1]);  			float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  			if (SCANcontroller.controller.colours == 1) {  				pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  			}  			else {  				if (v < 1) {  					pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  				}  				else {  					pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  				}  			}  		}  		mapline [i] = val;  	}  	else if (mapmode == 2) {  		if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  			continue;  		if (body.BiomeMap == null || body.BiomeMap.Map == null) {  			pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  			continue;  		}  		/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  		Color biome = Color.grey;  		if (SCANcontroller.controller.colours == 1) {  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.black' Color.white' (float)bio);  			}  		}  		else {  			Color elevation = Color.gray;  			if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  				float val = (float)data.getElevation (lon' lat);  				elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  			}  			Color bio1 = XKCDColors.CamoGreen;  			Color bio2 = XKCDColors.Marigold;  			if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  				//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  				biome = Color.white;  			}  			else {  				biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  			}  		}  		pix [i] = biome;  		mapline [i] = bio;  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  	pix [i] = Color.clear;  	continue;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  	pix [i] = Color.clear;  	continue;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  	pix [i] = Color.clear;  	continue;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (double.IsNaN (lat) || double.IsNaN (lon) || lat < -90 || lat > 90 || lon < -180 || lon > 180) {  	pix [i] = Color.clear;  	continue;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 0) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		// high resolution gets a coloured pixel for the actual position  		val = (float)data.getElevation (lon' lat);  		pix [i] = heightToColor (val' scheme);  	}  	else {  		// basic altimetry gets forced greyscale with lower resolution  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  		pix [i] = heightToColor (val' 1);  	}  	/* draw height lines - works' but mostly useless... 				int step = (int)(val / 1000); 				int step_h = step' step_v = step; 				if(i > 0) step_h = (int)(bigline[i - 1] / 1000); 				if(bigstep > 0) step_v = (int)(bigline[i] / 1000); 				if(step != step_h || step != step_v) { 					pix[i] = Color.white; 				} 				*/mapline [i] = val;  }  else if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  	// high resolution gets a coloured pixel for the actual position  	val = (float)data.getElevation (lon' lat);  	pix [i] = heightToColor (val' scheme);  }  else {  	// basic altimetry gets forced greyscale with lower resolution  	val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	pix [i] = heightToColor (val' 1);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  	// high resolution gets a coloured pixel for the actual position  	val = (float)data.getElevation (lon' lat);  	pix [i] = heightToColor (val' scheme);  }  else {  	// basic altimetry gets forced greyscale with lower resolution  	val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	pix [i] = heightToColor (val' 1);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  	// high resolution gets a coloured pixel for the actual position  	val = (float)data.getElevation (lon' lat);  	pix [i] = heightToColor (val' scheme);  }  else {  	// basic altimetry gets forced greyscale with lower resolution  	val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	pix [i] = heightToColor (val' 1);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  	// high resolution gets a coloured pixel for the actual position  	val = (float)data.getElevation (lon' lat);  	pix [i] = heightToColor (val' scheme);  }  else {  	// basic altimetry gets forced greyscale with lower resolution  	val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	pix [i] = heightToColor (val' 1);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 1) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry))  		continue;  	if (body.pqsController == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	float val;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  		val = (float)data.getElevation (lon' lat);  	}  	else {  		val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  	}  	if (mapstep == 0) {  		pix [i] = Color.grey;  	}  	else {  		// This doesn't actually calculate the slope per se' but it's faster  		// than asking for yet more elevation data. Please don't use this  		// code to operate nuclear power plants or rockets.  		double v1 = mapline [i];  		if (i > 0)  			v1 = Math.Max (v1' mapline [i - 1]);  		if (i < mapline.Length - 1)  			v1 = Math.Max (v1' mapline [i + 1]);  		float v = Mathf.Clamp ((float)Math.Abs (val - v1) / 1000f' 0' 2f);  		if (SCANcontroller.controller.colours == 1) {  			pix [i] = Color.Lerp (Color.black' Color.white' v / 2f);  		}  		else {  			if (v < 1) {  				pix [i] = Color.Lerp (XKCDColors.PukeGreen' XKCDColors.Lemon' v);  			}  			else {  				pix [i] = Color.Lerp (XKCDColors.Lemon' XKCDColors.OrangeRed' v - 1);  			}  		}  	}  	mapline [i] = val;  }  else if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  	val = (float)data.getElevation (lon' lat);  }  else {  	val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  	val = (float)data.getElevation (lon' lat);  }  else {  	val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  	val = (float)data.getElevation (lon' lat);  }  else {  	val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.AltimetryHiRes)) {  	val = (float)data.getElevation (lon' lat);  }  else {  	val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: val = (float)data.getElevation (((int)(lon * 5)) / 5' ((int)(lat * 5)) / 5);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapmode == 2) {  	if (!data.isCovered (lon' lat' SCANdata.SCANtype.Biome))  		continue;  	if (body.BiomeMap == null || body.BiomeMap.Map == null) {  		pix [i] = Color.Lerp (Color.black' Color.white' UnityEngine.Random.value);  		continue;  	}  	/* // this just basically stretches the actual biome map to fit... it looks horrible 				float u = ((lon + 360 + 180 + 90)) % 360; 				float v = ((lat + 180 + 90)) % 180; 				if(u < 0 || v < 0 || u >= 360 || v >= 180) continue; 				u /= 360f; v /= 180f; 				pix[i] = body.BiomeMap.Map.GetPixelBilinear(u' v); 				*/double bio = data.getBiomeIndexFraction (lon' lat);  	Color biome = Color.grey;  	if (SCANcontroller.controller.colours == 1) {  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.black' Color.white' (float)bio);  		}  	}  	else {  		Color elevation = Color.gray;  		if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  			float val = (float)data.getElevation (lon' lat);  			elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  		}  		Color bio1 = XKCDColors.CamoGreen;  		Color bio2 = XKCDColors.Marigold;  		if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  			//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  			biome = Color.white;  		}  		else {  			biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  		}  	}  	pix [i] = biome;  	mapline [i] = bio;  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (SCANcontroller.controller.colours == 1) {  	if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  		biome = Color.white;  	}  	else {  		biome = Color.Lerp (Color.black' Color.white' (float)bio);  	}  }  else {  	Color elevation = Color.gray;  	if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  		float val = (float)data.getElevation (lon' lat);  		elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  	}  	Color bio1 = XKCDColors.CamoGreen;  	Color bio2 = XKCDColors.Marigold;  	if ((i > 0 && mapline [i - 1] != bio) || (mapstep > 0 && mapline [i] != bio)) {  		//biome = Color.Lerp(XKCDColors.Puce' elevation' 0.5f);  		biome = Color.white;  	}  	else {  		biome = Color.Lerp (Color.Lerp (bio1' bio2' (float)bio)' elevation' 0.5f);  	}  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (data.isCovered (lon' lat' SCANdata.SCANtype.Altimetry)) {  	float val = (float)data.getElevation (lon' lat);  	elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  }  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: elevation = Color.Lerp (Color.black' Color.white' Mathf.Clamp (val + 1500f' 0' 9000) / 9000f);  
Magic Number,SCANsat,SCANmap,C:\repos\thatfool_SCAN\SCANmap.cs,getPartialMap,The following statement contains a magic number: if (mapstep % 10 == 0 || mapstep >= map.height)  	map.Apply ();  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,setup,The following statement contains a magic number: if (edgeDetectShader == null) {  	// simple colour based edge detection that comes with Unity Pro  	edgeDetectShader = Shader.Find ("Hidden/Edge Detect X");  	edgeDetectMaterial = new Material (edgeDetectShader);  	edgeDetectMaterial.SetFloat ("_Threshold"' 0.05f);  	// greyscale shader that comes with Unity Pro  	grayscaleShader = Shader.Find ("Hidden/Grayscale Effect");  	grayscaleMaterial = new Material (grayscaleShader);  	Texture2D t = new Texture2D (256' 1' TextureFormat.RGB24' false);  	// ramp texture to render everything in dark shades of Amber'  	// except originally dark lines' which become bright Amber  	for (int i = 0; i < 256; ++i)  		t.SetPixel (i' 0' Color.Lerp (Color.black' XKCDColors.Amber' i / 1024f));  	for (int i = 0; i < 10; ++i)  		t.SetPixel (i' 0' XKCDColors.Amber);  	t.Apply ();  	grayscaleMaterial.SetTexture ("_RampTex"' t);  }  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,setup,The following statement contains a magic number: if (edgeDetectShader == null) {  	// simple colour based edge detection that comes with Unity Pro  	edgeDetectShader = Shader.Find ("Hidden/Edge Detect X");  	edgeDetectMaterial = new Material (edgeDetectShader);  	edgeDetectMaterial.SetFloat ("_Threshold"' 0.05f);  	// greyscale shader that comes with Unity Pro  	grayscaleShader = Shader.Find ("Hidden/Grayscale Effect");  	grayscaleMaterial = new Material (grayscaleShader);  	Texture2D t = new Texture2D (256' 1' TextureFormat.RGB24' false);  	// ramp texture to render everything in dark shades of Amber'  	// except originally dark lines' which become bright Amber  	for (int i = 0; i < 256; ++i)  		t.SetPixel (i' 0' Color.Lerp (Color.black' XKCDColors.Amber' i / 1024f));  	for (int i = 0; i < 10; ++i)  		t.SetPixel (i' 0' XKCDColors.Amber);  	t.Apply ();  	grayscaleMaterial.SetTexture ("_RampTex"' t);  }  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,setup,The following statement contains a magic number: if (edgeDetectShader == null) {  	// simple colour based edge detection that comes with Unity Pro  	edgeDetectShader = Shader.Find ("Hidden/Edge Detect X");  	edgeDetectMaterial = new Material (edgeDetectShader);  	edgeDetectMaterial.SetFloat ("_Threshold"' 0.05f);  	// greyscale shader that comes with Unity Pro  	grayscaleShader = Shader.Find ("Hidden/Grayscale Effect");  	grayscaleMaterial = new Material (grayscaleShader);  	Texture2D t = new Texture2D (256' 1' TextureFormat.RGB24' false);  	// ramp texture to render everything in dark shades of Amber'  	// except originally dark lines' which become bright Amber  	for (int i = 0; i < 256; ++i)  		t.SetPixel (i' 0' Color.Lerp (Color.black' XKCDColors.Amber' i / 1024f));  	for (int i = 0; i < 10; ++i)  		t.SetPixel (i' 0' XKCDColors.Amber);  	t.Apply ();  	grayscaleMaterial.SetTexture ("_RampTex"' t);  }  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,setup,The following statement contains a magic number: for (int i = 0; i < 256; ++i)  	t.SetPixel (i' 0' Color.Lerp (Color.black' XKCDColors.Amber' i / 1024f));  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,setup,The following statement contains a magic number: for (int i = 0; i < 10; ++i)  	t.SetPixel (i' 0' XKCDColors.Amber);  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,updateCamera,The following statement contains a magic number: if (updateFrame > Time.frameCount - 5)  	return;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,updateCamera,The following statement contains a magic number: if (rt == null || rt.width != width || rt.height != height) {  	rt = new RenderTexture (width' height' 32' RenderTextureFormat.RGB565);  	rt.Create ();  }  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,updateCamera,The following statement contains a magic number: rt = new RenderTexture (width' height' 32' RenderTextureFormat.RGB565);  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,updateCamera,The following statement contains a magic number: if (cam == null) {  	cam = camgo.AddComponent<Camera> ();  	cam.enabled = false;  	// so we can render on demand  	cam.targetTexture = rt;  	cam.aspect = width * 1f / height;  	cam.fieldOfView = 90;  }  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,updateCamera,The following statement contains a magic number: cam.fieldOfView = 90;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,updateCamera,The following statement contains a magic number: pos_cam = pos_target - dir * dist / 2 + target_up * dist / 3;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,updateCamera,The following statement contains a magic number: pos_cam = pos_target - dir * dist / 2 + target_up * dist / 3;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,updateCamera,The following statement contains a magic number: cam.farClipPlane = dist * 3;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,The following statement contains a magic number: if (Math.Round (Time.realtimeSinceStartup) % 2 == 0)  	info += "_";  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,The following statement contains a magic number: r.x = where.x + 4;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,The following statement contains a magic number: r.y = where.y + 8;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,The following statement contains a magic number: r.x = where.x + 4;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,The following statement contains a magic number: r.y = where.y + where.height - 60;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,The following statement contains a magic number: if (sname != null) {  	GUI.Label (r' left (sname' chars)' style);  	r.y += 30;  	GUI.Label (r' left (distanceString ((FlightGlobals.ActiveVessel.transform.position - lookvec).magnitude)' chars)' style);  }  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,drawOverlay,The following statement contains a magic number: r.y += 30;  
Magic Number,SCANsat,RemoteView,C:\repos\thatfool_SCAN\RemoteView.cs,distanceString,The following statement contains a magic number: if (dist < 5000)  	return dist.ToString ("N1") + "m";  
