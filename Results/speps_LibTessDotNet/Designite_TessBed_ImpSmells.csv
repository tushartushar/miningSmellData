Implementation smell,Namespace,Class,File,Method,Description
Long Method,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The method has 114 lines of code.
Long Method,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The method has 192 lines of code.
Complex Method,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,RefreshAsset,Cyclomatic complexity of the method is 8
Complex Method,TessBed,Program,C:\repos\speps_LibTessDotNet\TessBed\Program.cs,Main,Cyclomatic complexity of the method is 8
Long Statement,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,WorkerCompleted,The length of the statement  "            data.Columns.Add(new DataGridViewTextBoxColumn { HeaderText = "Asset"' AutoSizeMode = DataGridViewAutoSizeColumnMode.AllCells }); " is 129.
Long Statement,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,WorkerCompleted,The length of the statement  "                data.Columns.Add(new DataGridViewTextBoxColumn { HeaderText = _libs[i].Name' AutoSizeMode = DataGridViewAutoSizeColumnMode.AllCells }); " is 135.
Long Statement,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,WorkerCompleted,The length of the statement  "                    data.Columns.Add(new DataGridViewTextBoxColumn { HeaderText = ""' AutoSizeMode = DataGridViewAutoSizeColumnMode.AllCells }); " is 124.
Long Statement,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(BenchForm)); " is 129.
Long Statement,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The length of the statement  "                            reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f); " is 158.
Long Statement,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The length of the statement  "                            brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length); " is 135.
Long Statement,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The length of the statement  "                (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]' " is 134.
Long Statement,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The length of the statement  "                (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]' " is 134.
Long Statement,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The length of the statement  "                (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]' " is 134.
Long Statement,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The length of the statement  "                (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3] " is 133.
Long Statement,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,RefreshAsset,The length of the statement  "            statusMain.Text = string.Format("{0:F3} ms - {1} polygons (of {2} vertices) {3}"' _sw.Elapsed.TotalMilliseconds' _tess.ElementCount' _polySize' _polySize == 3 ? "... triangles" : ""); " is 183.
Long Statement,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The length of the statement  "            System.ComponentModel.ComponentResourceManager resources = new System.ComponentModel.ComponentResourceManager(typeof(MainForm)); " is 128.
Long Statement,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The length of the statement  "            this.toolStripButtonShowWinding.Image = ((System.Drawing.Image)(resources.GetObject("toolStripButtonShowWinding.Image"))); " is 122.
Long Statement,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tessellate_WithAsset_ReturnsExpectedTriangulation,The length of the statement  "            var testData = ParseTestData(data.Winding' data.ElementSize' Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceName)); " is 134.
Complex Conditional,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The conditional expression  "rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b)"  is complex.
Complex Conditional,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The conditional expression  "rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a)"  is complex.
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,Worker,The following statement contains a magic number: for (int i = 0; i < names.Length; i++)              {                  var asset = _data.GetAsset(names[i]);                  var testResult = new TestResult();                  testResult.Name = names[i];                  foreach (var lib in _libs)                  {                      var libResult = lib.Triangulate(asset.Polygons' _loops);                      testResult.Libs.Add(libResult);                  }                  results.Add(testResult);                  _bgWorker.ReportProgress(i * 100 / names.Length);              }
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,Worker,The following statement contains a magic number: _bgWorker.ReportProgress(100);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStrip1.Size = new System.Drawing.Size(428' 25);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStrip1.Size = new System.Drawing.Size(428' 25);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripLabel1.Size = new System.Drawing.Size(39' 22);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripLabel1.Size = new System.Drawing.Size(39' 22);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripTextLoops.Size = new System.Drawing.Size(40' 25);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripTextLoops.Size = new System.Drawing.Size(40' 25);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(6' 25);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(6' 25);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonStart.Size = new System.Drawing.Size(35' 22);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonStart.Size = new System.Drawing.Size(35' 22);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Location = new System.Drawing.Point(0' 545);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(428' 22);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip1.Size = new System.Drawing.Size(428' 22);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripProgressBar.Size = new System.Drawing.Size(200' 16);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripProgressBar.Size = new System.Drawing.Size(200' 16);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripStatus.Size = new System.Drawing.Size(0' 17);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.data.Location = new System.Drawing.Point(0' 25);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.data.Size = new System.Drawing.Size(428' 520);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.data.Size = new System.Drawing.Size(428' 520);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.data.TabIndex = 2;
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(428' 567);
Magic Number,TessBed,BenchForm,C:\repos\speps_LibTessDotNet\TessBed\BenchForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(428' 567);
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: g.TranslateTransform(ClientSize.Width / 2' ClientSize.Height / 2);
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: g.TranslateTransform(ClientSize.Width / 2' ClientSize.Height / 2);
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: float xmid = (xmin + xmax) / 2;
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: float ymid = (ymin + ymax) / 2;
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,Canvas,C:\repos\speps_LibTessDotNet\TessBed\Canvas.cs,OnPaint,The following statement contains a magic number: using (var penContour = new Pen(Color.FromArgb(128' 0' 0' 128)' 2.0f))              using (var penWinding = new Pen(Color.FromArgb(255' 0' 0' 128)' 6.0f))              using (var brushPoint = new SolidBrush(Color.FromArgb(255' 0' 0' 0)))              using (var penOutput = new Pen(Color.FromArgb(32' 0' 0' 0)' 1.0f))              using (var penPolys = new Pen(Color.FromArgb(64' 0' 0' 0)' 1.0f))              using (var penZeroArea = new Pen(Color.FromArgb(255' 255' 0' 0)' 1.0f))              using (var brushPolys = new SolidBrush(Color.FromArgb(64' 255' 207' 130)))              {                  penWinding.EndCap = LineCap.ArrowAnchor;                  if (ShowInput)                  {                      foreach (var polygon in Input)                      {                          bool reverse = false;                          if (polygon.Orientation != ContourOrientation.Original)                          {                              float area = SignedArea(polygon);                              reverse = (polygon.Orientation == ContourOrientation.Clockwise && area < 0.0f) || (polygon.Orientation == ContourOrientation.CounterClockwise && area > 0.0f);                          }                            for (int i = 0; i < polygon.Count; i++)                          {                              int index = reverse ? polygon.Count - 1 - i : i;                              var p0 = f(polygon[(index + (reverse ? 1 : 0)) % polygon.Count]);                              var p1 = f(polygon[(index + (reverse ? 0 : 1)) % polygon.Count]);                                g.DrawLine(ShowWinding ? penWinding : penContour' p0' p1);                              g.FillEllipse(brushPoint' p0.X - 2.0f' p0.Y - 2.0f' 4.0f' 4.0f);                          }                      }                  }                    if (Output == null)                      return;                    foreach (var polygon in Output)                  {                      var pts = new PointF[polygon.Count];                      for (int i = 0; i < polygon.Count; i++)                      {                          pts[i] = f(polygon[i]);                      }                        if (Input.HasColors)                      {                          var colors = new Color[pts.Length];                          int[] mean = new int[4];                          for (int i = 0; i < pts.Length; i++)                          {                              colors[i] = polygon[i].Color;                              mean[0] += colors[i].R;                              mean[1] += colors[i].G;                              mean[2] += colors[i].B;                              mean[3] += colors[i].A;                          }                            using (var brush = new PathGradientBrush(pts))                          using (var pen = new Pen(brush' 20.0f))                          {                              brush.SurroundColors = colors;                              brush.CenterColor = Color.FromArgb(mean[3] / colors.Length' mean[0] / colors.Length' mean[1] / colors.Length' mean[2] / colors.Length);                                g.FillPolygon(brush' pts);                          }                      }                      else                      {                          g.FillPolygon(brushPolys' pts);                      }                        float area = SignedArea(polygon);                      for (int i = 0; i < pts.Length; i++)                      {                          var p0 = pts[i];                          var p1 = pts[(i + 1) % polygon.Count];                            g.DrawLine(ShowInput ? penOutput : penPolys' p0' p1);                          if (Math.Abs(area) < float.Epsilon)                          {                              g.DrawLine(penZeroArea' p0' p1);                          }                      }                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,DataLoader,C:\repos\speps_LibTessDotNet\TessBed\DataLoader.cs,LoadDat,The following statement contains a magic number: using (var stream = new StreamReader(resourceStream))              {                  while ((line = stream.ReadLine()) != null)                  {                      ++lineNum;                      line = line.Trim();                      if (string.IsNullOrEmpty(line))                      {                          if (points.Count > 0)                          {                              var p = new Polygon(points) { Orientation = currentOrientation };                              currentOrientation = ContourOrientation.Original;                              polys.Add(p);                              points.Clear();                          }                          continue;                      }                      if (line.StartsWith("//") ||                          line.StartsWith("#") ||                          line.StartsWith(";"))                      {                          continue;                      }                      if (line.StartsWith("force"' true' CultureInfo.InvariantCulture))                      {                          var force = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (force.Length == 2)                          {                              if (string.Compare(force[1]' "cw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.Clockwise;                              }                              if (string.Compare(force[1]' "ccw"' true) == 0)                              {                                  currentOrientation = ContourOrientation.CounterClockwise;                              }                          }                      }                      else if (line.StartsWith("color"' true' CultureInfo.InvariantCulture))                      {                          var rgba = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          int r = 255' g = 255' b = 255' a = 255;                          if (rgba != null)                          {                              if (rgba.Length == 4 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b))                              {                                  currentColor = Color.FromArgb(r' g' b);                                  polys.HasColors = true;                              }                              else if (rgba.Length == 5 &&                                  int.TryParse(rgba[1]' NumberStyles.Integer' CultureInfo.InvariantCulture' out r) &&                                  int.TryParse(rgba[2]' NumberStyles.Integer' CultureInfo.InvariantCulture' out g) &&                                  int.TryParse(rgba[3]' NumberStyles.Integer' CultureInfo.InvariantCulture' out b) &&                                  int.TryParse(rgba[4]' NumberStyles.Integer' CultureInfo.InvariantCulture' out a))                              {                                  currentColor = Color.FromArgb(a' r' g' b);                                  polys.HasColors = true;                              }                          }                      }                      else                      {                          float x = 0' y = 0' z = 0;                          var xyz = line.Split(new[] { ' '' '''' '\t' }' StringSplitOptions.RemoveEmptyEntries);                          if (xyz != null)                          {                              if (xyz.Length >= 1) float.TryParse(xyz[0]' NumberStyles.Float' CultureInfo.InvariantCulture' out x);                              if (xyz.Length >= 2) float.TryParse(xyz[1]' NumberStyles.Float' CultureInfo.InvariantCulture' out y);                              if (xyz.Length >= 3) float.TryParse(xyz[2]' NumberStyles.Float' CultureInfo.InvariantCulture' out z);                              points.Add(new PolygonPoint { X = x' Y = y' Z = z' Color = currentColor });                          }                          else                          {                              throw new InvalidDataException("Invalid input data");                          }                      }                  }                    if (points.Count > 0)                  {                      Polygon p = new Polygon(points) { Orientation = currentOrientation };                      polys.Add(p);                  }              }
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,MainForm,The following statement contains a magic number: SetPolySize(3);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,PolySizeEvent,The following statement contains a magic number: if (Int32.TryParse(toolStripPolySize.Text' out result))              {                  _polySize = result;                  if (_polySize < 3)                  {                      _polySize = 3;                      toolStripPolySize.Text = _polySize.ToString();                  }              }
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,PolySizeEvent,The following statement contains a magic number: if (Int32.TryParse(toolStripPolySize.Text' out result))              {                  _polySize = result;                  if (_polySize < 3)                  {                      _polySize = 3;                      toolStripPolySize.Text = _polySize.ToString();                  }              }
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,SetPolySize,The following statement contains a magic number: if (polySize < 3)              {                  polySize = 3;              }
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,SetPolySize,The following statement contains a magic number: if (polySize < 3)              {                  polySize = 3;              }
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,Project,The following statement contains a magic number: sUnit[(i + 1) % 3] = _tess.SUnitX;
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,Project,The following statement contains a magic number: sUnit[(i + 2) % 3] = _tess.SUnitY;
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,Project,The following statement contains a magic number: sUnit[(i + 2) % 3] = _tess.SUnitY;
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,Project,The following statement contains a magic number: tUnit[(i + 1) % 3] = norm[i] > 0.0f ? -_tess.SUnitY : _tess.SUnitY;
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,Project,The following statement contains a magic number: tUnit[(i + 2) % 3] = norm[i] > 0.0f ? _tess.SUnitX : -_tess.SUnitX;
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,Project,The following statement contains a magic number: tUnit[(i + 2) % 3] = norm[i] > 0.0f ? _tess.SUnitX : -_tess.SUnitX;
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var colors = new Color[] { (Color)data[0]' (Color)data[1]' (Color)data[2]' (Color)data[3] };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var colors = new Color[] { (Color)data[0]' (Color)data[1]' (Color)data[2]' (Color)data[3] };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: var rgba = new float[] {                  (float)colors[0].R * weights[0] + (float)colors[1].R * weights[1] + (float)colors[2].R * weights[2] + (float)colors[3].R * weights[3]'                  (float)colors[0].G * weights[0] + (float)colors[1].G * weights[1] + (float)colors[2].G * weights[2] + (float)colors[3].G * weights[3]'                  (float)colors[0].B * weights[0] + (float)colors[1].B * weights[1] + (float)colors[2].B * weights[2] + (float)colors[3].B * weights[3]'                  (float)colors[0].A * weights[0] + (float)colors[1].A * weights[1] + (float)colors[2].A * weights[2] + (float)colors[3].A * weights[3]              };
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: return Color.FromArgb((int)rgba[3]' (int)rgba[0]' (int)rgba[1]' (int)rgba[2]);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,VertexCombine,The following statement contains a magic number: return Color.FromArgb((int)rgba[3]' (int)rgba[0]' (int)rgba[1]' (int)rgba[2]);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,RefreshAsset,The following statement contains a magic number: statusMain.Text = string.Format("{0:F3} ms - {1} polygons (of {2} vertices) {3}"' _sw.Elapsed.TotalMilliseconds' _tess.ElementCount' _polySize' _polySize == 3 ? "... triangles" : "");
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip.ImageScalingSize = new System.Drawing.Size(32' 32);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip.ImageScalingSize = new System.Drawing.Size(32' 32);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip.Location = new System.Drawing.Point(0' 1059);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip.Padding = new System.Windows.Forms.Padding(2' 0' 28' 0);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip.Padding = new System.Windows.Forms.Padding(2' 0' 28' 0);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip.Size = new System.Drawing.Size(1601' 22);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusStrip.Size = new System.Drawing.Size(1601' 22);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.statusMain.Size = new System.Drawing.Size(0' 17);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStrip.ImageScalingSize = new System.Drawing.Size(32' 32);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStrip.ImageScalingSize = new System.Drawing.Size(32' 32);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStrip.Padding = new System.Windows.Forms.Padding(0' 0' 2' 0);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStrip.Size = new System.Drawing.Size(1601' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStrip.Size = new System.Drawing.Size(1601' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripLabelAsset.Size = new System.Drawing.Size(71' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripLabelAsset.Size = new System.Drawing.Size(71' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripAssets.Size = new System.Drawing.Size(238' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripAssets.Size = new System.Drawing.Size(238' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(6' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator1.Size = new System.Drawing.Size(6' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripLabelWinding.Size = new System.Drawing.Size(105' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripLabelWinding.Size = new System.Drawing.Size(105' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripWinding.Size = new System.Drawing.Size(238' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripWinding.Size = new System.Drawing.Size(238' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator2.Size = new System.Drawing.Size(6' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator2.Size = new System.Drawing.Size(6' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripLabelPolySize.Size = new System.Drawing.Size(97' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripLabelPolySize.Size = new System.Drawing.Size(97' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripPolySize.Size = new System.Drawing.Size(76' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripPolySize.Size = new System.Drawing.Size(76' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator3.Size = new System.Drawing.Size(6' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripSeparator3.Size = new System.Drawing.Size(6' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonShowInput.Size = new System.Drawing.Size(140' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonShowInput.Size = new System.Drawing.Size(140' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonShowWinding.Size = new System.Drawing.Size(169' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonShowWinding.Size = new System.Drawing.Size(169' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonNoEmpty.Size = new System.Drawing.Size(126' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonNoEmpty.Size = new System.Drawing.Size(126' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonBench.Size = new System.Drawing.Size(148' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonBench.Size = new System.Drawing.Size(148' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonOpen.Size = new System.Drawing.Size(78' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.toolStripButtonOpen.Size = new System.Drawing.Size(78' 37);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.panel.Location = new System.Drawing.Point(0' 40);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.panel.Margin = new System.Windows.Forms.Padding(6' 6' 6' 6);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.panel.Margin = new System.Windows.Forms.Padding(6' 6' 6' 6);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.panel.Margin = new System.Windows.Forms.Padding(6' 6' 6' 6);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.panel.Margin = new System.Windows.Forms.Padding(6' 6' 6' 6);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.panel.Size = new System.Drawing.Size(1601' 1019);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.panel.Size = new System.Drawing.Size(1601' 1019);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.panel.TabIndex = 2;
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1601' 1081);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(1601' 1081);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.Margin = new System.Windows.Forms.Padding(6' 6' 6' 6);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.Margin = new System.Windows.Forms.Padding(6' 6' 6' 6);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.Margin = new System.Windows.Forms.Padding(6' 6' 6' 6);
Magic Number,TessBed,MainForm,C:\repos\speps_LibTessDotNet\TessBed\MainForm.cs,InitializeComponent,The following statement contains a magic number: this.Margin = new System.Windows.Forms.Padding(6' 6' 6' 6);
Magic Number,TessBed,PolyConvert,C:\repos\speps_LibTessDotNet\TessBed\PolyConvert.cs,FromP2T,The following statement contains a magic number: foreach (var poly in pset.Polygons)              {                  foreach (var tri in poly.Triangles)                  {                      var rtri = new Polygon();                      rtri.Add(new PolygonPoint { X = tri.Points[0].Xf' Y = tri.Points[0].Yf });                      rtri.Add(new PolygonPoint { X = tri.Points[1].Xf' Y = tri.Points[1].Yf });                      rtri.Add(new PolygonPoint { X = tri.Points[2].Xf' Y = tri.Points[2].Yf });                      result.Add(rtri);                  }              }
Magic Number,TessBed,PolyConvert,C:\repos\speps_LibTessDotNet\TessBed\PolyConvert.cs,FromP2T,The following statement contains a magic number: foreach (var poly in pset.Polygons)              {                  foreach (var tri in poly.Triangles)                  {                      var rtri = new Polygon();                      rtri.Add(new PolygonPoint { X = tri.Points[0].Xf' Y = tri.Points[0].Yf });                      rtri.Add(new PolygonPoint { X = tri.Points[1].Xf' Y = tri.Points[1].Yf });                      rtri.Add(new PolygonPoint { X = tri.Points[2].Xf' Y = tri.Points[2].Yf });                      result.Add(rtri);                  }              }
Magic Number,TessBed,PolyConvert,C:\repos\speps_LibTessDotNet\TessBed\PolyConvert.cs,FromTess,The following statement contains a magic number: for (int i = 0; i < tess.ElementCount; i++)              {                  var poly = new Polygon();                  for (int j = 0; j < 3; j++)                  {                      int index = tess.Elements[i * 3 + j];                      if (index == -1)                          continue;                      var v = new PolygonPoint                      {                          X = tess.Vertices[index].Position.X'                          Y = tess.Vertices[index].Position.Y                      };                      poly.Add(v);                  }                  output.Add(poly);              }
Magic Number,TessBed,PolyConvert,C:\repos\speps_LibTessDotNet\TessBed\PolyConvert.cs,FromTess,The following statement contains a magic number: for (int i = 0; i < tess.ElementCount; i++)              {                  var poly = new Polygon();                  for (int j = 0; j < 3; j++)                  {                      int index = tess.Elements[i * 3 + j];                      if (index == -1)                          continue;                      var v = new PolygonPoint                      {                          X = tess.Vertices[index].Position.X'                          Y = tess.Vertices[index].Position.Y                      };                      poly.Add(v);                  }                  output.Add(poly);              }
Magic Number,TessBed,Program,C:\repos\speps_LibTessDotNet\TessBed\Program.cs,Main,The following statement contains a magic number: if (args.Length >= 1)              {                  if (string.Equals(args[0]' "gentestdat"' StringComparison.OrdinalIgnoreCase))                  {                      UnitTests.GenerateTestData();                  }                  if (args.Length == 2 && string.Equals(args[0]' "profile"' StringComparison.OrdinalIgnoreCase))                  {                      int count = 0;                      if (!int.TryParse(args[1]' out count))                      {                          return;                      }                      var stopwatch = new Stopwatch();                      var loader = new DataLoader();                      for (int i = 0; i < count; i++)                      {                          foreach (var name in loader.AssetNames)                          {                              var pset = loader.GetAsset(name).Polygons;                                foreach (WindingRule winding in Enum.GetValues(typeof(WindingRule)))                              {                                  var tess = new Tess();                                  PolyConvert.ToTess(pset' tess);                                  stopwatch.Start();                                  tess.Tessellate(winding' ElementType.Polygons' 3);                                  stopwatch.Stop();                              }                          }                      }                      Console.WriteLine("{0:F3}ms"' stopwatch.Elapsed.TotalMilliseconds);                  }                  return;              }
Magic Number,TessBed,Program,C:\repos\speps_LibTessDotNet\TessBed\Program.cs,Main,The following statement contains a magic number: if (args.Length >= 1)              {                  if (string.Equals(args[0]' "gentestdat"' StringComparison.OrdinalIgnoreCase))                  {                      UnitTests.GenerateTestData();                  }                  if (args.Length == 2 && string.Equals(args[0]' "profile"' StringComparison.OrdinalIgnoreCase))                  {                      int count = 0;                      if (!int.TryParse(args[1]' out count))                      {                          return;                      }                      var stopwatch = new Stopwatch();                      var loader = new DataLoader();                      for (int i = 0; i < count; i++)                      {                          foreach (var name in loader.AssetNames)                          {                              var pset = loader.GetAsset(name).Polygons;                                foreach (WindingRule winding in Enum.GetValues(typeof(WindingRule)))                              {                                  var tess = new Tess();                                  PolyConvert.ToTess(pset' tess);                                  stopwatch.Start();                                  tess.Tessellate(winding' ElementType.Polygons' 3);                                  stopwatch.Stop();                              }                          }                      }                      Console.WriteLine("{0:F3}ms"' stopwatch.Elapsed.TotalMilliseconds);                  }                  return;              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithSingleTriangle_ProducesSameTriangle,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithSingleTriangle_ProducesSameTriangle,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithSingleTriangle_ProducesSameTriangle,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithSingleTriangle_ProducesSameTriangle,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithThinQuad_DoesNotCrash,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithIssue1Quad_ReturnsSameResultAsLibtess2,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2' 1' 0' 3 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithIssue1Quad_ReturnsSameResultAsLibtess2,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2' 1' 0' 3 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithIssue1Quad_ReturnsSameResultAsLibtess2,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                  indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                  Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithIssue1Quad_ReturnsSameResultAsLibtess2,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                  indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                  Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithIssue1Quad_ReturnsSameResultAsLibtess2,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                  indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                  Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2' 2' 3' 4' 3' 1' 5 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2' 2' 3' 4' 3' 1' 5 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2' 2' 3' 4' 3' 1' 5 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2' 2' 3' 4' 3' 1' 5 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2' 2' 3' 4' 3' 1' 5 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2' 2' 3' 4' 3' 1' 5 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                  PolyConvert.ToTess(pset' tess);                  tess.NoEmptyPolygons = true;                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                  indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                  Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                  PolyConvert.ToTess(pset' tess);                  tess.NoEmptyPolygons = true;                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                  indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                  Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_WithNoEmptyPolygonsTrue_RemovesEmptyPolygons,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                  PolyConvert.ToTess(pset' tess);                  tess.NoEmptyPolygons = true;                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                  indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                  Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_CalledTwiceOnSameInstance_DoesNotCrash,The following statement contains a magic number: var expectedIndices = new int[] { 0' 1' 2 };
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_CalledTwiceOnSameInstance_DoesNotCrash,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    // Call once                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());                    // Call twice                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_CalledTwiceOnSameInstance_DoesNotCrash,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    // Call once                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());                    // Call twice                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_CalledTwiceOnSameInstance_DoesNotCrash,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    // Call once                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());                    // Call twice                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_CalledTwiceOnSameInstance_DoesNotCrash,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    // Call once                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());                    // Call twice                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_CalledTwiceOnSameInstance_DoesNotCrash,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    // Call once                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());                    // Call twice                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,Tesselate_CalledTwiceOnSameInstance_DoesNotCrash,The following statement contains a magic number: using (var stream = new MemoryStream(Encoding.UTF8.GetBytes(data)))              {                  var pset = DataLoader.LoadDat(stream);                  var tess = new Tess();                    // Call once                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());                    // Call twice                  PolyConvert.ToTess(pset' tess);                  tess.Tessellate(WindingRule.EvenOdd' ElementType.Polygons' 3);                    indices.Clear();                  for (int i = 0; i < tess.ElementCount; i++)                  {                      for (int j = 0; j < 3; j++)                      {                          int index = tess.Elements[i * 3 + j];                          indices.Add(index);                      }                  }                    Assert.AreEqual(expectedIndices' indices.ToArray());              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,GenerateTestData,The following statement contains a magic number: foreach (var name in _loader.AssetNames)              {                  var pset = _loader.GetAsset(name).Polygons;                    var lines = new List<string>();                  var indices = new List<int>();                    foreach (WindingRule winding in Enum.GetValues(typeof(WindingRule)))                  {                      var tess = new Tess();                      PolyConvert.ToTess(pset' tess);                      tess.Tessellate(winding' ElementType.Polygons' 3);                        lines.Add(string.Format("{0} {1}"' winding' 3));                      for (int i = 0; i < tess.ElementCount; i++)                      {                          indices.Clear();                          for (int j = 0; j < 3; j++)                          {                              int index = tess.Elements[i * 3 + j];                              indices.Add(index);                          }                          lines.Add(string.Join(" "' indices));                      }                      lines.Add("");                  }                    File.WriteAllLines(Path.Combine(TestDataPath' name + ".testdat")' lines);              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,GenerateTestData,The following statement contains a magic number: foreach (var name in _loader.AssetNames)              {                  var pset = _loader.GetAsset(name).Polygons;                    var lines = new List<string>();                  var indices = new List<int>();                    foreach (WindingRule winding in Enum.GetValues(typeof(WindingRule)))                  {                      var tess = new Tess();                      PolyConvert.ToTess(pset' tess);                      tess.Tessellate(winding' ElementType.Polygons' 3);                        lines.Add(string.Format("{0} {1}"' winding' 3));                      for (int i = 0; i < tess.ElementCount; i++)                      {                          indices.Clear();                          for (int j = 0; j < 3; j++)                          {                              int index = tess.Elements[i * 3 + j];                              indices.Add(index);                          }                          lines.Add(string.Join(" "' indices));                      }                      lines.Add("");                  }                    File.WriteAllLines(Path.Combine(TestDataPath' name + ".testdat")' lines);              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,GenerateTestData,The following statement contains a magic number: foreach (var name in _loader.AssetNames)              {                  var pset = _loader.GetAsset(name).Polygons;                    var lines = new List<string>();                  var indices = new List<int>();                    foreach (WindingRule winding in Enum.GetValues(typeof(WindingRule)))                  {                      var tess = new Tess();                      PolyConvert.ToTess(pset' tess);                      tess.Tessellate(winding' ElementType.Polygons' 3);                        lines.Add(string.Format("{0} {1}"' winding' 3));                      for (int i = 0; i < tess.ElementCount; i++)                      {                          indices.Clear();                          for (int j = 0; j < 3; j++)                          {                              int index = tess.Elements[i * 3 + j];                              indices.Add(index);                          }                          lines.Add(string.Join(" "' indices));                      }                      lines.Add("");                  }                    File.WriteAllLines(Path.Combine(TestDataPath' name + ".testdat")' lines);              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,GenerateTestData,The following statement contains a magic number: foreach (var name in _loader.AssetNames)              {                  var pset = _loader.GetAsset(name).Polygons;                    var lines = new List<string>();                  var indices = new List<int>();                    foreach (WindingRule winding in Enum.GetValues(typeof(WindingRule)))                  {                      var tess = new Tess();                      PolyConvert.ToTess(pset' tess);                      tess.Tessellate(winding' ElementType.Polygons' 3);                        lines.Add(string.Format("{0} {1}"' winding' 3));                      for (int i = 0; i < tess.ElementCount; i++)                      {                          indices.Clear();                          for (int j = 0; j < 3; j++)                          {                              int index = tess.Elements[i * 3 + j];                              indices.Add(index);                          }                          lines.Add(string.Join(" "' indices));                      }                      lines.Add("");                  }                    File.WriteAllLines(Path.Combine(TestDataPath' name + ".testdat")' lines);              }
Magic Number,TessBed,UnitTests,C:\repos\speps_LibTessDotNet\TessBed\UnitTests.cs,GetTestCaseData,The following statement contains a magic number: foreach (WindingRule winding in Enum.GetValues(typeof(WindingRule)))              {                  foreach (var name in _loader.AssetNames)                  {                      data.Add(new TestCaseData { AssetName = name' Winding = winding' ElementSize = 3 });                  }              }
