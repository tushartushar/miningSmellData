Implementation smell,Namespace,Class,File,Method,Description
Long Method,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,CheckForIntersect,The method has 146 lines of code.
Long Method,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The method has 110 lines of code.
Complex Method,LibTessDotNet,Geom,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Geom.cs,EdgeIntersect,Cyclomatic complexity of the method is 9
Complex Method,LibTessDotNet,Mesh,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Mesh.cs,MergeConvexFaces,Cyclomatic complexity of the method is 8
Complex Method,LibTessDotNet,PriorityQueue<TValue>,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\PriorityQueue.cs,Init,Cyclomatic complexity of the method is 8
Complex Method,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,CheckForIntersect,Cyclomatic complexity of the method is 14
Complex Method,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,WalkDirtyRegions,Cyclomatic complexity of the method is 12
Complex Method,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,Cyclomatic complexity of the method is 14
Complex Method,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,Cyclomatic complexity of the method is 18
Long Parameter List,LibTessDotNet,Geom,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Geom.cs,EdgeIntersect,The method has 5 parameters. Parameters: o1' d1' o2' d2' v
Long Parameter List,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,AddRightEdges,The method has 5 parameters. Parameters: regUp' eFirst' eLast' eTopLeft' cleanUp
Long Parameter List,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,VertexWeights,The method has 5 parameters. Parameters: isect' org' dst' w0' w1
Long Parameter List,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,GetIntersectData,The method has 5 parameters. Parameters: isect' orgUp' dstUp' orgLo' dstLo
Long Statement,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,AddContour,The length of the statement  "                reverse = (forceOrientation == ContourOrientation.Clockwise && area < 0.0f) || (forceOrientation == ContourOrientation.CounterClockwise && area > 0.0f); " is 152.
Complex Conditional,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,CheckForIntersect,The conditional expression  "(! Geom.VertEq(dstUp' _event)                  && Geom.EdgeSign(dstUp' _event' isect) >= 0.0f)                  || (! Geom.VertEq(dstLo' _event)                  && Geom.EdgeSign(dstLo' _event' isect) <= 0.0f)"  is complex.
Complex Conditional,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,WalkDirtyRegions,The conditional expression  "eUp._Dst != eLo._Dst                          && ! regUp._fixUpperEdge && ! regLo._fixUpperEdge                          && (eUp._Dst == _event || eLo._Dst == _event)"  is complex.
Magic Number,LibTessDotNet,Geom,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Geom.cs,IsWindingInside,The following statement contains a magic number: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
Magic Number,LibTessDotNet,Geom,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Geom.cs,IsWindingInside,The following statement contains a magic number: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
Magic Number,LibTessDotNet,Mesh,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Mesh.cs,MergeConvexFaces,The following statement contains a magic number: for (var f = _fHead._next; f != _fHead; f = f._next)              {                  // Skip faces which are outside the result                  if (!f._inside)                  {                      continue;                  }                    var eCur = f._anEdge;                  var vStart = eCur._Org;                    while (true)                  {                      var eNext = eCur._Lnext;                      var eSym = eCur._Sym;                        if (eSym != null && eSym._Lface != null && eSym._Lface._inside)                      {                          // Try to merge the neighbour faces if the resulting polygons                          // does not exceed maximum number of vertices.                          int curNv = f.VertsCount;                          int symNv = eSym._Lface.VertsCount;                          if ((curNv + symNv - 2) <= maxVertsPerFace)                          {                              // Merge if the resulting poly is convex.                              if (Geom.VertCCW(eCur._Lprev._Org' eCur._Org' eSym._Lnext._Lnext._Org) &&                                  Geom.VertCCW(eSym._Lprev._Org' eSym._Org' eCur._Lnext._Lnext._Org))                              {                                  eNext = eSym._Lnext;                                  Delete(eSym);                                  eCur = null;                              }                          }                      }                        if (eCur != null && eCur._Lnext._Org == vStart)                          break;                        // Continue to next edge.                      eCur = eNext;                  }              }
Magic Number,LibTessDotNet,Vec3,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\MeshUtils.cs,LongAxis,The following statement contains a magic number: if (Math.Abs(v.Z) > Math.Abs(i == 0 ? v.X : v.Y)) i = 2;
Magic Number,LibTessDotNet,PriorityHeap<TValue>,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\PriorityHeap.cs,Insert,The following statement contains a magic number: if ((curr * 2) > _max)              {                  _max <<= 1;                  Array.Resize(ref _nodes' _max + 1);                  Array.Resize(ref _handles' _max + 1);              }
Magic Number,LibTessDotNet,PriorityQueue<TValue>,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\PriorityQueue.cs,Init,The following statement contains a magic number: uint seed = 2016473283;
Magic Number,LibTessDotNet,PriorityQueue<TValue>,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\PriorityQueue.cs,Init,The following statement contains a magic number: while (stack.Count > 0)              {                  var top = stack.Pop();                  p = top.p;                  r = top.r;                    while (r > p + 10)                  {                      seed = seed * 1539415821 + 1;                      i = p + (int)(seed % (r - p + 1));                      piv = _order[i];                      _order[i] = _order[p];                      _order[p] = piv;                      i = p - 1;                      j = r + 1;                      do {                          do { ++i; } while (!_leq(_keys[_order[i]]' _keys[piv]));                          do { --j; } while (!_leq(_keys[piv]' _keys[_order[j]]));                          Swap(ref _order[i]' ref _order[j]);                      } while (i < j);                      Swap(ref _order[i]' ref _order[j]);                      if (i - p < r - j)                      {                          stack.Push(new StackItem { p = j + 1' r = r });                          r = i - 1;                      }                      else                      {                          stack.Push(new StackItem { p = p' r = i - 1 });                          p = j + 1;                      }                  }                  for (i = p + 1; i <= r; ++i)                  {                      piv = _order[i];                      for (j = i; j > p && !_leq(_keys[piv]' _keys[_order[j - 1]]); --j)                      {                          _order[j] = _order[j - 1];                      }                      _order[j] = piv;                  }              }
Magic Number,LibTessDotNet,PriorityQueue<TValue>,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\PriorityQueue.cs,Init,The following statement contains a magic number: while (stack.Count > 0)              {                  var top = stack.Pop();                  p = top.p;                  r = top.r;                    while (r > p + 10)                  {                      seed = seed * 1539415821 + 1;                      i = p + (int)(seed % (r - p + 1));                      piv = _order[i];                      _order[i] = _order[p];                      _order[p] = piv;                      i = p - 1;                      j = r + 1;                      do {                          do { ++i; } while (!_leq(_keys[_order[i]]' _keys[piv]));                          do { --j; } while (!_leq(_keys[piv]' _keys[_order[j]]));                          Swap(ref _order[i]' ref _order[j]);                      } while (i < j);                      Swap(ref _order[i]' ref _order[j]);                      if (i - p < r - j)                      {                          stack.Push(new StackItem { p = j + 1' r = r });                          r = i - 1;                      }                      else                      {                          stack.Push(new StackItem { p = p' r = i - 1 });                          p = j + 1;                      }                  }                  for (i = p + 1; i <= r; ++i)                  {                      piv = _order[i];                      for (j = i; j > p && !_leq(_keys[piv]' _keys[_order[j - 1]]); --j)                      {                          _order[j] = _order[j - 1];                      }                      _order[j] = piv;                  }              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,InitPriorityQ,The following statement contains a magic number: vertexCount += 8;
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: var minVal = new Real[3] { v._coords.X' v._coords.Y' v._coords.Z };
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: var minVert = new MeshUtils.Vertex[3] { v' v' v };
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: var maxVal = new Real[3] { v._coords.X' v._coords.Y' v._coords.Z };
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: var maxVert = new MeshUtils.Vertex[3] { v' v' v };
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: for (; v != _mesh._vHead; v = v._next)              {                  if (v._coords.X < minVal[0]) { minVal[0] = v._coords.X; minVert[0] = v; }                  if (v._coords.Y < minVal[1]) { minVal[1] = v._coords.Y; minVert[1] = v; }                  if (v._coords.Z < minVal[2]) { minVal[2] = v._coords.Z; minVert[2] = v; }                  if (v._coords.X > maxVal[0]) { maxVal[0] = v._coords.X; maxVert[0] = v; }                  if (v._coords.Y > maxVal[1]) { maxVal[1] = v._coords.Y; maxVert[1] = v; }                  if (v._coords.Z > maxVal[2]) { maxVal[2] = v._coords.Z; maxVert[2] = v; }              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: for (; v != _mesh._vHead; v = v._next)              {                  if (v._coords.X < minVal[0]) { minVal[0] = v._coords.X; minVert[0] = v; }                  if (v._coords.Y < minVal[1]) { minVal[1] = v._coords.Y; minVert[1] = v; }                  if (v._coords.Z < minVal[2]) { minVal[2] = v._coords.Z; minVert[2] = v; }                  if (v._coords.X > maxVal[0]) { maxVal[0] = v._coords.X; maxVert[0] = v; }                  if (v._coords.Y > maxVal[1]) { maxVal[1] = v._coords.Y; maxVert[1] = v; }                  if (v._coords.Z > maxVal[2]) { maxVal[2] = v._coords.Z; maxVert[2] = v; }              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: for (; v != _mesh._vHead; v = v._next)              {                  if (v._coords.X < minVal[0]) { minVal[0] = v._coords.X; minVert[0] = v; }                  if (v._coords.Y < minVal[1]) { minVal[1] = v._coords.Y; minVert[1] = v; }                  if (v._coords.Z < minVal[2]) { minVal[2] = v._coords.Z; minVert[2] = v; }                  if (v._coords.X > maxVal[0]) { maxVal[0] = v._coords.X; maxVert[0] = v; }                  if (v._coords.Y > maxVal[1]) { maxVal[1] = v._coords.Y; maxVert[1] = v; }                  if (v._coords.Z > maxVal[2]) { maxVal[2] = v._coords.Z; maxVert[2] = v; }              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: for (; v != _mesh._vHead; v = v._next)              {                  if (v._coords.X < minVal[0]) { minVal[0] = v._coords.X; minVert[0] = v; }                  if (v._coords.Y < minVal[1]) { minVal[1] = v._coords.Y; minVert[1] = v; }                  if (v._coords.Z < minVal[2]) { minVal[2] = v._coords.Z; minVert[2] = v; }                  if (v._coords.X > maxVal[0]) { maxVal[0] = v._coords.X; maxVert[0] = v; }                  if (v._coords.Y > maxVal[1]) { maxVal[1] = v._coords.Y; maxVert[1] = v; }                  if (v._coords.Z > maxVal[2]) { maxVal[2] = v._coords.Z; maxVert[2] = v; }              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: for (; v != _mesh._vHead; v = v._next)              {                  if (v._coords.X < minVal[0]) { minVal[0] = v._coords.X; minVert[0] = v; }                  if (v._coords.Y < minVal[1]) { minVal[1] = v._coords.Y; minVert[1] = v; }                  if (v._coords.Z < minVal[2]) { minVal[2] = v._coords.Z; minVert[2] = v; }                  if (v._coords.X > maxVal[0]) { maxVal[0] = v._coords.X; maxVert[0] = v; }                  if (v._coords.Y > maxVal[1]) { maxVal[1] = v._coords.Y; maxVert[1] = v; }                  if (v._coords.Z > maxVal[2]) { maxVal[2] = v._coords.Z; maxVert[2] = v; }              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: for (; v != _mesh._vHead; v = v._next)              {                  if (v._coords.X < minVal[0]) { minVal[0] = v._coords.X; minVert[0] = v; }                  if (v._coords.Y < minVal[1]) { minVal[1] = v._coords.Y; minVert[1] = v; }                  if (v._coords.Z < minVal[2]) { minVal[2] = v._coords.Z; minVert[2] = v; }                  if (v._coords.X > maxVal[0]) { maxVal[0] = v._coords.X; maxVert[0] = v; }                  if (v._coords.Y > maxVal[1]) { maxVal[1] = v._coords.Y; maxVert[1] = v; }                  if (v._coords.Z > maxVal[2]) { maxVal[2] = v._coords.Z; maxVert[2] = v; }              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) { i = 2; }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) { i = 2; }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ComputeNormal,The following statement contains a magic number: if (maxVal[2] - minVal[2] > maxVal[i] - minVal[i]) { i = 2; }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 1) % 3] = SUnitX;
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 2) % 3] = SUnitY;
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _sUnit[(i + 2) % 3] = SUnitY;
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 1) % 3] = norm[i] > 0.0f ? -SUnitY : SUnitY;
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 2) % 3] = norm[i] > 0.0f ? SUnitX : -SUnitX;
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,ProjectPolygon,The following statement contains a magic number: _tUnit[(i + 2) % 3] = norm[i] > 0.0f ? SUnitX : -SUnitX;
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The following statement contains a magic number: if (polySize < 3)              {                  polySize = 3;              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The following statement contains a magic number: if (polySize < 3)              {                  polySize = 3;              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The following statement contains a magic number: if (polySize > 3)              {                  _mesh.MergeConvexFaces(polySize);              }
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,OutputPolymesh,The following statement contains a magic number: if (elementType == ElementType.ConnectedPolygons)                  maxFaceCount *= 2;
Magic Number,LibTessDotNet,Tess,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Sweep.cs,OutputContours,The following statement contains a magic number: _elements = new int[_elementCount * 2];
Missing Default,LibTessDotNet,Geom,C:\repos\speps_LibTessDotNet\LibTessDotNet\Sources\Geom.cs,IsWindingInside,The following switch statement is missing a default case: switch (rule)              {                  case WindingRule.EvenOdd:                      return (n & 1) == 1;                  case WindingRule.NonZero:                      return n != 0;                  case WindingRule.Positive:                      return n > 0;                  case WindingRule.Negative:                      return n < 0;                  case WindingRule.AbsGeqTwo:                      return n >= 2 || n <= -2;              }
