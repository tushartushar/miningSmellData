Implementation smell,Namespace,Class,File,Method,Description
Long Method,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The method has 126 lines of code.
Complex Method,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,Cyclomatic complexity of the method is 14
Long Parameter List,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,Execute,The method has 7 parameters.
Long Parameter List,AddMaterials,FillPatternBenchmarkCommand,C:\repos\jeremytammik_AddMaterials\AddMaterials\FillPatternBenchmarkCommand.cs,Execute,The method has 6 parameters.
Long Identifier,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,OnFillPatternChanged,The length of the parameter FillPatternViewerControlWpfControl is 34.
Long Statement,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,Execute,The length of the statement  "	Dictionary<string' Material> materials = new FilteredElementCollector (doc).OfClass (typeof(Material)).Cast<Material> ().ToDictionary<Material' string> (e => e.Name); " is 166.
Long Statement,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,Execute,The length of the statement  "	Dictionary<string' FillPatternElement> fillPatterns = new FilteredElementCollector (doc).OfClass (typeof(FillPatternElement)).Cast<FillPatternElement> ().ToDictionary<FillPatternElement' string> (e => e.Name); " is 209.
Long Statement,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,Execute,The length of the statement  "		string msg = string.Format ("{0} row{1} successfully parsed and " + "{2} material{3} added:"' materialsToImport.Count' PluralSuffix (materialsToImport.Count)' materialsToAdd.Count' PluralSuffix (materialsToAdd.Count)); " is 218.
Long Statement,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The length of the statement  "	Excel.Workbook workbook = excel.Workbooks.Open (_input_file_name' 0' true' 5' ""' ""' true' Excel.XlPlatform.xlWindows' "\t"' false' false' 0' true' 1' 0); " is 155.
Long Statement,AddMaterials,FillPatternBenchmarkCommand,C:\repos\jeremytammik_AddMaterials\AddMaterials\FillPatternBenchmarkCommand.cs,Execute,The length of the statement  "	var fillPatternElements = new FilteredElementCollector (doc).OfClass (typeof(FillPatternElement)).OfType<FillPatternElement> ().OrderBy (fp => fp.Name).ToList (); " is 162.
Long Statement,AddMaterials,FillPatternBenchmarkCommand,C:\repos\jeremytammik_AddMaterials\AddMaterials\FillPatternBenchmarkCommand.cs,Execute,The length of the statement  "	FillPatternsViewModel fillPatternsViewModel = new FillPatternsViewModel (fillPatterns.Select (x => new FillPatternViewModel (x))); " is 130.
Long Statement,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The length of the statement  "		g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0); " is 123.
Long Statement,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,LineIntersectsRect,The length of the statement  "	return LineIntersectsRect (new System.Drawing.Point ((int)rayMatrix.OffsetX' (int)rayMatrix.OffsetY)' new System.Drawing.Point ((int)m.OffsetX' (int)m.OffsetY)' r); " is 164.
Long Statement,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,LineIntersectsRect,The length of the statement  "	return LineIntersectsLine (p1' p2' new System.Drawing.Point (r.X' r.Y)' new System.Drawing.Point (r.X + r.Width' r.Y)) || LineIntersectsLine (p1' p2' new System.Drawing.Point (r.X + r.Width' r.Y)' new System.Drawing.Point (r.X + r.Width' r.Y + r.Height)) || LineIntersectsLine (p1' p2' new System.Drawing.Point (r.X + r.Width' r.Y + r.Height)' new System.Drawing.Point (r.X' r.Y + r.Height)) || LineIntersectsLine (p1' p2' new System.Drawing.Point (r.X' r.Y + r.Height)' new System.Drawing.Point (r.X' r.Y)) || (r.Contains (p1) && r.Contains (p2)); " is 548.
Long Statement,AddMaterials.View.Converters,BitmapSourceConverter,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Converters\BitmapSourceConverter.cs,ConvertFromImage,The length of the statement  "			var bs = Imaging.CreateBitmapSourceFromHBitmap (hBitmap' IntPtr.Zero' Int32Rect.Empty' BitmapSizeOptions.FromEmptyOptions ()); " is 126.
Long Statement,AddMaterials.View.Converters,BitmapSourceConverter,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Converters\BitmapSourceConverter.cs,ConvertFromIcon,The length of the statement  "		var bs = Imaging.CreateBitmapSourceFromHIcon (icon.Handle' new Int32Rect (0' 0' icon.Width' icon.Height)' BitmapSizeOptions.FromWidthAndHeight (icon.Width' icon.Height)); " is 170.
Complex Conditional,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,LineIntersectsLine,The conditional expression  "r < 0 || r > 1 || s < 0 || s > 1"  is complex.
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: while (null != range.Cells [iRow' 1].Value2) {  	string matName = (string)range.Cells [iRow' 1].Value2;  	matName += " " + (string)range.Cells [iRow' 2].Value2;  	matName += " " + (string)range.Cells [iRow' 3].Value2;  	if (!string.IsNullOrEmpty (matName)) {  		double red = (double)range.Cells [iRow' 4].Value2;  		double green = (double)range.Cells [iRow' 5].Value2;  		double blue = (double)range.Cells [iRow' 6].Value2;  		double transparency = (double)range.Cells [iRow' 8].Value2;  		string surPatternName = (string)range.Cells [iRow' 9].Value2;  		string cutPatternName = (string)range.Cells [iRow' 10].Value2;  		string csi = (string)range.Cells [iRow' 11].Value2;  		FillPatternElement fillPatternElement;  		FillPattern surfacePattern = null' cutPattern = null;  		if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  			surfacePattern = fillPatternElement.GetFillPattern ();  		if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  			cutPattern = fillPatternElement.GetFillPattern ();  		var status = Status.Normal;  		if (!materials.ContainsKey (csi))  			status = Status.BaseMaterialClassNotFound;  		if (materials.ContainsKey (matName))  			status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  		yield return new MaterialViewModel {  			Name = matName'  			BaseMaterialClass = csi'  			Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  			Transparency = transparency'  			SurfacePattern = surfacePattern'  			CutPattern = cutPattern'  			Status = status'  			AddToProject = status == Status.Normal  		};  	}  	++iRow;  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: matName += " " + (string)range.Cells [iRow' 2].Value2;  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: matName += " " + (string)range.Cells [iRow' 3].Value2;  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: if (!string.IsNullOrEmpty (matName)) {  	double red = (double)range.Cells [iRow' 4].Value2;  	double green = (double)range.Cells [iRow' 5].Value2;  	double blue = (double)range.Cells [iRow' 6].Value2;  	double transparency = (double)range.Cells [iRow' 8].Value2;  	string surPatternName = (string)range.Cells [iRow' 9].Value2;  	string cutPatternName = (string)range.Cells [iRow' 10].Value2;  	string csi = (string)range.Cells [iRow' 11].Value2;  	FillPatternElement fillPatternElement;  	FillPattern surfacePattern = null' cutPattern = null;  	if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  		surfacePattern = fillPatternElement.GetFillPattern ();  	if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  		cutPattern = fillPatternElement.GetFillPattern ();  	var status = Status.Normal;  	if (!materials.ContainsKey (csi))  		status = Status.BaseMaterialClassNotFound;  	if (materials.ContainsKey (matName))  		status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  	yield return new MaterialViewModel {  		Name = matName'  		BaseMaterialClass = csi'  		Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  		Transparency = transparency'  		SurfacePattern = surfacePattern'  		CutPattern = cutPattern'  		Status = status'  		AddToProject = status == Status.Normal  	};  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: if (!string.IsNullOrEmpty (matName)) {  	double red = (double)range.Cells [iRow' 4].Value2;  	double green = (double)range.Cells [iRow' 5].Value2;  	double blue = (double)range.Cells [iRow' 6].Value2;  	double transparency = (double)range.Cells [iRow' 8].Value2;  	string surPatternName = (string)range.Cells [iRow' 9].Value2;  	string cutPatternName = (string)range.Cells [iRow' 10].Value2;  	string csi = (string)range.Cells [iRow' 11].Value2;  	FillPatternElement fillPatternElement;  	FillPattern surfacePattern = null' cutPattern = null;  	if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  		surfacePattern = fillPatternElement.GetFillPattern ();  	if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  		cutPattern = fillPatternElement.GetFillPattern ();  	var status = Status.Normal;  	if (!materials.ContainsKey (csi))  		status = Status.BaseMaterialClassNotFound;  	if (materials.ContainsKey (matName))  		status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  	yield return new MaterialViewModel {  		Name = matName'  		BaseMaterialClass = csi'  		Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  		Transparency = transparency'  		SurfacePattern = surfacePattern'  		CutPattern = cutPattern'  		Status = status'  		AddToProject = status == Status.Normal  	};  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: if (!string.IsNullOrEmpty (matName)) {  	double red = (double)range.Cells [iRow' 4].Value2;  	double green = (double)range.Cells [iRow' 5].Value2;  	double blue = (double)range.Cells [iRow' 6].Value2;  	double transparency = (double)range.Cells [iRow' 8].Value2;  	string surPatternName = (string)range.Cells [iRow' 9].Value2;  	string cutPatternName = (string)range.Cells [iRow' 10].Value2;  	string csi = (string)range.Cells [iRow' 11].Value2;  	FillPatternElement fillPatternElement;  	FillPattern surfacePattern = null' cutPattern = null;  	if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  		surfacePattern = fillPatternElement.GetFillPattern ();  	if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  		cutPattern = fillPatternElement.GetFillPattern ();  	var status = Status.Normal;  	if (!materials.ContainsKey (csi))  		status = Status.BaseMaterialClassNotFound;  	if (materials.ContainsKey (matName))  		status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  	yield return new MaterialViewModel {  		Name = matName'  		BaseMaterialClass = csi'  		Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  		Transparency = transparency'  		SurfacePattern = surfacePattern'  		CutPattern = cutPattern'  		Status = status'  		AddToProject = status == Status.Normal  	};  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: if (!string.IsNullOrEmpty (matName)) {  	double red = (double)range.Cells [iRow' 4].Value2;  	double green = (double)range.Cells [iRow' 5].Value2;  	double blue = (double)range.Cells [iRow' 6].Value2;  	double transparency = (double)range.Cells [iRow' 8].Value2;  	string surPatternName = (string)range.Cells [iRow' 9].Value2;  	string cutPatternName = (string)range.Cells [iRow' 10].Value2;  	string csi = (string)range.Cells [iRow' 11].Value2;  	FillPatternElement fillPatternElement;  	FillPattern surfacePattern = null' cutPattern = null;  	if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  		surfacePattern = fillPatternElement.GetFillPattern ();  	if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  		cutPattern = fillPatternElement.GetFillPattern ();  	var status = Status.Normal;  	if (!materials.ContainsKey (csi))  		status = Status.BaseMaterialClassNotFound;  	if (materials.ContainsKey (matName))  		status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  	yield return new MaterialViewModel {  		Name = matName'  		BaseMaterialClass = csi'  		Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  		Transparency = transparency'  		SurfacePattern = surfacePattern'  		CutPattern = cutPattern'  		Status = status'  		AddToProject = status == Status.Normal  	};  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: if (!string.IsNullOrEmpty (matName)) {  	double red = (double)range.Cells [iRow' 4].Value2;  	double green = (double)range.Cells [iRow' 5].Value2;  	double blue = (double)range.Cells [iRow' 6].Value2;  	double transparency = (double)range.Cells [iRow' 8].Value2;  	string surPatternName = (string)range.Cells [iRow' 9].Value2;  	string cutPatternName = (string)range.Cells [iRow' 10].Value2;  	string csi = (string)range.Cells [iRow' 11].Value2;  	FillPatternElement fillPatternElement;  	FillPattern surfacePattern = null' cutPattern = null;  	if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  		surfacePattern = fillPatternElement.GetFillPattern ();  	if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  		cutPattern = fillPatternElement.GetFillPattern ();  	var status = Status.Normal;  	if (!materials.ContainsKey (csi))  		status = Status.BaseMaterialClassNotFound;  	if (materials.ContainsKey (matName))  		status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  	yield return new MaterialViewModel {  		Name = matName'  		BaseMaterialClass = csi'  		Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  		Transparency = transparency'  		SurfacePattern = surfacePattern'  		CutPattern = cutPattern'  		Status = status'  		AddToProject = status == Status.Normal  	};  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: if (!string.IsNullOrEmpty (matName)) {  	double red = (double)range.Cells [iRow' 4].Value2;  	double green = (double)range.Cells [iRow' 5].Value2;  	double blue = (double)range.Cells [iRow' 6].Value2;  	double transparency = (double)range.Cells [iRow' 8].Value2;  	string surPatternName = (string)range.Cells [iRow' 9].Value2;  	string cutPatternName = (string)range.Cells [iRow' 10].Value2;  	string csi = (string)range.Cells [iRow' 11].Value2;  	FillPatternElement fillPatternElement;  	FillPattern surfacePattern = null' cutPattern = null;  	if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  		surfacePattern = fillPatternElement.GetFillPattern ();  	if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  		cutPattern = fillPatternElement.GetFillPattern ();  	var status = Status.Normal;  	if (!materials.ContainsKey (csi))  		status = Status.BaseMaterialClassNotFound;  	if (materials.ContainsKey (matName))  		status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  	yield return new MaterialViewModel {  		Name = matName'  		BaseMaterialClass = csi'  		Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  		Transparency = transparency'  		SurfacePattern = surfacePattern'  		CutPattern = cutPattern'  		Status = status'  		AddToProject = status == Status.Normal  	};  }  
Magic Number,AddMaterials,Command,C:\repos\jeremytammik_AddMaterials\AddMaterials\Command.cs,ReadMaterialsFromXlsx,The following statement contains a magic number: if (!string.IsNullOrEmpty (matName)) {  	double red = (double)range.Cells [iRow' 4].Value2;  	double green = (double)range.Cells [iRow' 5].Value2;  	double blue = (double)range.Cells [iRow' 6].Value2;  	double transparency = (double)range.Cells [iRow' 8].Value2;  	string surPatternName = (string)range.Cells [iRow' 9].Value2;  	string cutPatternName = (string)range.Cells [iRow' 10].Value2;  	string csi = (string)range.Cells [iRow' 11].Value2;  	FillPatternElement fillPatternElement;  	FillPattern surfacePattern = null' cutPattern = null;  	if (fillPatterns.TryGetValue (surPatternName' out fillPatternElement))  		surfacePattern = fillPatternElement.GetFillPattern ();  	if (fillPatterns.TryGetValue (cutPatternName' out fillPatternElement))  		cutPattern = fillPatternElement.GetFillPattern ();  	var status = Status.Normal;  	if (!materials.ContainsKey (csi))  		status = Status.BaseMaterialClassNotFound;  	if (materials.ContainsKey (matName))  		status = Status.ProjectAlreadyContainsMaterialWithTheSameName;  	yield return new MaterialViewModel {  		Name = matName'  		BaseMaterialClass = csi'  		Color = new Color (Byte.Parse (red.ToString ())' Byte.Parse (green.ToString ())' Byte.Parse (blue.ToString ()))'  		Transparency = transparency'  		SurfacePattern = surfacePattern'  		CutPattern = cutPattern'  		Status = status'  		AddToProject = status == Status.Normal  	};  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,CreateFillPatternImage,The following statement contains a magic number: if (double.IsNaN (width))  	width = 100;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,CreateFillPatternImage,The following statement contains a magic number: width = 100;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,CreateFillPatternImage,The following statement contains a magic number: if (double.IsNaN (height))  	height = 30;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,CreateFillPatternImage,The following statement contains a magic number: height = 30;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: if (fillPattern.Target == FillPatternTarget.Model)  	matrixScale = Scale;  else  	matrixScale = Scale * 10;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: matrixScale = Scale * 10;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: try {  	var width = (ActualWidth == 0 ? Width : ActualWidth) == 0 ? 100 : (ActualWidth == 0 ? Width : ActualWidth);  	if (double.IsNaN (width))  		width = 100;  	var height = (ActualHeight == 0 ? Height : ActualHeight) == 0 ? 30 : (ActualHeight == 0 ? Height : ActualHeight);  	if (double.IsNaN (height))  		height = 30;  	var viewRect = new Rectangle (0' 0' (int)width' (int)height);  	var centerX = (viewRect.Left + viewRect.Left + viewRect.Width) / 2;  	var centerY = (viewRect.Top + viewRect.Top + viewRect.Height) / 2;  	g.TranslateTransform (centerX' centerY);  	var rectF = new Rectangle (-1' -1' 2' 2);  	g.FillRectangle (Brushes.Blue' rectF);  	//draw a small rectangle in the center of the image  	g.ResetTransform ();  	var fillGrids = fillPattern.GetFillGrids ();  	Debug.Print (new string ('-'' 100));  	Debug.Print ("FilPattern name: {0}"' fillPattern.Name);  	if (fillPattern.Target == FillPatternTarget.Model)  		Debug.Print ("FillPattern type: Model");  	else  		Debug.Print ("FillPattern type: Drafting");  	Debug.Print ("Matrix scale: {0}"' matrixScale);  	Debug.Print ("Grids count: {0}"' fillGrids.Count);  	Debug.Print ("Len\\Area: {0}"' fillPattern.LengthPerArea);  	Debug.Print ("Lines\\Len: {0}"' fillPattern.LinesPerLength);  	Debug.Print ("Strokes\\Area: {0}"' fillPattern.StrokesPerArea);  	foreach (var fillGrid in fillGrids) {  		var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  		Debug.Print (new string ('-'' 50));  		Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  		Debug.Print ("Offset: {0}"' fillGrid.Offset);  		Debug.Print ("Angle: {0}"' degreeAngle);  		Debug.Print ("Shift: {0}"' fillGrid.Shift);  		var pen = new Pen (System.Drawing.Color.Black) {  			Width = 1f / matrixScale  		};  		float dashLength = 1;  		var segments = fillGrid.GetSegments ();  		if (segments.Count > 0) {  			pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  			Debug.Print ("\tSegments:");  			foreach (var segment in segments) {  				Debug.Print ("\t\t{0}"' segment);  			}  			dashLength = pen.DashPattern.Sum ();  		}  		g.ResetTransform ();  		var rotateMatrix = new Matrix ();  		rotateMatrix.Rotate (degreeAngle);  		var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  		//-1 reflects about x-axis  		matrix.Scale (matrixScale' matrixScale);  		matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  		var backMatrix = matrix.Clone ();  		backMatrix.Multiply (rotateMatrix);  		matrix.Multiply (rotateMatrix);  		var offset = (-10) * dashLength;  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		Debug.Print ("Offset: {0}"' offset);  		bool moving_forward = true;  		bool moving_back = true;  		int safety = 500;  		double alternator = 0;  		while (moving_forward || moving_back)// draw segments shifting and offsetting each time  		 {  			Debug.Write ("*");  			var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  			if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  				g.Transform = matrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_forward = false;  				Debug.Print ("\n----> Matrix does not intersect view");  			}  			if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  				g.Transform = backMatrix;  				g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  			}  			else {  				moving_back = false;  				Debug.Print ("\n----> Back matrix does not intersect view");  			}  			if (safety == 0) {  				Debug.Print ("\n--------> Safety limit exceeded");  				break;  			}  			else  				--safety;  			matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  			backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  			alternator += fillGrid.Shift;  			if (Math.Abs (alternator) > Math.Abs (offset)) {  				Debug.Print ("\n----> Alternating");  				matrix.Translate (offset' 0);  				backMatrix.Translate (offset' 0);  				alternator = 0d;  			}  		}  	}  	sw.Stop ();  	g.ResetTransform ();  	#if DEBUG  	g.DrawString (string.Format ("{0} ms"' sw.ElapsedMilliseconds)' System.Drawing.SystemFonts.DefaultFont' Brushes.Red' 0' 0);  	#endif  	Debug.Print (new string ('-'' 50));  	Pen p = new Pen (System.Drawing.Color.Black);  	p.Width = 1f / matrixScale;  	Debug.Print ("Finished");  }  catch (Exception ex) {  	Debug.Print (ex.ToString ());  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: if (double.IsNaN (width))  	width = 100;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: width = 100;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: if (double.IsNaN (height))  	height = 30;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: height = 30;  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: Debug.Print (new string ('-'' 100));  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: foreach (var fillGrid in fillGrids) {  	var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  	Debug.Print (new string ('-'' 50));  	Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  	Debug.Print ("Offset: {0}"' fillGrid.Offset);  	Debug.Print ("Angle: {0}"' degreeAngle);  	Debug.Print ("Shift: {0}"' fillGrid.Shift);  	var pen = new Pen (System.Drawing.Color.Black) {  		Width = 1f / matrixScale  	};  	float dashLength = 1;  	var segments = fillGrid.GetSegments ();  	if (segments.Count > 0) {  		pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  		Debug.Print ("\tSegments:");  		foreach (var segment in segments) {  			Debug.Print ("\t\t{0}"' segment);  		}  		dashLength = pen.DashPattern.Sum ();  	}  	g.ResetTransform ();  	var rotateMatrix = new Matrix ();  	rotateMatrix.Rotate (degreeAngle);  	var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  	//-1 reflects about x-axis  	matrix.Scale (matrixScale' matrixScale);  	matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  	var backMatrix = matrix.Clone ();  	backMatrix.Multiply (rotateMatrix);  	matrix.Multiply (rotateMatrix);  	var offset = (-10) * dashLength;  	matrix.Translate (offset' 0);  	backMatrix.Translate (offset' 0);  	Debug.Print ("Offset: {0}"' offset);  	bool moving_forward = true;  	bool moving_back = true;  	int safety = 500;  	double alternator = 0;  	while (moving_forward || moving_back)// draw segments shifting and offsetting each time  	 {  		Debug.Write ("*");  		var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  		if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  			g.Transform = matrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_forward = false;  			Debug.Print ("\n----> Matrix does not intersect view");  		}  		if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  			g.Transform = backMatrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_back = false;  			Debug.Print ("\n----> Back matrix does not intersect view");  		}  		if (safety == 0) {  			Debug.Print ("\n--------> Safety limit exceeded");  			break;  		}  		else  			--safety;  		matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  		backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  		alternator += fillGrid.Shift;  		if (Math.Abs (alternator) > Math.Abs (offset)) {  			Debug.Print ("\n----> Alternating");  			matrix.Translate (offset' 0);  			backMatrix.Translate (offset' 0);  			alternator = 0d;  		}  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: foreach (var fillGrid in fillGrids) {  	var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  	Debug.Print (new string ('-'' 50));  	Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  	Debug.Print ("Offset: {0}"' fillGrid.Offset);  	Debug.Print ("Angle: {0}"' degreeAngle);  	Debug.Print ("Shift: {0}"' fillGrid.Shift);  	var pen = new Pen (System.Drawing.Color.Black) {  		Width = 1f / matrixScale  	};  	float dashLength = 1;  	var segments = fillGrid.GetSegments ();  	if (segments.Count > 0) {  		pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  		Debug.Print ("\tSegments:");  		foreach (var segment in segments) {  			Debug.Print ("\t\t{0}"' segment);  		}  		dashLength = pen.DashPattern.Sum ();  	}  	g.ResetTransform ();  	var rotateMatrix = new Matrix ();  	rotateMatrix.Rotate (degreeAngle);  	var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  	//-1 reflects about x-axis  	matrix.Scale (matrixScale' matrixScale);  	matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  	var backMatrix = matrix.Clone ();  	backMatrix.Multiply (rotateMatrix);  	matrix.Multiply (rotateMatrix);  	var offset = (-10) * dashLength;  	matrix.Translate (offset' 0);  	backMatrix.Translate (offset' 0);  	Debug.Print ("Offset: {0}"' offset);  	bool moving_forward = true;  	bool moving_back = true;  	int safety = 500;  	double alternator = 0;  	while (moving_forward || moving_back)// draw segments shifting and offsetting each time  	 {  		Debug.Write ("*");  		var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  		if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  			g.Transform = matrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_forward = false;  			Debug.Print ("\n----> Matrix does not intersect view");  		}  		if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  			g.Transform = backMatrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_back = false;  			Debug.Print ("\n----> Back matrix does not intersect view");  		}  		if (safety == 0) {  			Debug.Print ("\n--------> Safety limit exceeded");  			break;  		}  		else  			--safety;  		matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  		backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  		alternator += fillGrid.Shift;  		if (Math.Abs (alternator) > Math.Abs (offset)) {  			Debug.Print ("\n----> Alternating");  			matrix.Translate (offset' 0);  			backMatrix.Translate (offset' 0);  			alternator = 0d;  		}  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: foreach (var fillGrid in fillGrids) {  	var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  	Debug.Print (new string ('-'' 50));  	Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  	Debug.Print ("Offset: {0}"' fillGrid.Offset);  	Debug.Print ("Angle: {0}"' degreeAngle);  	Debug.Print ("Shift: {0}"' fillGrid.Shift);  	var pen = new Pen (System.Drawing.Color.Black) {  		Width = 1f / matrixScale  	};  	float dashLength = 1;  	var segments = fillGrid.GetSegments ();  	if (segments.Count > 0) {  		pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  		Debug.Print ("\tSegments:");  		foreach (var segment in segments) {  			Debug.Print ("\t\t{0}"' segment);  		}  		dashLength = pen.DashPattern.Sum ();  	}  	g.ResetTransform ();  	var rotateMatrix = new Matrix ();  	rotateMatrix.Rotate (degreeAngle);  	var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  	//-1 reflects about x-axis  	matrix.Scale (matrixScale' matrixScale);  	matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  	var backMatrix = matrix.Clone ();  	backMatrix.Multiply (rotateMatrix);  	matrix.Multiply (rotateMatrix);  	var offset = (-10) * dashLength;  	matrix.Translate (offset' 0);  	backMatrix.Translate (offset' 0);  	Debug.Print ("Offset: {0}"' offset);  	bool moving_forward = true;  	bool moving_back = true;  	int safety = 500;  	double alternator = 0;  	while (moving_forward || moving_back)// draw segments shifting and offsetting each time  	 {  		Debug.Write ("*");  		var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  		if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  			g.Transform = matrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_forward = false;  			Debug.Print ("\n----> Matrix does not intersect view");  		}  		if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  			g.Transform = backMatrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_back = false;  			Debug.Print ("\n----> Back matrix does not intersect view");  		}  		if (safety == 0) {  			Debug.Print ("\n--------> Safety limit exceeded");  			break;  		}  		else  			--safety;  		matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  		backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  		alternator += fillGrid.Shift;  		if (Math.Abs (alternator) > Math.Abs (offset)) {  			Debug.Print ("\n----> Alternating");  			matrix.Translate (offset' 0);  			backMatrix.Translate (offset' 0);  			alternator = 0d;  		}  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: foreach (var fillGrid in fillGrids) {  	var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  	Debug.Print (new string ('-'' 50));  	Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  	Debug.Print ("Offset: {0}"' fillGrid.Offset);  	Debug.Print ("Angle: {0}"' degreeAngle);  	Debug.Print ("Shift: {0}"' fillGrid.Shift);  	var pen = new Pen (System.Drawing.Color.Black) {  		Width = 1f / matrixScale  	};  	float dashLength = 1;  	var segments = fillGrid.GetSegments ();  	if (segments.Count > 0) {  		pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  		Debug.Print ("\tSegments:");  		foreach (var segment in segments) {  			Debug.Print ("\t\t{0}"' segment);  		}  		dashLength = pen.DashPattern.Sum ();  	}  	g.ResetTransform ();  	var rotateMatrix = new Matrix ();  	rotateMatrix.Rotate (degreeAngle);  	var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  	//-1 reflects about x-axis  	matrix.Scale (matrixScale' matrixScale);  	matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  	var backMatrix = matrix.Clone ();  	backMatrix.Multiply (rotateMatrix);  	matrix.Multiply (rotateMatrix);  	var offset = (-10) * dashLength;  	matrix.Translate (offset' 0);  	backMatrix.Translate (offset' 0);  	Debug.Print ("Offset: {0}"' offset);  	bool moving_forward = true;  	bool moving_back = true;  	int safety = 500;  	double alternator = 0;  	while (moving_forward || moving_back)// draw segments shifting and offsetting each time  	 {  		Debug.Write ("*");  		var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  		if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  			g.Transform = matrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_forward = false;  			Debug.Print ("\n----> Matrix does not intersect view");  		}  		if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  			g.Transform = backMatrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_back = false;  			Debug.Print ("\n----> Back matrix does not intersect view");  		}  		if (safety == 0) {  			Debug.Print ("\n--------> Safety limit exceeded");  			break;  		}  		else  			--safety;  		matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  		backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  		alternator += fillGrid.Shift;  		if (Math.Abs (alternator) > Math.Abs (offset)) {  			Debug.Print ("\n----> Alternating");  			matrix.Translate (offset' 0);  			backMatrix.Translate (offset' 0);  			alternator = 0d;  		}  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: foreach (var fillGrid in fillGrids) {  	var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  	Debug.Print (new string ('-'' 50));  	Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  	Debug.Print ("Offset: {0}"' fillGrid.Offset);  	Debug.Print ("Angle: {0}"' degreeAngle);  	Debug.Print ("Shift: {0}"' fillGrid.Shift);  	var pen = new Pen (System.Drawing.Color.Black) {  		Width = 1f / matrixScale  	};  	float dashLength = 1;  	var segments = fillGrid.GetSegments ();  	if (segments.Count > 0) {  		pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  		Debug.Print ("\tSegments:");  		foreach (var segment in segments) {  			Debug.Print ("\t\t{0}"' segment);  		}  		dashLength = pen.DashPattern.Sum ();  	}  	g.ResetTransform ();  	var rotateMatrix = new Matrix ();  	rotateMatrix.Rotate (degreeAngle);  	var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  	//-1 reflects about x-axis  	matrix.Scale (matrixScale' matrixScale);  	matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  	var backMatrix = matrix.Clone ();  	backMatrix.Multiply (rotateMatrix);  	matrix.Multiply (rotateMatrix);  	var offset = (-10) * dashLength;  	matrix.Translate (offset' 0);  	backMatrix.Translate (offset' 0);  	Debug.Print ("Offset: {0}"' offset);  	bool moving_forward = true;  	bool moving_back = true;  	int safety = 500;  	double alternator = 0;  	while (moving_forward || moving_back)// draw segments shifting and offsetting each time  	 {  		Debug.Write ("*");  		var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  		if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  			g.Transform = matrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_forward = false;  			Debug.Print ("\n----> Matrix does not intersect view");  		}  		if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  			g.Transform = backMatrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_back = false;  			Debug.Print ("\n----> Back matrix does not intersect view");  		}  		if (safety == 0) {  			Debug.Print ("\n--------> Safety limit exceeded");  			break;  		}  		else  			--safety;  		matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  		backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  		alternator += fillGrid.Shift;  		if (Math.Abs (alternator) > Math.Abs (offset)) {  			Debug.Print ("\n----> Alternating");  			matrix.Translate (offset' 0);  			backMatrix.Translate (offset' 0);  			alternator = 0d;  		}  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: foreach (var fillGrid in fillGrids) {  	var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  	Debug.Print (new string ('-'' 50));  	Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  	Debug.Print ("Offset: {0}"' fillGrid.Offset);  	Debug.Print ("Angle: {0}"' degreeAngle);  	Debug.Print ("Shift: {0}"' fillGrid.Shift);  	var pen = new Pen (System.Drawing.Color.Black) {  		Width = 1f / matrixScale  	};  	float dashLength = 1;  	var segments = fillGrid.GetSegments ();  	if (segments.Count > 0) {  		pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  		Debug.Print ("\tSegments:");  		foreach (var segment in segments) {  			Debug.Print ("\t\t{0}"' segment);  		}  		dashLength = pen.DashPattern.Sum ();  	}  	g.ResetTransform ();  	var rotateMatrix = new Matrix ();  	rotateMatrix.Rotate (degreeAngle);  	var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  	//-1 reflects about x-axis  	matrix.Scale (matrixScale' matrixScale);  	matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  	var backMatrix = matrix.Clone ();  	backMatrix.Multiply (rotateMatrix);  	matrix.Multiply (rotateMatrix);  	var offset = (-10) * dashLength;  	matrix.Translate (offset' 0);  	backMatrix.Translate (offset' 0);  	Debug.Print ("Offset: {0}"' offset);  	bool moving_forward = true;  	bool moving_back = true;  	int safety = 500;  	double alternator = 0;  	while (moving_forward || moving_back)// draw segments shifting and offsetting each time  	 {  		Debug.Write ("*");  		var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  		if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  			g.Transform = matrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_forward = false;  			Debug.Print ("\n----> Matrix does not intersect view");  		}  		if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  			g.Transform = backMatrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_back = false;  			Debug.Print ("\n----> Back matrix does not intersect view");  		}  		if (safety == 0) {  			Debug.Print ("\n--------> Safety limit exceeded");  			break;  		}  		else  			--safety;  		matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  		backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  		alternator += fillGrid.Shift;  		if (Math.Abs (alternator) > Math.Abs (offset)) {  			Debug.Print ("\n----> Alternating");  			matrix.Translate (offset' 0);  			backMatrix.Translate (offset' 0);  			alternator = 0d;  		}  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: foreach (var fillGrid in fillGrids) {  	var degreeAngle = (float)RadianToGradus (fillGrid.Angle);  	Debug.Print (new string ('-'' 50));  	Debug.Print ("Origin: U:{0} V:{1}"' fillGrid.Origin.U' fillGrid.Origin.V);  	Debug.Print ("Offset: {0}"' fillGrid.Offset);  	Debug.Print ("Angle: {0}"' degreeAngle);  	Debug.Print ("Shift: {0}"' fillGrid.Shift);  	var pen = new Pen (System.Drawing.Color.Black) {  		Width = 1f / matrixScale  	};  	float dashLength = 1;  	var segments = fillGrid.GetSegments ();  	if (segments.Count > 0) {  		pen.DashPattern = segments.Select (Convert.ToSingle).ToArray ();  		Debug.Print ("\tSegments:");  		foreach (var segment in segments) {  			Debug.Print ("\t\t{0}"' segment);  		}  		dashLength = pen.DashPattern.Sum ();  	}  	g.ResetTransform ();  	var rotateMatrix = new Matrix ();  	rotateMatrix.Rotate (degreeAngle);  	var matrix = new Matrix (1' 0' 0' -1' centerX' centerY);  	//-1 reflects about x-axis  	matrix.Scale (matrixScale' matrixScale);  	matrix.Translate ((float)fillGrid.Origin.U' (float)fillGrid.Origin.V);  	var backMatrix = matrix.Clone ();  	backMatrix.Multiply (rotateMatrix);  	matrix.Multiply (rotateMatrix);  	var offset = (-10) * dashLength;  	matrix.Translate (offset' 0);  	backMatrix.Translate (offset' 0);  	Debug.Print ("Offset: {0}"' offset);  	bool moving_forward = true;  	bool moving_back = true;  	int safety = 500;  	double alternator = 0;  	while (moving_forward || moving_back)// draw segments shifting and offsetting each time  	 {  		Debug.Write ("*");  		var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  		if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  			g.Transform = matrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_forward = false;  			Debug.Print ("\n----> Matrix does not intersect view");  		}  		if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  			g.Transform = backMatrix;  			g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  		}  		else {  			moving_back = false;  			Debug.Print ("\n----> Back matrix does not intersect view");  		}  		if (safety == 0) {  			Debug.Print ("\n--------> Safety limit exceeded");  			break;  		}  		else  			--safety;  		matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  		backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  		alternator += fillGrid.Shift;  		if (Math.Abs (alternator) > Math.Abs (offset)) {  			Debug.Print ("\n----> Alternating");  			matrix.Translate (offset' 0);  			backMatrix.Translate (offset' 0);  			alternator = 0d;  		}  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: Debug.Print (new string ('-'' 50));  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: while (moving_forward || moving_back)// draw segments shifting and offsetting each time   {  	Debug.Write ("*");  	var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  	if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  		g.Transform = matrix;  		g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  	}  	else {  		moving_forward = false;  		Debug.Print ("\n----> Matrix does not intersect view");  	}  	if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  		g.Transform = backMatrix;  		g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  	}  	else {  		moving_back = false;  		Debug.Print ("\n----> Back matrix does not intersect view");  	}  	if (safety == 0) {  		Debug.Print ("\n--------> Safety limit exceeded");  		break;  	}  	else  		--safety;  	matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  	backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  	alternator += fillGrid.Shift;  	if (Math.Abs (alternator) > Math.Abs (offset)) {  		Debug.Print ("\n----> Alternating");  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		alternator = 0d;  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: while (moving_forward || moving_back)// draw segments shifting and offsetting each time   {  	Debug.Write ("*");  	var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  	if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  		g.Transform = matrix;  		g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  	}  	else {  		moving_forward = false;  		Debug.Print ("\n----> Matrix does not intersect view");  	}  	if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  		g.Transform = backMatrix;  		g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  	}  	else {  		moving_back = false;  		Debug.Print ("\n----> Back matrix does not intersect view");  	}  	if (safety == 0) {  		Debug.Print ("\n--------> Safety limit exceeded");  		break;  	}  	else  		--safety;  	matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  	backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  	alternator += fillGrid.Shift;  	if (Math.Abs (alternator) > Math.Abs (offset)) {  		Debug.Print ("\n----> Alternating");  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		alternator = 0d;  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: while (moving_forward || moving_back)// draw segments shifting and offsetting each time   {  	Debug.Write ("*");  	var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  	if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  		g.Transform = matrix;  		g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  	}  	else {  		moving_forward = false;  		Debug.Print ("\n----> Matrix does not intersect view");  	}  	if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  		g.Transform = backMatrix;  		g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  	}  	else {  		moving_back = false;  		Debug.Print ("\n----> Back matrix does not intersect view");  	}  	if (safety == 0) {  		Debug.Print ("\n--------> Safety limit exceeded");  		break;  	}  	else  		--safety;  	matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  	backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  	alternator += fillGrid.Shift;  	if (Math.Abs (alternator) > Math.Abs (offset)) {  		Debug.Print ("\n----> Alternating");  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		alternator = 0d;  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: while (moving_forward || moving_back)// draw segments shifting and offsetting each time   {  	Debug.Write ("*");  	var rectF1 = new RectangleF (-2 / matrixScale' -2 / matrixScale' 4 / matrixScale' 4 / matrixScale);  	if (moving_forward && LineIntersectsRect (matrix' viewRect)) {  		g.Transform = matrix;  		g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  	}  	else {  		moving_forward = false;  		Debug.Print ("\n----> Matrix does not intersect view");  	}  	if (moving_back && LineIntersectsRect (backMatrix' viewRect)) {  		g.Transform = backMatrix;  		g.DrawLine (pen' new PointF (0' 0)' new PointF (LENGTH' 0));  	}  	else {  		moving_back = false;  		Debug.Print ("\n----> Back matrix does not intersect view");  	}  	if (safety == 0) {  		Debug.Print ("\n--------> Safety limit exceeded");  		break;  	}  	else  		--safety;  	matrix.Translate ((float)fillGrid.Shift' (float)fillGrid.Offset);  	backMatrix.Translate (-(float)fillGrid.Shift' -(float)fillGrid.Offset);  	alternator += fillGrid.Shift;  	if (Math.Abs (alternator) > Math.Abs (offset)) {  		Debug.Print ("\n----> Alternating");  		matrix.Translate (offset' 0);  		backMatrix.Translate (offset' 0);  		alternator = 0d;  	}  }  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,DrawFillPattern,The following statement contains a magic number: Debug.Print (new string ('-'' 50));  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,LineIntersectsRect,The following statement contains a magic number: m.Translate (200' 0);  
Magic Number,AddMaterials.View.Controls,FillPatternViewerControlWpf,C:\repos\jeremytammik_AddMaterials\AddMaterials\View\Controls\FillPatternViewerControlWpf.xaml.cs,RadianToGradus,The following statement contains a magic number: return radian * 180 / Math.PI;  
