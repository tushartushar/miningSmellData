Implementation smell,Namespace,Class,File,Method,Description
Long Method,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The method has 278 lines of code.
Complex Method,ManicDigger.ClientNative,AudioTask,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,DoPlay,Cyclomatic complexity of the method is 9
Complex Method,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,Cyclomatic complexity of the method is 23
Long Parameter List,ManicDigger.ClientNative,AviWriter,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\AviWriter.cs,AVISaveOptions,The method has 5 parameters. Parameters: hwnd' flags' nStreams' ptr_ptr_avi' ao
Long Parameter List,ManicDigger.ClientNative,AviWriter,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\AviWriter.cs,AVIStreamWrite,The method has 8 parameters. Parameters: aviStream' lStart' lSamples' lpBuffer' cbBuffer' dwFlags' dummy1' dummy2
Long Parameter List,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,StringFormat4,The method has 5 parameters. Parameters: format' arg0' arg1' arg2' arg3
Long Parameter List,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,AudioUpdateListener,The method has 6 parameters. Parameters: posX' posY' posZ' orientX' orientY' orientZ
Long Parameter List,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,EnetHostConnect,The method has 5 parameters. Parameters: host' hostName' port' data' channelLimit
Long Parameter List,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,EnetPeerSend,The method has 5 parameters. Parameters: peer' channelID' data' dataLength' flags
Long Parameter List,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,EnetHostInitialize,The method has 6 parameters. Parameters: host' address' peerLimit' channelLimit' incomingBandwidth' outgoingBandwidth
Long Parameter List,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,SetWindowCursor,The method has 6 parameters. Parameters: hotx' hoty' sizex' sizey' imgdata' imgdataLength
Long Identifier,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,,The length of the parameter singlePlayerServerDummyNetwork is 30.
Long Statement,ManicDigger.ClientNative,AudioTask,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,DoPlay,The length of the statement  "					OpenTK.Audio.OpenAL.AL.BufferData(buffer' GetSoundFormat(sample.Channels' sample.BitsPerSample)' sample.Pcm' sample.Pcm.Length' sample.Rate); " is 141.
Long Statement,ManicDigger.ClientNative,AviWriter,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\AviWriter.cs,Open,The length of the statement  "			BitmapData bmpDat = bmp_.LockBits(new Rectangle(0' 0' width' height)' ImageLockMode.ReadOnly' PixelFormat.Format24bppRgb); " is 122.
Long Statement,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,TextSize,The length of the statement  "			textsizes[new TextAndFont() { text = text' size = font.GetFontSize()' family = font.GetFontFamily()' style = font.GetFontStyle() }] = size; " is 139.
Long Statement,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,MessageBoxShowError,The length of the statement  "			System.Windows.Forms.MessageBox.Show(text' caption' System.Windows.Forms.MessageBoxButtons.OK' System.Windows.Forms.MessageBoxIcon.Exclamation); " is 144.
Long Statement,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,LoadTexture,The length of the statement  "					GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.NearestMipmapLinear); " is 123.
Long Statement,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,LoadTexture,The length of the statement  "				GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' linearMag ? (int)TextureMagFilter.Linear : (int)TextureMagFilter.Nearest); " is 154.
Long Statement,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,LoadTexture,The length of the statement  "			BitmapData bmp_data = bmp.LockBits(new Rectangle(0' 0' bmp.Width' bmp.Height)' ImageLockMode.ReadOnly' System.Drawing.Imaging.PixelFormat.Format32bppArgb); " is 155.
Long Statement,ManicDigger.ClientNative,Screenshot,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Screenshot.cs,GrabScreenshot,The length of the statement  "                bmp.LockBits(d_GameWindow.ClientRectangle' System.Drawing.Imaging.ImageLockMode.WriteOnly' System.Drawing.Imaging.PixelFormat.Format24bppRgb); " is 142.
Long Statement,ManicDigger.ClientNative,Screenshot,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Screenshot.cs,GrabScreenshot,The length of the statement  "            GL.ReadPixels(0' 0' d_GameWindow.ClientSize.Width' d_GameWindow.ClientSize.Height' OpenTK.Graphics.OpenGL.PixelFormat.Bgr' PixelType.UnsignedByte' data.Scan0); " is 159.
Long Statement,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,niceFont,The length of the statement  "					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(128' Color.Black))' 0' 0' StringFormat.GenericTypographic); " is 122.
Complex Conditional,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,GetSampleFromArray,The conditional expression  "stream.ReadByte() == 'R'  			    && stream.ReadByte() == 'I'  			    && stream.ReadByte() == 'F'  			    && stream.ReadByte() == 'F'"  is complex.
Complex Conditional,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,IsChecksum,The conditional expression  "(chars[i] < '0' || chars[i] > '9') && (chars[i] < 'a' || chars[i] > 'f')"  is complex.
Empty Catch Block,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,AudioOpenAl,The method has an empty catch block.
Empty Catch Block,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,SetPreferences,The method has an empty catch block.
Empty Catch Block,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,EnetPeerSend,The method has an empty catch block.
Empty Catch Block,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GlGetMaxTextureSize,The method has an empty catch block.
Magic Number,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))  			{  				// RIFF header  				string signature = new string(reader.ReadChars(4));  				if (signature != "RIFF")  					throw new NotSupportedException("Specified stream is not a wave file.");    				int riff_chunck_size = reader.ReadInt32();    				string format = new string(reader.ReadChars(4));  				if (format != "WAVE")  					throw new NotSupportedException("Specified stream is not a wave file.");    				// WAVE header  				string format_signature = new string(reader.ReadChars(4));  				if (format_signature != "fmt ")  					throw new NotSupportedException("Specified wave file is not supported.");    				int format_chunk_size = reader.ReadInt32();  				int audio_format = reader.ReadInt16();  				int num_channels = reader.ReadInt16();  				int sample_rate = reader.ReadInt32();  				int byte_rate = reader.ReadInt32();  				int block_align = reader.ReadInt16();  				int bits_per_sample = reader.ReadInt16();    				string data_signature = new string(reader.ReadChars(4));  				if (data_signature != "data")  					throw new NotSupportedException("Specified wave file is not supported.");    				int data_chunk_size = reader.ReadInt32();    				channels = num_channels;  				bits = bits_per_sample;  				rate = sample_rate;    				return reader.ReadBytes((int)reader.BaseStream.Length);  			}
Magic Number,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))  			{  				// RIFF header  				string signature = new string(reader.ReadChars(4));  				if (signature != "RIFF")  					throw new NotSupportedException("Specified stream is not a wave file.");    				int riff_chunck_size = reader.ReadInt32();    				string format = new string(reader.ReadChars(4));  				if (format != "WAVE")  					throw new NotSupportedException("Specified stream is not a wave file.");    				// WAVE header  				string format_signature = new string(reader.ReadChars(4));  				if (format_signature != "fmt ")  					throw new NotSupportedException("Specified wave file is not supported.");    				int format_chunk_size = reader.ReadInt32();  				int audio_format = reader.ReadInt16();  				int num_channels = reader.ReadInt16();  				int sample_rate = reader.ReadInt32();  				int byte_rate = reader.ReadInt32();  				int block_align = reader.ReadInt16();  				int bits_per_sample = reader.ReadInt16();    				string data_signature = new string(reader.ReadChars(4));  				if (data_signature != "data")  					throw new NotSupportedException("Specified wave file is not supported.");    				int data_chunk_size = reader.ReadInt32();    				channels = num_channels;  				bits = bits_per_sample;  				rate = sample_rate;    				return reader.ReadBytes((int)reader.BaseStream.Length);  			}
Magic Number,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))  			{  				// RIFF header  				string signature = new string(reader.ReadChars(4));  				if (signature != "RIFF")  					throw new NotSupportedException("Specified stream is not a wave file.");    				int riff_chunck_size = reader.ReadInt32();    				string format = new string(reader.ReadChars(4));  				if (format != "WAVE")  					throw new NotSupportedException("Specified stream is not a wave file.");    				// WAVE header  				string format_signature = new string(reader.ReadChars(4));  				if (format_signature != "fmt ")  					throw new NotSupportedException("Specified wave file is not supported.");    				int format_chunk_size = reader.ReadInt32();  				int audio_format = reader.ReadInt16();  				int num_channels = reader.ReadInt16();  				int sample_rate = reader.ReadInt32();  				int byte_rate = reader.ReadInt32();  				int block_align = reader.ReadInt16();  				int bits_per_sample = reader.ReadInt16();    				string data_signature = new string(reader.ReadChars(4));  				if (data_signature != "data")  					throw new NotSupportedException("Specified wave file is not supported.");    				int data_chunk_size = reader.ReadInt32();    				channels = num_channels;  				bits = bits_per_sample;  				rate = sample_rate;    				return reader.ReadBytes((int)reader.BaseStream.Length);  			}
Magic Number,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,LoadWave,The following statement contains a magic number: using (BinaryReader reader = new BinaryReader(stream))  			{  				// RIFF header  				string signature = new string(reader.ReadChars(4));  				if (signature != "RIFF")  					throw new NotSupportedException("Specified stream is not a wave file.");    				int riff_chunck_size = reader.ReadInt32();    				string format = new string(reader.ReadChars(4));  				if (format != "WAVE")  					throw new NotSupportedException("Specified stream is not a wave file.");    				// WAVE header  				string format_signature = new string(reader.ReadChars(4));  				if (format_signature != "fmt ")  					throw new NotSupportedException("Specified wave file is not supported.");    				int format_chunk_size = reader.ReadInt32();  				int audio_format = reader.ReadInt16();  				int num_channels = reader.ReadInt16();  				int sample_rate = reader.ReadInt32();  				int byte_rate = reader.ReadInt32();  				int block_align = reader.ReadInt16();  				int bits_per_sample = reader.ReadInt16();    				string data_signature = new string(reader.ReadChars(4));  				if (data_signature != "data")  					throw new NotSupportedException("Specified wave file is not supported.");    				int data_chunk_size = reader.ReadInt32();    				channels = num_channels;  				bits = bits_per_sample;  				rate = sample_rate;    				return reader.ReadBytes((int)reader.BaseStream.Length);  			}
Magic Number,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,GetSoundFormat,The following statement contains a magic number: switch (channels)  			{  				case 1:  					return bits == 8 ? OpenTK.Audio.OpenAL.ALFormat.Mono8 : OpenTK.Audio.OpenAL.ALFormat.Mono16;  				case 2:  					return bits == 8 ? OpenTK.Audio.OpenAL.ALFormat.Stereo8 : OpenTK.Audio.OpenAL.ALFormat.Stereo16;  				default:  					throw new NotSupportedException("The specified sound format is not supported.");  			}
Magic Number,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,GetSoundFormat,The following statement contains a magic number: switch (channels)  			{  				case 1:  					return bits == 8 ? OpenTK.Audio.OpenAL.ALFormat.Mono8 : OpenTK.Audio.OpenAL.ALFormat.Mono16;  				case 2:  					return bits == 8 ? OpenTK.Audio.OpenAL.ALFormat.Stereo8 : OpenTK.Audio.OpenAL.ALFormat.Stereo16;  				default:  					throw new NotSupportedException("The specified sound format is not supported.");  			}
Magic Number,ManicDigger.ClientNative,AudioOpenAl,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,GetSoundFormat,The following statement contains a magic number: switch (channels)  			{  				case 1:  					return bits == 8 ? OpenTK.Audio.OpenAL.ALFormat.Mono8 : OpenTK.Audio.OpenAL.ALFormat.Mono16;  				case 2:  					return bits == 8 ? OpenTK.Audio.OpenAL.ALFormat.Stereo8 : OpenTK.Audio.OpenAL.ALFormat.Stereo16;  				default:  					throw new NotSupportedException("The specified sound format is not supported.");  			}
Magic Number,ManicDigger.ClientNative,AudioTask,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\Audio.cs,DoPlay,The following statement contains a magic number: {  					//Trace.WriteLine("Testing WaveReader({0}).ReadToEnd()"' filename);    					int buffer = OpenTK.Audio.OpenAL.AL.GenBuffer();    					OpenTK.Audio.OpenAL.AL.BufferData(buffer' GetSoundFormat(sample.Channels' sample.BitsPerSample)' sample.Pcm' sample.Pcm.Length' sample.Rate);  					//audiofiles[filename]=buffer;    					OpenTK.Audio.OpenAL.AL.DistanceModel(OpenTK.Audio.OpenAL.ALDistanceModel.InverseDistance);  					OpenTK.Audio.OpenAL.AL.Source(source' OpenTK.Audio.OpenAL.ALSourcef.RolloffFactor' 0.3f);  					OpenTK.Audio.OpenAL.AL.Source(source' OpenTK.Audio.OpenAL.ALSourcef.ReferenceDistance' 1);  					OpenTK.Audio.OpenAL.AL.Source(source' OpenTK.Audio.OpenAL.ALSourcef.MaxDistance' (int)(64 * 1));  					OpenTK.Audio.OpenAL.AL.Source(source' OpenTK.Audio.OpenAL.ALSourcei.Buffer' buffer);  					OpenTK.Audio.OpenAL.AL.SourcePlay(source);    					// Query the source to find out when it stops playing.  					for (; ;)  					{  						OpenTK.Audio.OpenAL.AL.GetSource(source' OpenTK.Audio.OpenAL.ALGetSourcei.SourceState' out state);  						if ((!loop) && (OpenTK.Audio.OpenAL.ALSourceState)state != OpenTK.Audio.OpenAL.ALSourceState.Playing)  						{  							break;  						}  						if (stop)  						{  							break;  						}  						if (gameexit.GetExit())  						{  							break;  						}  						if (loop)  						{  							if (state == (int)OpenTK.Audio.OpenAL.ALSourceState.Playing && (!shouldplay))  							{  								OpenTK.Audio.OpenAL.AL.SourcePause(source);  							}  							if (state != (int)OpenTK.Audio.OpenAL.ALSourceState.Playing && (shouldplay))  							{  								if (restart)  								{  									OpenTK.Audio.OpenAL.AL.SourceRewind(source);  									restart = false;  								}  								OpenTK.Audio.OpenAL.AL.SourcePlay(source);  							}  						}                            						OpenTK.Audio.OpenAL.AL.Source(source' OpenTK.Audio.OpenAL.ALSource3f.Position' position.X' position.Y' position.Z);             						/*                          if (stop)                          {                              AL.SourcePause(source);                              resume = false;                          }                          if (resume)                          {                              AL.SourcePlay(source);                              resume = false;                          }                          */  						Thread.Sleep(1);  					}  					Finished = true;  					OpenTK.Audio.OpenAL.AL.SourceStop(source);  					OpenTK.Audio.OpenAL.AL.DeleteSource(source);  					OpenTK.Audio.OpenAL.AL.DeleteBuffer(buffer);  				}
Magic Number,ManicDigger.ClientNative,AviWriter,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\AviWriter.cs,Open,The following statement contains a magic number: int hr = AVIFileOpenW(ref pfile_' fileName' 4097 /* OF_WRITE | OF_CREATE (winbase.h) */' 0);
Magic Number,ManicDigger.ClientNative,AviWriter,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\AviWriter.cs,SetOptions,The following statement contains a magic number: bi.biSize = 40;
Magic Number,ManicDigger.ClientNative,AviWriter,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\AviWriter.cs,SetOptions,The following statement contains a magic number: bi.biBitCount = 24;
Magic Number,ManicDigger.ClientNative,AviWriter,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\AviWriter.cs,SetOptions,The following statement contains a magic number: hr = AVIStreamSetFormat(psCompressed_' 0' ref bi' 40);
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,OggDecoder,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\OggDecoder.cs,OggToWav,The following statement contains a magic number: while (true) //This causes an OutOfMemory exception at line 173  			{ // we repeat if the bitstream is chained  				int eos = 0;    				// grab some data at the head of the stream.  We want the first page  				// (which is guaranteed to be small and only contain the Vorbis  				// stream initial header) We need the first page to get the stream  				// serialno.    				// submit a 4k block to libvorbis' Ogg layer  				int index = oy.buffer(4096);  				buffer = oy.data;  				try  				{  					bytes = input.Read(buffer' index' 4096);  				}  				catch (Exception e)  				{  					s_err.WriteLine(e);  				}  				oy.wrote(bytes);    				// Get the first page.  				if (oy.pageout(og) != 1)  				{  					// have we simply run out of data?  If so' we're done.  					if (bytes < 4096)  						break;    					// error case.  Must not be Vorbis data  					s_err.WriteLine("Input does not appear to be an Ogg bitstream.");  				}    				// Get the serial number and set up the rest of decode.  				// serialno first; use it to set up a logical stream  				os.init(og.serialno());    				// extract the initial header from the first page and verify that the  				// Ogg bitstream is in fact Vorbis data    				// I handle the initial header first instead of just having the code  				// read all three Vorbis headers at once because reading the initial  				// header is an easy way to identify a Vorbis bitstream and it's  				// useful to see that functionality seperated out.    				vi.init();  				vc.init();  				if (os.pagein(og) < 0)  				{  					// error; stream version mismatch perhaps  					s_err.WriteLine("Error reading first page of Ogg bitstream data.");  				}    				if (os.packetout(op) != 1)  				{  					// no page? must not be vorbis  					s_err.WriteLine("Error reading initial header packet.");  				}    				if (vi.synthesis_headerin(vc' op) < 0)  				{  					// error case; not a vorbis header  					s_err.WriteLine("This Ogg bitstream does not contain Vorbis audio data.");  				}    				// At this point' we're sure we're Vorbis.  We've set up the logical  				// (Ogg) bitstream decoder.  Get the comment and codebook headers and  				// set up the Vorbis decoder    				// The next two packets in order are the comment and codebook headers.  				// They're likely large and may span multiple pages.  Thus we reead  				// and submit data until we get our two pacakets' watching that no  				// pages are missing.  If a page is missing' error out; losing a  				// header page is the only place where missing data is fatal. */    				int i = 0;    				while (i < 2)  				{  					while (i < 2)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // Need more data  						// Don't complain about missing or corrupt data yet.  We'll  						// catch it at the packet output phase    						if (result == 1)  						{  							os.pagein(og); // we can ignore any errors here  							// as they'll also become apparent  							// at packetout  							while (i < 2)  							{  								result = os.packetout(op);  								if (result == 0)  									break;  								if (result == -1)  								{  									// Uh oh; data at some point was corrupted or missing!  									// We can't tolerate that in a header.  Die.  									s_err.WriteLine("Corrupt secondary header.  Exiting.");  								}  								vi.synthesis_headerin(vc' op);  								i++;  							}  						}  					}  					// no harm in not checking before adding more  					index = oy.buffer(4096);  					buffer = oy.data;  					try  					{  						bytes = input.Read(buffer' index' 4096);  					}  					catch (Exception e)  					{  						s_err.WriteLine(e);  					}  					if (bytes == 0 && i < 2)  					{  						s_err.WriteLine("End of file before finding all Vorbis headers!");  					}  					oy.wrote(bytes);  				}    				// Throw the comments plus a few lines about the bitstream we're  				// decoding  				{  					byte[][] ptr = vc.user_comments;  					for (int j = 0; j < vc.user_comments.Length; j++)  					{  						if (ptr[j] == null)  							break;  						s_err.WriteLine(vc.getComment(j));  					}  					s_err.WriteLine("\nBitstream is " + vi.channels + " channel' " + vi.rate + "Hz");  					s_err.WriteLine("Encoded by: " + vc.getVendor() + "\n");  					sample.Channels = vi.channels;  					sample.Rate = vi.rate;  				}    				convsize = 4096 / vi.channels;    				// OK' got and parsed all three headers. Initialize the Vorbis  				//  packet->PCM decoder.  				vd.synthesis_init(vi); // central decode state  				vb.init(vd);           // local state for most of the decode    				// so multiple block decodes can  				// proceed in parallel.  We could init  				// multiple vorbis_block structures  				// for vd here    				float[][][] _pcm = new float[1][][];  				int[] _index = new int[vi.channels];  				// The rest is just a straight decode loop until end of stream  				while (eos == 0)  				{  					while (eos == 0)  					{    						int result = oy.pageout(og);  						if (result == 0)  							break; // need more data  						if (result == -1)  						{ // missing or corrupt data at this page position  							s_err.WriteLine("Corrupt or missing data in bitstream; continuing...");  						}  						else  						{  							os.pagein(og); // can safely ignore errors at  							// this point  							while (true)  							{  								result = os.packetout(op);    								if (result == 0)  									break; // need more data  								if (result == -1)  								{ // missing or corrupt data at this page position  									// no reason to complain; already complained above  								}  								else  								{  									// we have a packet.  Decode it  									int samples;  									if (vb.synthesis(op) == 0)  									{ // test for success!  										vd.synthesis_blockin(vb);  									}    									// **pcm is a multichannel float vector.  In stereo' for  									// example' pcm[0] is left' and pcm[1] is right.  samples is  									// the size of each channel.  Convert the float values  									// (-1.<=range<=1.) to whatever PCM format and write it out    									while ((samples = vd.synthesis_pcmout(_pcm' _index)) > 0)  									{  										float[][] pcm = _pcm[0];  										bool clipflag = false;  										int bout = (samples < convsize ? samples : convsize);    										// convert floats to 16 bit signed ints (host order) and  										// interleave  										for (i = 0; i < vi.channels; i++)  										{  											int ptr = i * 2;  											//int ptr=i;  											int mono = _index[i];  											for (int j = 0; j < bout; j++)  											{  												int val = (int)(pcm[i][mono + j] * 32767.0);  												//        short val=(short)(pcm[i][mono+j]*32767.);  												//        int val=(int)Math.round(pcm[i][mono+j]*32767.);  												// might as well guard against clipping  												if (val > 32767)  												{  													val = 32767;  													clipflag = true;  												}  												if (val < -32768)  												{  													val = -32768;  													clipflag = true;  												}  												if (val < 0)  													val = val | 0x8000;  												convbuffer[ptr] = (byte)(val);  												convbuffer[ptr + 1] = (byte)((uint)val >> 8);  												ptr += 2 * (vi.channels);  											}  										}    										if (clipflag)  										{  											//s_err.WriteLine("Clipping in frame "+vd.sequence);  										}    										output.Write(convbuffer' 0' 2 * vi.channels * bout);    										vd.synthesis_read(bout); // tell libvorbis how  										// many samples we  										// actually consumed  									}  								}  							}  							if (og.eos() != 0)  								eos = 1;  						}  					}  					if (eos == 0)  					{  						index = oy.buffer(4096);  						buffer = oy.data;  						try  						{  							bytes = input.Read(buffer' index' 4096);  						}  						catch (Exception e)  						{  							s_err.WriteLine(e);  						}  						oy.wrote(bytes);  						if (bytes == 0)  							eos = 1;  					}  				}    				// clean up this logical bitstream; before exit we see if we're  				// followed by another [chained]    				os.clear();    				// ogg_page and ogg_packet structs always point to storage in  				// libvorbis.  They're never freed or manipulated directly    				vb.clear();  				vd.clear();  				vi.clear();  // must be called last  				break; //Necessary for this not to crash  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GamePlatformNative,The following statement contains a magic number: System.Threading.ThreadPool.SetMinThreads(32' 32);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GamePlatformNative,The following statement contains a magic number: System.Threading.ThreadPool.SetMinThreads(32' 32);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GamePlatformNative,The following statement contains a magic number: System.Threading.ThreadPool.SetMaxThreads(128' 128);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GamePlatformNative,The following statement contains a magic number: System.Threading.ThreadPool.SetMaxThreads(128' 128);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DoUploadData,The following statement contains a magic number: try  			{  				HttpWebRequest request = (HttpWebRequest)WebRequest.Create(d.url);  				request.Method = "POST";  				request.Timeout = 15000; // 15s timeout  				request.ContentType = "application/x-www-form-urlencoded";  				request.CachePolicy = new System.Net.Cache.RequestCachePolicy(System.Net.Cache.RequestCacheLevel.NoCacheNoStore);    				request.ContentLength = d.dataLength;    				System.Net.ServicePointManager.Expect100Continue = false; // fixes lighthttpd 417 error    				using (Stream requestStream = request.GetRequestStream())  				{  					requestStream.Write(d.data' 0' d.dataLength);  					requestStream.Flush();  				}  				WebResponse response_ = request.GetResponse();    				MemoryStream m = new MemoryStream();  				using (Stream s = response_.GetResponseStream())  				{  					CopyTo(s' m);  				}  				d.response.SetValue(m.ToArray());  				d.response.SetValueLength(d.response.GetValue().Length);  				d.response.SetDone(true);    				request.Abort();    			}  			catch  			{  				d.response.SetError(true);  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,CopyTo,The following statement contains a magic number: byte[] buffer = new byte[16384];
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,IsChecksum,The following statement contains a magic number: if (checksum.Length != 32)  			{  				return false;  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GetDisplayResolutions,The following statement contains a magic number: if (resolutions == null)  			{  				resolutions = new DisplayResolutionCi[1024];  				foreach (var r in DisplayDevice.Default.AvailableResolutions)  				{  					if (r.Width < 800 || r.Height < 600 || r.BitsPerPixel < 16)  					{  						continue;  					}  					DisplayResolutionCi r2 = new DisplayResolutionCi();  					r2.Width = r.Width;  					r2.Height = r.Height;  					r2.BitsPerPixel = r.BitsPerPixel;  					r2.RefreshRate = r.RefreshRate;  					resolutions[resolutionsCount++] = r2;  				}  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GetDisplayResolutions,The following statement contains a magic number: if (resolutions == null)  			{  				resolutions = new DisplayResolutionCi[1024];  				foreach (var r in DisplayDevice.Default.AvailableResolutions)  				{  					if (r.Width < 800 || r.Height < 600 || r.BitsPerPixel < 16)  					{  						continue;  					}  					DisplayResolutionCi r2 = new DisplayResolutionCi();  					r2.Width = r.Width;  					r2.Height = r.Height;  					r2.BitsPerPixel = r.BitsPerPixel;  					r2.RefreshRate = r.RefreshRate;  					resolutions[resolutionsCount++] = r2;  				}  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GetDisplayResolutions,The following statement contains a magic number: if (resolutions == null)  			{  				resolutions = new DisplayResolutionCi[1024];  				foreach (var r in DisplayDevice.Default.AvailableResolutions)  				{  					if (r.Width < 800 || r.Height < 600 || r.BitsPerPixel < 16)  					{  						continue;  					}  					DisplayResolutionCi r2 = new DisplayResolutionCi();  					r2.Width = r.Width;  					r2.Height = r.Height;  					r2.BitsPerPixel = r.BitsPerPixel;  					r2.RefreshRate = r.RefreshRate;  					resolutions[resolutionsCount++] = r2;  				}  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GetDisplayResolutions,The following statement contains a magic number: if (resolutions == null)  			{  				resolutions = new DisplayResolutionCi[1024];  				foreach (var r in DisplayDevice.Default.AvailableResolutions)  				{  					if (r.Width < 800 || r.Height < 600 || r.BitsPerPixel < 16)  					{  						continue;  					}  					DisplayResolutionCi r2 = new DisplayResolutionCi();  					r2.Width = r.Width;  					r2.Height = r.Height;  					r2.BitsPerPixel = r.BitsPerPixel;  					r2.RefreshRate = r.RefreshRate;  					resolutions[resolutionsCount++] = r2;  				}  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: if (dataRgba == null)  			{  				for (int i = 0; i < data.GetRgbaCount(); i++)  				{  					rgba[i] = 255;  				}  			}  			else  			{  				for (int i = 0; i < data.GetRgbaCount(); i++)  				{  					rgba[i] = dataRgba[i];  				}  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 3 * 4' xyz);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 3 * 4' xyz);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: GL.VertexPointer(3' VertexPointerType.Float' 3 * 4' xyz);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: GL.ColorPointer(4' ColorPointerType.UnsignedByte' 4 * 1' rgba);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: GL.ColorPointer(4' ColorPointerType.UnsignedByte' 4 * 1' rgba);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: GL.TexCoordPointer(2' TexCoordPointerType.Float' 2 * 4' uv);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: GL.TexCoordPointer(2' TexCoordPointerType.Float' 2 * 4' uv);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModelData,The following statement contains a magic number: GL.TexCoordPointer(2' TexCoordPointerType.Float' 2 * 4' uv);
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,DrawModels,The following statement contains a magic number: if (lists.Length < count)  			{  				lists = new int[count * 2];  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,LoadTexture,The following statement contains a magic number: if (!ENABLE_MIPMAPS)  			{  				GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Nearest);  				GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' (int)TextureMagFilter.Nearest);  			}  			else  			{  				//GL.GenerateMipmap(GenerateMipmapTarget.Texture2D); //DOES NOT WORK ON ATI GRAPHIC CARDS  				GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.GenerateMipmap' 1); //DOES NOT WORK ON ???  				int[] MipMapCount = new int[1];  				GL.GetTexParameter(TextureTarget.Texture2D' GetTextureParameter.TextureMaxLevel' out MipMapCount[0]);  				if (MipMapCount[0] == 0)  				{  					GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.Nearest);  				}  				else  				{  					GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMinFilter' (int)TextureMinFilter.NearestMipmapLinear);  				}  				GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMagFilter' linearMag ? (int)TextureMagFilter.Linear : (int)TextureMagFilter.Nearest);  				GL.TexParameter(TextureTarget.Texture2D' TextureParameterName.TextureMaxLevel' 4);  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GlFogFogColor,The following statement contains a magic number: float[] fogColor = new[] {  				(float)r / 255'  				(float)g / 255'  				(float)b / 255'  				(float)a / 255  			};
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GlFogFogColor,The following statement contains a magic number: float[] fogColor = new[] {  				(float)r / 255'  				(float)g / 255'  				(float)b / 255'  				(float)a / 255  			};
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GlFogFogColor,The following statement contains a magic number: float[] fogColor = new[] {  				(float)r / 255'  				(float)g / 255'  				(float)b / 255'  				(float)a / 255  			};
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GlFogFogColor,The following statement contains a magic number: float[] fogColor = new[] {  				(float)r / 255'  				(float)g / 255'  				(float)b / 255'  				(float)a / 255  			};
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,GlGetMaxTextureSize,The following statement contains a magic number: int size = 1024;
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,SetWindowCursor,The following statement contains a magic number: try  			{  				Bitmap bmp = new Bitmap(new MemoryStream(imgdata' 0' imgdataLength)); //new Bitmap("data/local/gui/mousecursor.png");  				if (bmp.Width > 32 || bmp.Height > 32)  				{  					// Limit cursor size to 32x32  					return;  				}  				// Convert to required 0xBBGGRRAA format - see https://github.com/opentk/opentk/pull/107#issuecomment-41771702  				int i = 0;  				byte[] data = new byte[4 * bmp.Width * bmp.Height];  				for (int y = 0; y < bmp.Width; y++)  				{  					for (int x = 0; x < bmp.Height; x++)  					{  						Color color = bmp.GetPixel(x' y);  						data[i] = color.B;  						data[i + 1] = color.G;  						data[i + 2] = color.R;  						data[i + 3] = color.A;  						i += 4;  					}  				}  				bmp.Dispose();  				window.Cursor = new MouseCursor(hotx' hoty' sizex' sizey' data);  			}  			catch  			{  				RestoreWindowCursor();  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,SetWindowCursor,The following statement contains a magic number: try  			{  				Bitmap bmp = new Bitmap(new MemoryStream(imgdata' 0' imgdataLength)); //new Bitmap("data/local/gui/mousecursor.png");  				if (bmp.Width > 32 || bmp.Height > 32)  				{  					// Limit cursor size to 32x32  					return;  				}  				// Convert to required 0xBBGGRRAA format - see https://github.com/opentk/opentk/pull/107#issuecomment-41771702  				int i = 0;  				byte[] data = new byte[4 * bmp.Width * bmp.Height];  				for (int y = 0; y < bmp.Width; y++)  				{  					for (int x = 0; x < bmp.Height; x++)  					{  						Color color = bmp.GetPixel(x' y);  						data[i] = color.B;  						data[i + 1] = color.G;  						data[i + 2] = color.R;  						data[i + 3] = color.A;  						i += 4;  					}  				}  				bmp.Dispose();  				window.Cursor = new MouseCursor(hotx' hoty' sizex' sizey' data);  			}  			catch  			{  				RestoreWindowCursor();  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,SetWindowCursor,The following statement contains a magic number: try  			{  				Bitmap bmp = new Bitmap(new MemoryStream(imgdata' 0' imgdataLength)); //new Bitmap("data/local/gui/mousecursor.png");  				if (bmp.Width > 32 || bmp.Height > 32)  				{  					// Limit cursor size to 32x32  					return;  				}  				// Convert to required 0xBBGGRRAA format - see https://github.com/opentk/opentk/pull/107#issuecomment-41771702  				int i = 0;  				byte[] data = new byte[4 * bmp.Width * bmp.Height];  				for (int y = 0; y < bmp.Width; y++)  				{  					for (int x = 0; x < bmp.Height; x++)  					{  						Color color = bmp.GetPixel(x' y);  						data[i] = color.B;  						data[i + 1] = color.G;  						data[i + 2] = color.R;  						data[i + 3] = color.A;  						i += 4;  					}  				}  				bmp.Dispose();  				window.Cursor = new MouseCursor(hotx' hoty' sizex' sizey' data);  			}  			catch  			{  				RestoreWindowCursor();  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,SetWindowCursor,The following statement contains a magic number: try  			{  				Bitmap bmp = new Bitmap(new MemoryStream(imgdata' 0' imgdataLength)); //new Bitmap("data/local/gui/mousecursor.png");  				if (bmp.Width > 32 || bmp.Height > 32)  				{  					// Limit cursor size to 32x32  					return;  				}  				// Convert to required 0xBBGGRRAA format - see https://github.com/opentk/opentk/pull/107#issuecomment-41771702  				int i = 0;  				byte[] data = new byte[4 * bmp.Width * bmp.Height];  				for (int y = 0; y < bmp.Width; y++)  				{  					for (int x = 0; x < bmp.Height; x++)  					{  						Color color = bmp.GetPixel(x' y);  						data[i] = color.B;  						data[i + 1] = color.G;  						data[i + 2] = color.R;  						data[i + 3] = color.A;  						i += 4;  					}  				}  				bmp.Dispose();  				window.Cursor = new MouseCursor(hotx' hoty' sizex' sizey' data);  			}  			catch  			{  				RestoreWindowCursor();  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,SetWindowCursor,The following statement contains a magic number: try  			{  				Bitmap bmp = new Bitmap(new MemoryStream(imgdata' 0' imgdataLength)); //new Bitmap("data/local/gui/mousecursor.png");  				if (bmp.Width > 32 || bmp.Height > 32)  				{  					// Limit cursor size to 32x32  					return;  				}  				// Convert to required 0xBBGGRRAA format - see https://github.com/opentk/opentk/pull/107#issuecomment-41771702  				int i = 0;  				byte[] data = new byte[4 * bmp.Width * bmp.Height];  				for (int y = 0; y < bmp.Width; y++)  				{  					for (int x = 0; x < bmp.Height; x++)  					{  						Color color = bmp.GetPixel(x' y);  						data[i] = color.B;  						data[i + 1] = color.G;  						data[i + 2] = color.R;  						data[i + 3] = color.A;  						i += 4;  					}  				}  				bmp.Dispose();  				window.Cursor = new MouseCursor(hotx' hoty' sizex' sizey' data);  			}  			catch  			{  				RestoreWindowCursor();  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,SetWindowCursor,The following statement contains a magic number: try  			{  				Bitmap bmp = new Bitmap(new MemoryStream(imgdata' 0' imgdataLength)); //new Bitmap("data/local/gui/mousecursor.png");  				if (bmp.Width > 32 || bmp.Height > 32)  				{  					// Limit cursor size to 32x32  					return;  				}  				// Convert to required 0xBBGGRRAA format - see https://github.com/opentk/opentk/pull/107#issuecomment-41771702  				int i = 0;  				byte[] data = new byte[4 * bmp.Width * bmp.Height];  				for (int y = 0; y < bmp.Width; y++)  				{  					for (int x = 0; x < bmp.Height; x++)  					{  						Color color = bmp.GetPixel(x' y);  						data[i] = color.B;  						data[i + 1] = color.G;  						data[i + 2] = color.R;  						data[i + 3] = color.A;  						i += 4;  					}  				}  				bmp.Dispose();  				window.Cursor = new MouseCursor(hotx' hoty' sizex' sizey' data);  			}  			catch  			{  				RestoreWindowCursor();  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,UpdateMousePosition,The following statement contains a magic number: if (mousePointerLocked)  			{  				/*  				* Windows: OK  				* Cursor hides properly  				* Cursor is trapped inside window  				* Centering works  				*  				* Linux: Needs workaround  				* Cursor hides properly  				* Cursor is trapped inside window  				* Centering broken  				*  				* Mac OS X: OK  				* Cursor hides properly (although visible when doing Skype screencast)  				* Centering works  				* Opening "mission control" by gesture does not free cursor  				*/    				int centerx = window.Bounds.Left + (window.Bounds.Width / 2);  				int centery = window.Bounds.Top + (window.Bounds.Height / 2);    				// Setting cursor position this way works on Windows and Mac  				Mouse.SetPosition(centerx' centery);  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,UpdateMousePosition,The following statement contains a magic number: if (mousePointerLocked)  			{  				/*  				* Windows: OK  				* Cursor hides properly  				* Cursor is trapped inside window  				* Centering works  				*  				* Linux: Needs workaround  				* Cursor hides properly  				* Cursor is trapped inside window  				* Centering broken  				*  				* Mac OS X: OK  				* Cursor hides properly (although visible when doing Skype screencast)  				* Centering works  				* Opening "mission control" by gesture does not free cursor  				*/    				int centerx = window.Bounds.Left + (window.Bounds.Width / 2);  				int centery = window.Bounds.Top + (window.Bounds.Height / 2);    				// Setting cursor position this way works on Windows and Mac  				Mouse.SetPosition(centerx' centery);  			}
Magic Number,ManicDigger.ClientNative,GamePlatformNative,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\PlatformNative.cs,Mouse_WheelChanged,The following statement contains a magic number: if (currentTick - lastMouseWheelTick < 10)  			{  				// Limit processing of MouseWheel events  				// This is due to a bug in OpenTK that fires two events on Windows 10  				// Documented in issue #207  				return;  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,defaultFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					StringFormat format = StringFormat.GenericTypographic;    					g2.FillRectangle(new SolidBrush(Color.FromArgb(textalpha' 0' 0' 0))' 0' 0' size.Width' size.Height);  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;  					Rectangle rect = new Rectangle() { X = 0' Y = 0 };  					using (GraphicsPath path = GetStringPath(t.GetText()' rect' font' format))  					{  						g2.SmoothingMode = SmoothingMode.AntiAlias;  						RectangleF off = rect;  						off.Offset(2' 2);  						using (GraphicsPath offPath = GetStringPath(t.GetText()' off' font' format))  						{  							Brush b = new SolidBrush(Color.FromArgb(100' 0' 0' 0));  							g2.FillPath(b' offPath);  							b.Dispose();  						}  						g2.FillPath(new SolidBrush(Color.FromArgb(t.GetColor()))' path);  						g2.DrawPath(Pens.Black' path);  					}  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,defaultFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					StringFormat format = StringFormat.GenericTypographic;    					g2.FillRectangle(new SolidBrush(Color.FromArgb(textalpha' 0' 0' 0))' 0' 0' size.Width' size.Height);  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;  					Rectangle rect = new Rectangle() { X = 0' Y = 0 };  					using (GraphicsPath path = GetStringPath(t.GetText()' rect' font' format))  					{  						g2.SmoothingMode = SmoothingMode.AntiAlias;  						RectangleF off = rect;  						off.Offset(2' 2);  						using (GraphicsPath offPath = GetStringPath(t.GetText()' off' font' format))  						{  							Brush b = new SolidBrush(Color.FromArgb(100' 0' 0' 0));  							g2.FillPath(b' offPath);  							b.Dispose();  						}  						g2.FillPath(new SolidBrush(Color.FromArgb(t.GetColor()))' path);  						g2.DrawPath(Pens.Black' path);  					}  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,defaultFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					StringFormat format = StringFormat.GenericTypographic;    					g2.FillRectangle(new SolidBrush(Color.FromArgb(textalpha' 0' 0' 0))' 0' 0' size.Width' size.Height);  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAliasGridFit;  					Rectangle rect = new Rectangle() { X = 0' Y = 0 };  					using (GraphicsPath path = GetStringPath(t.GetText()' rect' font' format))  					{  						g2.SmoothingMode = SmoothingMode.AntiAlias;  						RectangleF off = rect;  						off.Offset(2' 2);  						using (GraphicsPath offPath = GetStringPath(t.GetText()' off' font' format))  						{  							Brush b = new SolidBrush(Color.FromArgb(100' 0' 0' 0));  							g2.FillPath(b' offPath);  							b.Dispose();  						}  						g2.FillPath(new SolidBrush(Color.FromArgb(t.GetColor()))' path);  						g2.DrawPath(Pens.Black' path);  					}  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,niceFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					g2.SmoothingMode = SmoothingMode.AntiAlias;  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  					#if DEBUG // Display measured text sizes  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 0' 255' 0))' 0' 0' (int)size.Width' (int)size.Height);  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 255' 255' 0))' 0' 0' (int)size2.Width-1' (int)size2.Height-1);  					#endif  					// Draw text shadow  					Matrix mx = new Matrix(1f' 0' 0' 1f' 1' 1);  					g2.Transform = mx;  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(128' Color.Black))' 0' 0' StringFormat.GenericTypographic);  					g2.ResetTransform();  					// Draw text  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(t.GetColor()))' 0' 0' StringFormat.GenericTypographic);  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,niceFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					g2.SmoothingMode = SmoothingMode.AntiAlias;  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  					#if DEBUG // Display measured text sizes  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 0' 255' 0))' 0' 0' (int)size.Width' (int)size.Height);  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 255' 255' 0))' 0' 0' (int)size2.Width-1' (int)size2.Height-1);  					#endif  					// Draw text shadow  					Matrix mx = new Matrix(1f' 0' 0' 1f' 1' 1);  					g2.Transform = mx;  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(128' Color.Black))' 0' 0' StringFormat.GenericTypographic);  					g2.ResetTransform();  					// Draw text  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(t.GetColor()))' 0' 0' StringFormat.GenericTypographic);  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,niceFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					g2.SmoothingMode = SmoothingMode.AntiAlias;  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  					#if DEBUG // Display measured text sizes  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 0' 255' 0))' 0' 0' (int)size.Width' (int)size.Height);  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 255' 255' 0))' 0' 0' (int)size2.Width-1' (int)size2.Height-1);  					#endif  					// Draw text shadow  					Matrix mx = new Matrix(1f' 0' 0' 1f' 1' 1);  					g2.Transform = mx;  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(128' Color.Black))' 0' 0' StringFormat.GenericTypographic);  					g2.ResetTransform();  					// Draw text  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(t.GetColor()))' 0' 0' StringFormat.GenericTypographic);  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,niceFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					g2.SmoothingMode = SmoothingMode.AntiAlias;  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  					#if DEBUG // Display measured text sizes  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 0' 255' 0))' 0' 0' (int)size.Width' (int)size.Height);  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 255' 255' 0))' 0' 0' (int)size2.Width-1' (int)size2.Height-1);  					#endif  					// Draw text shadow  					Matrix mx = new Matrix(1f' 0' 0' 1f' 1' 1);  					g2.Transform = mx;  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(128' Color.Black))' 0' 0' StringFormat.GenericTypographic);  					g2.ResetTransform();  					// Draw text  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(t.GetColor()))' 0' 0' StringFormat.GenericTypographic);  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,niceFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					g2.SmoothingMode = SmoothingMode.AntiAlias;  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  					#if DEBUG // Display measured text sizes  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 0' 255' 0))' 0' 0' (int)size.Width' (int)size.Height);  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 255' 255' 0))' 0' 0' (int)size2.Width-1' (int)size2.Height-1);  					#endif  					// Draw text shadow  					Matrix mx = new Matrix(1f' 0' 0' 1f' 1' 1);  					g2.Transform = mx;  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(128' Color.Black))' 0' 0' StringFormat.GenericTypographic);  					g2.ResetTransform();  					// Draw text  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(t.GetColor()))' 0' 0' StringFormat.GenericTypographic);  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,niceFont,The following statement contains a magic number: using (Graphics g2 = Graphics.FromImage(bmp2))  			{  				if (size.Width != 0 && size.Height != 0)  				{  					g2.SmoothingMode = SmoothingMode.AntiAlias;  					g2.TextRenderingHint = System.Drawing.Text.TextRenderingHint.AntiAlias;  					#if DEBUG // Display measured text sizes  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 0' 255' 0))' 0' 0' (int)size.Width' (int)size.Height);  						g2.DrawRectangle(new Pen(Color.FromArgb(255' 255' 255' 0))' 0' 0' (int)size2.Width-1' (int)size2.Height-1);  					#endif  					// Draw text shadow  					Matrix mx = new Matrix(1f' 0' 0' 1f' 1' 1);  					g2.Transform = mx;  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(128' Color.Black))' 0' 0' StringFormat.GenericTypographic);  					g2.ResetTransform();  					// Draw text  					g2.DrawString(t.GetText()' font' new SolidBrush(Color.FromArgb(t.GetColor()))' 0' 0' StringFormat.GenericTypographic);  				}  			}
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,NextPowerOfTwo,The following statement contains a magic number: x |= x >> 2;
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,NextPowerOfTwo,The following statement contains a magic number: x |= x >> 4;
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,NextPowerOfTwo,The following statement contains a magic number: x |= x >> 8;
Magic Number,ManicDigger.Renderers,TextRenderer,C:\repos\manicdigger_manicdigger\ManicDigger\ClientNative\TextRenderer.cs,NextPowerOfTwo,The following statement contains a magic number: x |= x >> 16;
