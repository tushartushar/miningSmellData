Implementation smell,Namespace,Class,File,Method,Description
Long Method,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The method has 124 lines of code.
Long Method,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The method has 418 lines of code.
Long Method,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The method has 129 lines of code.
Long Method,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The method has 131 lines of code.
Long Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,The method has 150 lines of code.
Long Method,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The method has 110 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_fast,The method has 101 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The method has 126 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The method has 147 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The method has 424 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The method has 291 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The method has 200 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The method has 154 lines of code.
Long Method,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The method has 198 lines of code.
Complex Method,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,UploadClick,Cyclomatic complexity of the method is 9
Complex Method,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,Cyclomatic complexity of the method is 10
Complex Method,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,Cyclomatic complexity of the method is 37
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,Cyclomatic complexity of the method is 9
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,Cyclomatic complexity of the method is 9
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,Cyclomatic complexity of the method is 9
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,Cyclomatic complexity of the method is 24
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,Cyclomatic complexity of the method is 10
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaSegmentInformation,Cyclomatic complexity of the method is 8
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaInfo,Cyclomatic complexity of the method is 8
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaCluster,Cyclomatic complexity of the method is 11
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,Cyclomatic complexity of the method is 9
Complex Method,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSubtitle,Cyclomatic complexity of the method is 9
Complex Method,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,Cyclomatic complexity of the method is 8
Complex Method,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,Cyclomatic complexity of the method is 22
Complex Method,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,Cyclomatic complexity of the method is 13
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,Cyclomatic complexity of the method is 10
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,Cyclomatic complexity of the method is 10
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_stored,Cyclomatic complexity of the method is 11
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_fast,Cyclomatic complexity of the method is 14
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,Cyclomatic complexity of the method is 18
Complex Method,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,Cyclomatic complexity of the method is 26
Complex Method,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,Cyclomatic complexity of the method is 52
Complex Method,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,inflate_flush,Cyclomatic complexity of the method is 9
Complex Method,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,Cyclomatic complexity of the method is 43
Complex Method,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,Cyclomatic complexity of the method is 36
Complex Method,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateSync,Cyclomatic complexity of the method is 8
Complex Method,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,Cyclomatic complexity of the method is 26
Complex Method,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,Cyclomatic complexity of the method is 8
Complex Method,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,Cyclomatic complexity of the method is 12
Long Parameter List,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The method has 5 parameters. Parameters: subtitleFileName' rawText' videoFileName' name' description
Long Parameter List,Nikse.SubtitleEdit.PluginLogic,IPlugin,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\IPlugin.cs,DoAction,The method has 7 parameters. Parameters: parentForm' subtitle' frameRate' listViewLineSeparatorString' subtitleFileName' videoFileName' rawText
Long Parameter List,Nikse.SubtitleEdit.PluginLogic,OpenSubtitlesUpload,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Plugin.cs,DoAction,The method has 7 parameters. Parameters: parentForm' subtitle' frameRate' listViewLineSeparatorString' subtitleFileName' videoFileName' rawText
Long Parameter List,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The method has 7 parameters. Parameters: subtitle' subtitleFileName' movieFileName' movieFileNameFull' language' fps' encoding
Long Parameter List,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The method has 12 parameters. Parameters: subtitle' subtitleFileName' movieFileName' movieFileNameFull' language' releaseName' idMovieImdb' comment' hearingImpaired' hd' fps' encoding
Long Parameter List,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaInfo,The method has 8 parameters. Parameters: fileName' isValid' hasConstantFrameRate' frameRate' pixelWidth' pixelHeight' millisecsDuration' videoCodec
Long Parameter List,OpenSubtitlesUpload.VideoFormats.Boxes,Minf,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Minf.cs,Minf,The method has 5 parameters. Parameters: fs' maximumLength' timeScale' handlerType' mdia
Long Parameter List,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The method has 5 parameters. Parameters: fs' maximumLength' timeScale' handlerType' mdia
Long Parameter List,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The method has 6 parameters. Parameters: strm' level' method' windowBits' memLevel' strategy
Long Parameter List,ComponentAce.Compression.Libs.zlib,Config,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Config,The method has 5 parameters. Parameters: good_length' max_lazy' nice_length' max_chain' func
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,InfCodes,The method has 7 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,InfCodes,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The method has 8 parameters. Parameters: bl' bd' tl' tl_index' td' td_index' s' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The method has 11 parameters. Parameters: b' bindex' n' s' d' e' t' m' hp' hn' v
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_bits,The method has 5 parameters. Parameters: c' bb' tb' hp' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,The method has 9 parameters. Parameters: nl' nd' c' bl' bd' tl' td' hp' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_fixed,The method has 5 parameters. Parameters: bl' bd' tl' td' z
Long Parameter List,ComponentAce.Compression.Libs.zlib,StaticTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\StaticTree.cs,StaticTree,The method has 5 parameters. Parameters: static_tree' extra_bits' extra_base' elems' max_length
Long Identifier,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,,The length of the parameter AutoDetectWordsCroatianAndSerbian is 33.
Long Identifier,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,,The length of the parameter AutoDetectWordsSerbianCyrillic is 30.
Long Statement,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The length of the statement  "            this.listViewSearchResults.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 157.
Long Statement,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The length of the statement  "            this.listViewSearchResults.MouseDoubleClick += new System.Windows.Forms.MouseEventHandler(this.listViewSearchResults_MouseDoubleClick); " is 135.
Long Statement,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The length of the statement  "            this.buttonOK.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 147.
Long Statement,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The length of the statement  "            this.buttonCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 151.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,GetCurrentEncoding,The length of the statement  "            if (comboBoxEncoding.Text == Encoding.UTF8.BodyName || comboBoxEncoding.Text == Encoding.UTF8.EncodingName || comboBoxEncoding.Text == "utf-8") " is 143.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,UploadClick,The length of the statement  "                    var res = _api.TryUploadSubtitles(_rawText' textBoxSubtitleFileName.Text' textBoxMovieFileName.Text' _videoFileName' GetLanguageCode()' fps' GetCurrentEncoding()); " is 163.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,UploadClick,The length of the statement  "                        if (_api.UploadSubtitles(_rawText' textBoxSubtitleFileName.Text' textBoxMovieFileName.Text' _videoFileName' GetLanguageCode()' textBoxReleaseName.Text' textBoxImdbId.Text' textBoxComment.Text' textForHi' hd' fps' GetCurrentEncoding())) " is 235.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,GetMovieFileExtensions,The length of the statement  "            return new List<string> { ".avi"' ".mkv"' ".wmv"' ".mpg"' ".mpeg"' ".divx"' ".mp4"' ".asf"' ".flv"' ".mov"' ".m4v"' ".vob"' ".ogv"' ".webm"' ".ts"' ".m2ts" }; " is 158.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,buttonOpenVideo_Click,The length of the statement  "                //Task.Factory.StartNew(SetFrameRateFromVideoFile).ContinueWith((_) => comboBoxFrameRate.SelectedIndex = idx' TaskScheduler.FromCurrentSynchronizationContext()); // where 'idx' is global volatile " is 195.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The length of the statement  "            // Cursor = Cursors.WaitCursor; will Invalid operation exection (Note: Belong to UI thread' the expection won't crash the app 'CAREFUL')  " is 136.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The length of the statement  "                            mkv.GetMatroskaInfo(_videoFileName' ref isValid' ref hasConstantFrameRate' ref frameRate' ref pixelWidth' ref pixelHeight' ref millisecsDuration' ref videoCodec); " is 162.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.buttonUpload.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 151.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxSubtitleFileName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 156.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelUploadManually.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 161.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelUploadManually.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelUploadManually_LinkClicked); " is 144.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.buttonCancel.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Right))); " is 151.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxMovieFileName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 153.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxPassword.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 148.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxUserName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 148.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.groupBoxLogin.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left)  " is 149.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelRegister.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 155.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelRegister.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelRegister_LinkClicked); " is 132.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.groupBoxSubtitleInfo.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 156.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.linkLabelSearchImdb.LinkClicked += new System.Windows.Forms.LinkLabelLinkClickedEventHandler(this.linkLabelSearchImdb_LinkClicked); " is 136.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxComment.Anchor = ((System.Windows.Forms.AnchorStyles)((((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Bottom)  " is 150.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.textBoxReleaseName.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 151.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.comboBoxLanguage.Anchor = ((System.Windows.Forms.AnchorStyles)(((System.Windows.Forms.AnchorStyles.Top | System.Windows.Forms.AnchorStyles.Left)  " is 149.
Long Statement,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The length of the statement  "            this.labelStatus.Anchor = ((System.Windows.Forms.AnchorStyles)((System.Windows.Forms.AnchorStyles.Bottom | System.Windows.Forms.AnchorStyles.Left))); " is 149.
Long Statement,Nikse.SubtitleEdit.PluginLogic,OpenSubtitlesUpload,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Plugin.cs,DoAction,The length of the statement  "            using (var form = new PluginForm(subtitleFileName' rawText' videoFileName' (this as IPlugin).Name' (this as IPlugin).Description)) " is 130.
Long Statement,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The length of the statement  "                int frenchCount = GetCount(text' "[Cc]'est"' "pas"' "vous"' "pour"' "suis"' "Pourquoi"' "maison"' "souviens"' "quelque"); // not spanish words " is 142.
Long Statement,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The length of the statement  "                int frenchCount = GetCount(text' "[Cc]'est"' "pas"' "vous"' "pour"' "suis"' "Pourquoi"' "maison"' "souviens"' "quelque"); // not italian words " is 142.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,Login,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,Login,The length of the statement  "            Token = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='token']/../value/string").InnerText; " is 128.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,LogOut,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,NoOperation,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subhash']/../value/string").InnerText = subtitleHash; " is 160.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subfilename']/../value/string").InnerText = subtitleFileName; " is 168.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviehash']/../value/string").InnerText = movieHash; " is 159.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviebytesize']/../value/double").InnerText = movieByteSize; " is 167.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "                doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviefps']/../value/double").InnerText = fps; " is 152.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviefilename']/../value/string").InnerText = movieFileName; " is 167.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,TryUploadSubtitles,The length of the statement  "                string alreadyInDb = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='alreadyindb']/../value/int").InnerText; " is 144.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='idmovieimdb']/../value/string").InnerText = idMovieImdb; " is 163.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='sublanguageid']/../value/string").InnerText = language; " is 162.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='hearingimpaired']/../value/string").InnerText = hearingImpaired; " is 171.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='highdefinition']/../value/string").InnerText = hd; " is 157.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviereleasename']/../value/string").InnerText = releaseName; " is 168.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subauthorcomment']/../value/string").InnerText = comment; " is 164.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subhash']/../value/string").InnerText = subtitleHash; " is 160.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subfilename']/../value/string").InnerText = subtitleFileName; " is 168.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviehash']/../value/string").InnerText = movieHash; " is 159.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviebytesize']/../value/double").InnerText = movieByteSize; " is 167.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "                doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviefps']/../value/double").InnerText = fps; " is 152.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='moviefilename']/../value/string").InnerText = movieFileName; " is 167.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/struct/member/value/struct/member/name[text()='subcontent']/../value/string").InnerText = subtitleContent; " is 166.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,UploadSubtitles,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,GZLib,The length of the statement  "                    using (var gs = new ComponentAce.Compression.Libs.zlib.ZOutputStream(mso' ComponentAce.Compression.Libs.zlib.zlibConst.Z_DEFAULT_COMPRESSION)) " is 142.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchMoviesOnIMDB,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/array/data/value/struct/member/name[text()='sublanguageid']/../value/string").InnerText = language; " is 159.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/array/data/value/struct/member/name[text()='moviehash']/../value/string").InnerText = movieHash; " is 156.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchSubtitles,The length of the statement  "            doc.DocumentElement.SelectSingleNode("params/param[2]/value/array/data/value/struct/member/name[text()='moviebytesize']/../value/double").InnerText = movieByteSize; " is 164.
Long Statement,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SearchSubtitles,The length of the statement  "            LastStatus = doc.DocumentElement.SelectSingleNode("params/param/value/struct/member/name[text()='status']/../value/string").InnerText; " is 134.
Long Statement,Nikse.SubtitleEdit.Logic,Utils,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Utils.cs,GetSettingsFileName,The length of the statement  "                path = Path.Combine(Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.ApplicationData)' "Subtitle Edit")' "Plugins"); " is 132.
Long Statement,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,FindTrackStartInCluster,The length of the statement  "                        clusterTimeCode = GetMatroskaVariableSizeUnsignedInt(dataSize); // Absolute timestamp of the cluster (based on TimecodeScale). " is 126.
Long Statement,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaSegmentInformation,The length of the statement  "                    if (matroskaId == 0x2AD7B1)// TimecodeScale - u-integer     Timecode scale in nanoseconds (1.000.000 means all timecodes in the segment are expressed in milliseconds). " is 167.
Long Statement,OpenSubtitlesUpload.VideoFormats,MP4,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mp4.cs,GetSubtitleTracks,The length of the statement  "                    if (trak.Mdia != null && (trak.Mdia.IsTextSubtitle || trak.Mdia.IsVobSubSubtitle || trak.Mdia.IsClosedCaption) && trak.Mdia.Minf != null && trak.Mdia.Minf.Stbl != null) " is 168.
Long Statement,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The length of the statement  "            return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 | " is 138.
Long Statement,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The length of the statement  "            return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 | " is 138.
Long Statement,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The length of the statement  "                    textSize = GetUInt(data' 0); // don't get it exactly - seems like mp4box sometimes uses 2 bytes length field (first text record only)... handbrake uses 4 bytes " is 159.
Long Statement,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The length of the statement  "                if (window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]) " is 158.
Long Statement,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The length of the statement  "                while (window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && window[++scan] == window[++match] && scan < strend); " is 318.
Long Statement,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The length of the statement  "            if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) " is 177.
Long Statement,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The length of the statement  "            if (strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)) " is 123.
Long Statement,ComponentAce.Compression.Libs.zlib,ZStream,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZStream.cs,flush_pending,The length of the statement  "            if (dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)) " is 191.
Long Statement,ComponentAce.Compression.Libs.zlib,ZStream,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZStream.cs,flush_pending,The length of the statement  "                //System.Console.Out.WriteLine(dstate.pending_buf.Length + "' " + dstate.pending_out + "' " + next_out.Length + "' " + next_out_index + "' " + len); " is 148.
Complex Conditional,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The conditional expression  "ei.Name != Encoding.UTF8.BodyName && ei.CodePage >= 949 && !ei.DisplayName.Contains("EBCDIC") && ei.CodePage != 1047"  is complex.
Complex Conditional,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The conditional expression  "frameRate < 1 && (ext == ".mp4" || ext == ".mov" || ext == ".m4v")"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaId,The conditional expression  "x == Ebml || // ebml header                  x == 0x18538067 || // segment                  x == 0x114D9B74 || // seekhead                  x == 0x1549A966 || // segment info                  x == 0x1654AE6B || // track                  x == 0x1F43B675 || // cluster                  x == 0x1C53BB6B || // Cues                  x == 0x1941A469 || // Attachments                  x == 0x1043A770 || // Chapters                  x == 0x1254C367"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The conditional expression  "s == 0xEC || // Void                  s == 0xBF || // CRC-32                  s == 0xD7 || // Track number                  s == 0x83 || // Track type                  s == 0xB9 || // Flag enabled                  s == 0x88 || // Flag default                  s == 0x9C || // Flag lacing                  s == 0x4F || // Track Time Code Scale                  s == 0xAA || // CodecDecodeAll                  s == 0xE0 || // Track Video                  s == 0xE1 || // Track Audio                  s == 0x86"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The conditional expression  "s == 0x73C5 || // TrackUID                  s == 0x55AA || // FlagForced                  s == 0x6DE7 || // MinCache                  s == 0x6DF8 || // MaxCache                  s == 0x55EE || // MaxBlockAdditionID                  s == 0x63A2 || // CodecPrivate                  s == 0x7446 || // AttachmentLink                  s == 0x6D80 || // ContentEncodings                  s == 0x537F || // TrackOffset                  s == 0x6FAB || // TrackOverlay                  s == 0x536E || // Name                  s == 0x6624 || // TrackTranslate                  s == 0x66FC || // TrackTranslateEditionUID                  s == 0x66BF || // TrackTranslateCodec                  s == 0x66A5"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The conditional expression  "s == 0x23E383 || // Default Duration                  s == 0x22B59C || // Language                  s == 0x258688 || // CodecName                  s == 0x23314F"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackVideoId,The conditional expression  "s == 0xEC || // Void                  s == 0xBF || // CRC-32                  s == 0xB0 || // PixelWidth                  s == 0xBA || // PixelHeight                  s == 0x9A"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackVideoId,The conditional expression  "s == 0x54B0 || // DisplayWidth                  s == 0x54BA || // DisplayHeight                  s == 0x54BA || // DisplayHeight                  s == 0x54AA || // PixelCropButton                  s == 0x54BB || // PixelCropTop                  s == 0x54CC || // PixelCropLeft                  s == 0x54DD || // PixelCropRight                  s == 0x54DD || // PixelCropRight                  s == 0x54B2 || // DisplayUnit                  s == 0x54B3"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSegmentId,The conditional expression  "s == 0x73A4 || // SegmentUID                  s == 0x7384 || // SegmentFilename                  s == 0x4444 || // SegmentFamily                  s == 0x6924 || // ChapterTranslate                  s == 0x69FC || // ChapterTranslateEditionUID                  s == 0x69BF || // ChapterTranslateCodec                  s == 0x69A5 || // ChapterTranslateID                  s == 0x4489 || // Duration                  s == 0x4461 || // DateUTC                  s == 0x7BA9 || // Title                  s == 0x4D80 || // MuxingApp                  s == 0x5741"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSegmentId,The conditional expression  "s == 0x3CB923 || // PrevUID                  s == 0x3C83AB || // PrevFilename                  s == 0x3EB923 || // NextUID                  s == 0x3E83BB || // NextFilename                  s == 0x2AD7B1"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaClusterId,The conditional expression  "s == 0xE7 || // TimeCode                  s == 0xA7 || // Position                  s == 0xAB || // PrevSize                  s == 0xA0 || // BlockGroup                  s == 0xA1 || // Block                  s == 0xA2 || // BlockVirtual                  s == 0xA6 || // BlockMore                  s == 0xEE || // BlockAddID                  s == 0xA5 || // BlockAdditional                  s == 0x9B || // BlockDuration                  s == 0xFA || // ReferencePriority                  s == 0xFB || // ReferenceBlock                  s == 0xFD || // ReferenceVirtual                  s == 0xA4 || // CodecState                  s == 0x8E || // Slices                  s == 0x8E || // TimeSlice                  s == 0xCC || // LaceNumber                  s == 0xCD || // FrameNumber                  s == 0xCB || // BlockAdditionID                  s == 0xCE || // Delay                  s == 0xCF || // Duration                  s == 0xA3"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats,MP4,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mp4.cs,GetSubtitleTracks,The conditional expression  "trak.Mdia != null && (trak.Mdia.IsTextSubtitle || trak.Mdia.IsVobSubSubtitle || trak.Mdia.IsClosedCaption) && trak.Mdia.Minf != null && trak.Mdia.Minf.Stbl != null"  is complex.
Complex Conditional,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The conditional expression  "Name == "minf" && IsTextSubtitle || IsVobSubSubtitle || IsClosedCaption || IsVideo"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The conditional expression  "match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The conditional expression  "window[match + best_len] != scan_end || window[match + best_len - 1] != scan_end1 || window[match] != window[scan] || window[++match] != window[scan + 1]"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The conditional expression  "memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateParams,The conditional expression  "_level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The conditional expression  "strm.next_out == null || (strm.next_in == null && strm.avail_in != 0) || (status == FINISH_STATE && flush != Z_FINISH)"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The conditional expression  "strm.avail_in != 0 || lookahead != 0 || (flush != Z_NO_FLUSH && status != FINISH_STATE)"  is complex.
Complex Conditional,ComponentAce.Compression.Libs.zlib,ZStream,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZStream.cs,flush_pending,The conditional expression  "dstate.pending_buf.Length <= dstate.pending_out || next_out.Length <= next_out_index || dstate.pending_buf.Length < (dstate.pending_out + len) || next_out.Length < (next_out_index + len)"  is complex.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,LoadLogin,The method has an empty catch block.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SaveLogin,The method has an empty catch block.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,FillLanguages,The method has an empty catch block.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,CheckLogin,The method has an empty catch block.
Empty Catch Block,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The method has an empty catch block.
Empty Catch Block,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,GetBytesWithChosenEncoding,The method has an empty catch block.
Empty Catch Block,ComponentAce.Compression.Libs.zlib,ZOutputStream,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZOutputStream.cs,finish,The method has an empty catch block.
Empty Catch Block,ComponentAce.Compression.Libs.zlib,ZOutputStream,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZOutputStream.cs,Close,The method has an empty catch block.
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelSearch.Location = new System.Drawing.Point(12' 25);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelSearch.Location = new System.Drawing.Point(12' 25);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelSearch.Size = new System.Drawing.Size(85' 13);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelSearch.Size = new System.Drawing.Size(85' 13);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSearchQuery.Location = new System.Drawing.Point(104' 22);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSearchQuery.Location = new System.Drawing.Point(104' 22);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSearchQuery.Size = new System.Drawing.Size(310' 20);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSearchQuery.Size = new System.Drawing.Size(310' 20);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.Location = new System.Drawing.Point(420' 20);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.Location = new System.Drawing.Point(420' 20);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearch.TabIndex = 2;
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.Location = new System.Drawing.Point(15' 63);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.Location = new System.Drawing.Point(15' 63);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.Size = new System.Drawing.Size(480' 238);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.Size = new System.Drawing.Size(480' 238);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.listViewSearchResults.TabIndex = 3;
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.columnHeaderImdbId.Width = 100;
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.columnHeaderTitle.Width = 350;
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.Location = new System.Drawing.Point(339' 307);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.Location = new System.Drawing.Point(339' 307);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonOK.TabIndex = 4;
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Location = new System.Drawing.Point(420' 307);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Location = new System.Drawing.Point(420' 307);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.TabIndex = 5;
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Location = new System.Drawing.Point(13' 316);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Location = new System.Drawing.Point(13' 316);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Size = new System.Drawing.Size(59' 13);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Size = new System.Drawing.Size(59' 13);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.TabIndex = 6;
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(507' 342);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(507' 342);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(523' 380);
Magic Number,OpenSubtitlesUpload,ImdbSearch,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\ImdbSearch.cs,InitializeComponent,The following statement contains a magic number: this.MinimumSize = new System.Drawing.Size(523' 380);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The following statement contains a magic number: temp.Length + 18 < rawText.Length
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The following statement contains a magic number: ei.Name != Encoding.UTF8.BodyName && ei.CodePage >= 949 && !ei.DisplayName.Contains("EBCDIC") && ei.CodePage != 1047
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,PluginForm,The following statement contains a magic number: ei.Name != Encoding.UTF8.BodyName && ei.CodePage >= 949 && !ei.DisplayName.Contains("EBCDIC") && ei.CodePage != 1047
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The following statement contains a magic number: Invoke(new MethodInvoker(() =>                  {                      double minDiff = 100;                      var index = 0;                      for (int i = 1; i < comboBoxFrameRate.Items.Count; i++)                      {                          var element = comboBoxFrameRate.Items[i];                          double d;                          if (double.TryParse(element.ToString()' NumberStyles.AllowDecimalPoint' CultureInfo.InvariantCulture' out d))                          {                              double diff = Math.Abs(d - frameRate);                              if (diff < 0.01 && diff < minDiff)                              {                                  index = i;                                  minDiff = diff;                              }                          }                      }                      comboBoxFrameRate.SelectedIndex = index;                  }));
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,SetFrameRateFromVideoFile,The following statement contains a magic number: Invoke(new MethodInvoker(() =>                  {                      double minDiff = 100;                      var index = 0;                      for (int i = 1; i < comboBoxFrameRate.Items.Count; i++)                      {                          var element = comboBoxFrameRate.Items[i];                          double d;                          if (double.TryParse(element.ToString()' NumberStyles.AllowDecimalPoint' CultureInfo.InvariantCulture' out d))                          {                              double diff = Math.Abs(d - frameRate);                              if (diff < 0.01 && diff < minDiff)                              {                                  index = i;                                  minDiff = diff;                              }                          }                      }                      comboBoxFrameRate.SelectedIndex = index;                  }));
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.Location = new System.Drawing.Point(301' 465);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.Location = new System.Drawing.Point(301' 465);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonUpload.TabIndex = 4;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.Location = new System.Drawing.Point(116' 107);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.Location = new System.Drawing.Point(116' 107);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.Size = new System.Drawing.Size(317' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.Size = new System.Drawing.Size(317' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxSubtitleFileName.TabIndex = 9;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.Location = new System.Drawing.Point(13' 473);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.Location = new System.Drawing.Point(13' 473);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.Size = new System.Drawing.Size(85' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.Size = new System.Drawing.Size(85' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelUploadManually.TabIndex = 3;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Location = new System.Drawing.Point(382' 465);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Location = new System.Drawing.Point(382' 465);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.Size = new System.Drawing.Size(75' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonCancel.TabIndex = 5;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.Location = new System.Drawing.Point(6' 110);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.Location = new System.Drawing.Point(6' 110);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.Size = new System.Drawing.Size(52' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.Size = new System.Drawing.Size(52' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelSubtitleFileName.TabIndex = 8;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.Location = new System.Drawing.Point(6' 163);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.Location = new System.Drawing.Point(6' 163);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.Size = new System.Drawing.Size(81' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.Size = new System.Drawing.Size(81' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelMovieFileName.TabIndex = 12;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.Location = new System.Drawing.Point(116' 160);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.Location = new System.Drawing.Point(116' 160);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.Size = new System.Drawing.Size(287' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.Size = new System.Drawing.Size(287' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxMovieFileName.TabIndex = 13;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.Location = new System.Drawing.Point(14' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.Location = new System.Drawing.Point(14' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.Size = new System.Drawing.Size(53' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.Size = new System.Drawing.Size(53' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelPassword.TabIndex = 3;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.Location = new System.Drawing.Point(114' 55);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.Location = new System.Drawing.Point(114' 55);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.Size = new System.Drawing.Size(179' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.Size = new System.Drawing.Size(179' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxPassword.TabIndex = 4;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelUserName.Location = new System.Drawing.Point(14' 32);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelUserName.Location = new System.Drawing.Point(14' 32);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelUserName.Size = new System.Drawing.Size(58' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelUserName.Size = new System.Drawing.Size(58' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxUserName.Location = new System.Drawing.Point(114' 29);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxUserName.Location = new System.Drawing.Point(114' 29);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxUserName.Size = new System.Drawing.Size(179' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxUserName.Size = new System.Drawing.Size(179' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxLogin.Location = new System.Drawing.Point(16' 353);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxLogin.Location = new System.Drawing.Point(16' 353);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxLogin.Size = new System.Drawing.Size(438' 89);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxLogin.Size = new System.Drawing.Size(438' 89);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.Location = new System.Drawing.Point(299' 32);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.Location = new System.Drawing.Point(299' 32);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.Size = new System.Drawing.Size(95' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.Size = new System.Drawing.Size(95' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelRegister.TabIndex = 2;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxSubtitleInfo.Location = new System.Drawing.Point(12' 12);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxSubtitleInfo.Location = new System.Drawing.Point(12' 12);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxSubtitleInfo.Size = new System.Drawing.Size(442' 335);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.groupBoxSubtitleInfo.Size = new System.Drawing.Size(442' 335);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.Location = new System.Drawing.Point(116' 185);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.Location = new System.Drawing.Point(116' 185);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.Size = new System.Drawing.Size(315' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.Size = new System.Drawing.Size(315' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxFrameRate.TabIndex = 16;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.Location = new System.Drawing.Point(6' 189);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.Location = new System.Drawing.Point(6' 189);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.Size = new System.Drawing.Size(27' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.Size = new System.Drawing.Size(27' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelFrameRate.TabIndex = 15;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.Location = new System.Drawing.Point(116' 133);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.Location = new System.Drawing.Point(116' 133);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.Size = new System.Drawing.Size(317' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.Size = new System.Drawing.Size(317' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxEncoding.TabIndex = 11;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 136);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Location = new System.Drawing.Point(6' 136);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(75' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.Size = new System.Drawing.Size(75' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label5.TabIndex = 10;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.Location = new System.Drawing.Point(227' 309);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.Location = new System.Drawing.Point(227' 309);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.Size = new System.Drawing.Size(118' 17);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.Size = new System.Drawing.Size(118' 17);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxHD.TabIndex = 20;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.Location = new System.Drawing.Point(116' 309);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.Location = new System.Drawing.Point(116' 309);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.Size = new System.Drawing.Size(106' 17);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.Size = new System.Drawing.Size(106' 17);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.checkBoxTextForHI.TabIndex = 19;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.Location = new System.Drawing.Point(207' 53);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.Location = new System.Drawing.Point(207' 53);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.Size = new System.Drawing.Size(24' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.Size = new System.Drawing.Size(24' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonSearchIMDb.TabIndex = 4;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.Location = new System.Drawing.Point(409' 158);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.Location = new System.Drawing.Point(409' 158);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.Size = new System.Drawing.Size(24' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.Size = new System.Drawing.Size(24' 23);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.buttonOpenVideo.TabIndex = 14;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.Location = new System.Drawing.Point(236' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.Location = new System.Drawing.Point(236' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.Size = new System.Drawing.Size(72' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.Size = new System.Drawing.Size(72' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.linkLabelSearchImdb.TabIndex = 5;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.Location = new System.Drawing.Point(116' 212);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.Location = new System.Drawing.Point(116' 212);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.Size = new System.Drawing.Size(317' 91);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.Size = new System.Drawing.Size(317' 91);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxComment.TabIndex = 18;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(7' 215);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Location = new System.Drawing.Point(7' 215);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(51' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.Size = new System.Drawing.Size(51' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label4.TabIndex = 17;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 84);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Location = new System.Drawing.Point(6' 84);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(75' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.Size = new System.Drawing.Size(75' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label3.TabIndex = 6;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.Location = new System.Drawing.Point(116' 81);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.Location = new System.Drawing.Point(116' 81);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.Size = new System.Drawing.Size(317' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.Size = new System.Drawing.Size(317' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxReleaseName.TabIndex = 7;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Location = new System.Drawing.Point(6' 58);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(44' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.Size = new System.Drawing.Size(44' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label2.TabIndex = 2;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.Location = new System.Drawing.Point(116' 55);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.Location = new System.Drawing.Point(116' 55);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.Size = new System.Drawing.Size(85' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.Size = new System.Drawing.Size(85' 20);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.textBoxImdbId.TabIndex = 3;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxLanguage.Location = new System.Drawing.Point(116' 28);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxLanguage.Location = new System.Drawing.Point(116' 28);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxLanguage.Size = new System.Drawing.Size(317' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.comboBoxLanguage.Size = new System.Drawing.Size(317' 21);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 31);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Location = new System.Drawing.Point(6' 31);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(55' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.label1.Size = new System.Drawing.Size(55' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Location = new System.Drawing.Point(14' 445);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Location = new System.Drawing.Point(14' 445);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Size = new System.Drawing.Size(59' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.Size = new System.Drawing.Size(59' 13);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.labelStatus.TabIndex = 2;
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.AutoScaleDimensions = new System.Drawing.SizeF(6F' 13F);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(469' 500);
Magic Number,OpenSubtitlesUpload,PluginForm,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\PluginForm.cs,InitializeComponent,The following statement contains a magic number: this.ClientSize = new System.Drawing.Size(469' 500);
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: switch (encoding.CodePage)              {                  case 860:                      return "pt"; // Portuguese                  case 28599:                  case 1254:                      return "tr"; // Turkish                  case 28598:                  case 1255:                      return "he"; // Hebrew                  case 28596:                  case 1256:                      return "ar"; // Arabic                  case 1258:                      return "vi"; // Vietnamese                  case 949:                  case 1361:                  case 20949:                  case 51949:                  case 50225:                      return "ko"; // Korean                  case 1253:                  case 28597:                      return "el"; // Greek                  case 50220:                  case 50221:                  case 50222:                  case 51932:                  case 20932:                  case 10001:                      return "ja"; // Japanese                  case 20000:                  case 20002:                  case 20936:                  case 950:                  case 52936:                  case 54936:                  case 51936:                      return "zh"; // Chinese                  default:                      return null;              }
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: norwegianCount < 2 && dutchCount < count
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: danishCount < 2 && dutchCount < count
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: frenchCount < 2 && portugueseCount < 2
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: frenchCount < 2 && portugueseCount < 2
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: frenchCount < 2
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: romanianCount < 5
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: count > 10 || count > bestCount
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: count > 10 || count > bestCount
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: count > bestCount * 2
Magic Number,Nikse.SubtitleEdit.Core,LanguageAutoDetect,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\LanguageAutoDetect.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: count > bestCount * 2
Magic Number,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,SendRequestAndGetResponse,The following statement contains a magic number: webRequest.Timeout = 10000;
Magic Number,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,ComputeMovieHash,The following statement contains a magic number: const int c = 65536;
Magic Number,OpenSubtitles,OpenSubtitlesApi,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\OpenSubtitlesApi.cs,ComputeMovieHash,The following statement contains a magic number: i < 65536 / sizeof(long) && (input.Read(buffer' 0' sizeof(long)) > 0)
Magic Number,Nikse.SubtitleEdit.Logic,Utils,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Utils.cs,AutoDetectGoogleLanguage,The following statement contains a magic number: string languageId = AutoDetectGoogleLanguage(text' 10);
Magic Number,Nikse.SubtitleEdit.Logic,Utils,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\Utils.cs,GetSettingsFileName,The following statement contains a magic number: path = path.Remove(0' 6);
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,FindTrackStartInCluster,The following statement contains a magic number: return (clusterTimeCode + trackStartTime) * _timeCodeScale / 1000000;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: int a = 255;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a == 255
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 127;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: result = 2;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a == 127
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 63;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: result = 3;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a == 63
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 31;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: result = 4;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a == 31
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 15;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: result = 5;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a == 15
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 7;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: result = 6;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a == 7
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a = 3;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: result = 7;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: a == 3
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableIntLength,The following statement contains a magic number: result = 8;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: long i = (long)_f.ReadByte() << 48;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: i += (long)_f.ReadByte() << 40;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: i += (long)_f.ReadByte() << 32;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: i += (long)_f.ReadByte() << 24;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: i += (long)_f.ReadByte() << 16;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: i += (long)_f.ReadByte() << 8;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaDataSize,The following statement contains a magic number: sizeOfSize == 8
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaVariableSizeUnsignedInt,The following statement contains a magic number: sizeOfSize >= 8
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackEntryId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackVideoId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaTrackVideoId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSegmentId,The following statement contains a magic number: UInt32 s = (UInt32)b * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaSegmentId,The following statement contains a magic number: s = (UInt32)b * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaTrackEntry,The following statement contains a magic number: _frameRate = 1.0 / (defaultDuration / 1000000000.0);
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaContentEncoding,The following statement contains a magic number: int ebmlId = _f.ReadByte() * 256 + _f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaSegmentInformation,The following statement contains a magic number: _durationInMilliseconds = duration8b / timeCodeScale * 1000000.0;
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,GetMatroskaClusterId,The following statement contains a magic number: s = s * 256 + (byte)_f.ReadByte();
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following statement contains a magic number: switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following statement contains a magic number: switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following statement contains a magic number: switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }
Magic Number,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following statement contains a magic number: switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }
Magic Number,OpenSubtitlesUpload.VideoFormats,MP4,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mp4.cs,ParseMp4,The following statement contains a magic number: Size < 8
Magic Number,OpenSubtitlesUpload.VideoFormats,MP4,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mp4.cs,ParseMp4,The following statement contains a magic number: count > 100
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ReadElement,The following statement contains a magic number: SkipData(size - 4);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: char[] chars = new char[4];
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[1] = (char)((FourCC >> 8) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[2] = (char)((FourCC >> 16) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[2] = (char)((FourCC >> 16) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[3] = (char)((FourCC >> 24) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,FromFourCC,The following statement contains a magic number: chars[3] = (char)((FourCC >> 24) & 0xFF);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: FourCC.Length != 4
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: FourCC.Length != 4
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)FourCC[3]) << 24                          | ((int)FourCC[2]) << 16                          | ((int)FourCC[1]) << 8                          | ((int)FourCC[0]);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)c3) << 24                          | ((int)c2) << 16                          | ((int)c1) << 8                          | ((int)c0);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)c3) << 24                          | ((int)c2) << 16                          | ((int)c1) << 8                          | ((int)c0);
Magic Number,OpenSubtitlesUpload.VideoFormats,RiffParser,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\RiffParser.cs,ToFourCC,The following statement contains a magic number: int result = ((int)c3) << 24                          | ((int)c2) << 16                          | ((int)c1) << 8                          | ((int)c0);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((buffer[index] << 24) + (buffer[index + 1] << 16) + (buffer[index + 2] << 8) + buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt,The following statement contains a magic number: return (uint)((Buffer[index] << 24) + (Buffer[index + 1] << 16) + (Buffer[index + 2] << 8) + Buffer[index + 3]);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)Buffer[index] << 56 | (UInt64)Buffer[index + 1] << 48 | (UInt64)Buffer[index + 2] << 40 | (UInt64)Buffer[index + 3] << 32 |                     (UInt64)Buffer[index + 4] << 24 | (UInt64)Buffer[index + 5] << 16 | (UInt64)Buffer[index + 6] << 8 | Buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetUInt64,The following statement contains a magic number: return (UInt64)buffer[index] << 56 | (UInt64)buffer[index + 1] << 48 | (UInt64)buffer[index + 2] << 40 | (UInt64)buffer[index + 3] << 32 |                     (UInt64)buffer[index + 4] << 24 | (UInt64)buffer[index + 5] << 16 | (UInt64)buffer[index + 6] << 8 | buffer[index + 7];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetWord,The following statement contains a magic number: return (buffer[index] << 8) + buffer[index + 1];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,GetWord,The following statement contains a magic number: return (Buffer[index] << 8) + Buffer[index + 1];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Buffer = new byte[8];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Name = GetString(4' 4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Name = GetString(4' 4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Size = GetUInt64(0) - 8;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Box,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Box.cs,InitializeSizeAndName,The following statement contains a magic number: Position = ((ulong)(fs.Position)) + Size - 8;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: Buffer = new byte[size - 4];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: int languageIndex = 20;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: CreationTime = GetUInt(4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: ModificationTime = GetUInt(8);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: TimeScale = GetUInt(12);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: Duration = GetUInt(16);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: Quality = GetWord(22);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: int languageByte = ((Buffer[languageIndex] << 1) >> 3) + 0x60;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: int languageByte2 = ((Buffer[languageIndex] & 0x3) << 3) + (Buffer[languageIndex + 1] >> 5) + 0x60;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdhd.cs,Mdhd,The following statement contains a magic number: int languageByte2 = ((Buffer[languageIndex] & 0x3) << 3) + (Buffer[languageIndex + 1] >> 5) + 0x60;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mdia,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mdia.cs,Mdia,The following statement contains a magic number: uint timeScale = 90000;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: Buffer = new byte[20];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: CreationTime = GetUInt(4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: ModificationTime = GetUInt(8);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: TimeScale = GetUInt(12);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Mvhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Mvhd.cs,Mvhd,The following statement contains a magic number: Duration = GetUInt(16);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: Buffer = new byte[Size - 4];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: uint totalEntries = GetUInt(4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: uint offset = GetUInt(8 + i * 4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: uint offset = GetUInt(8 + i * 4);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,Stbl,The following statement contains a magic number: lastOffset + 5 < offset
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: var data = new byte[4];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: fs.Read(data' 0' 2);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: data = new byte[textSize + 2];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Stbl,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Stbl.cs,ReadText,The following statement contains a magic number: textSize > 100
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: Buffer = new byte[84];
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: addToIndex64Bit = 8;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: TrackId = GetUInt(12 + addToIndex64Bit);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: Duration = GetUInt64(20 + addToIndex64Bit);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: addToIndex64Bit += 4;
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: Width = (uint)GetWord(76 + addToIndex64Bit);
Magic Number,OpenSubtitlesUpload.VideoFormats.Boxes,Tkhd,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Boxes\Tkhd.cs,Tkhd,The following statement contains a magic number: Height = (uint)GetWord(80 + addToIndex64Bit);
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Adler32.cs,adler32,The following statement contains a magic number: long s2 = (adler >> 16) & 0xffff;
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Adler32.cs,adler32,The following statement contains a magic number: k -= 16;
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Adler32.cs,adler32,The following statement contains a magic number: k >= 16
Magic Number,ComponentAce.Compression.Libs.zlib,Adler32,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Adler32.cs,adler32,The following statement contains a magic number: return (s2 << 16) | s1;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_ltree = new short[HEAP_SIZE * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: dyn_dtree = new short[(2 * D_CODES + 1) * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: bl_tree = new short[(2 * BL_CODES + 1) * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,lm_init,The following statement contains a magic number: window_size = 2 * w_size;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,tr_init,The following statement contains a magic number: last_eob_len = 8;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[i * 2] = 0;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_dtree[i * 2] = 0;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,init_block,The following statement contains a magic number: bl_tree[i * 2] = 0;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,init_block,The following statement contains a magic number: dyn_ltree[END_BLOCK * 2] = 1;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,smaller,The following statement contains a magic number: return (tree[n * 2] < tree[m * 2] || (tree[n * 2] == tree[m * 2] && depth[n] <= depth[m]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: tree[(max_code + 1) * 2 + 1] = (short)SupportClass.Identity(0xffff);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: max_count = 138;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,scan_tree,The following statement contains a magic number: min_count = 3;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: bl_tree[Tree.bl_order[max_blindex] * 2 + 1] != 0
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: max_blindex >= 3
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,build_bl_tree,The following statement contains a magic number: opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(lcodes - 257' 5);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(dcodes - 1' 5);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(blcodes - 4' 4);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_all_trees,The following statement contains a magic number: send_bits(bl_tree[Tree.bl_order[rank] * 2 + 1]' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int nextlen = tree[0 * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int max_count = 7;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: int min_count = 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: nextlen = tree[(n + 1) * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: max_count = 138;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_tree,The following statement contains a magic number: min_count = 3;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,put_short,The following statement contains a magic number: put_byte((byte)(SupportClass.URShift(w' 8)));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,putShortMSB,The following statement contains a magic number: put_byte((byte)(b >> 8));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,send_code,The following statement contains a magic number: send_bits((tree[c * 2] & 0xffff)' (tree[c * 2 + 1] & 0xffff));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: send_bits(STATIC_TREES << 1' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: 1 + last_eob_len + 10 - bi_valid < 9
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_align,The following statement contains a magic number: last_eob_len = 7;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte)(SupportClass.URShift(dist' 8));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2] = (byte)(SupportClass.URShift(dist' 8));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: pending_buf[d_buf + last_lit * 2 + 1] = (byte)dist;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: dyn_ltree[lc * 2]++;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: int out_length = last_lit * 8;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = (int)(out_length + (int)dyn_dtree[dcode * 2] * (5L + Tree.extra_dbits[dcode]));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: out_length = SupportClass.URShift(out_length' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (matches < (last_lit / 2)) && out_length < in_length / 2
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_tally,The following statement contains a magic number: (last_lit & 0x1fff) == 0 && level > 2
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,compress_block,The following statement contains a magic number: dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,compress_block,The following statement contains a magic number: last_eob_len = ltree[END_BLOCK * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: n < 7
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: ascii_freq += dyn_ltree[n * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: n < 128
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: bin_freq += dyn_ltree[n * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,set_data_type,The following statement contains a magic number: data_type = (byte)(bin_freq > (SupportClass.URShift(ascii_freq' 2)) ? Z_BINARY : Z_ASCII);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,bi_flush,The following statement contains a magic number: bi_valid == 16
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,bi_windup,The following statement contains a magic number: bi_valid > 8
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,copy_block,The following statement contains a magic number: last_eob_len = 8;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: max_block_size = pending_buf_size - 5;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_stored,The following statement contains a magic number: max_block_size > pending_buf_size - 5
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_stored_block,The following statement contains a magic number: send_bits((STORED_BLOCK << 1) + (eof ? 1 : 0)' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: opt_lenb = SupportClass.URShift((opt_len + 3 + 7)' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: static_lenb = SupportClass.URShift((static_len + 3 + 7)' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,_tr_flush_block,The following statement contains a magic number: stored_len + 4 <= opt_lenb && buf != -1
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: match_length <= 5 && (strategy == Z_FILTERED || (match_length == MIN_MATCH && strstart - match_start > 4096))
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate_slow,The following statement contains a magic number: prev_length -= 2;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The following statement contains a magic number: chain_length >>= 2;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,longest_match,The following statement contains a magic number: scan += 2;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: level = 6;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED || windowBits < 9 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: hash_bits = memLevel + 7;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: window = new byte[w_size * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: lit_bufsize = 1 << (memLevel + 6);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf = new byte[lit_bufsize * 4];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: pending_buf_size = lit_bufsize * 4;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateInit2,The following statement contains a magic number: l_buf = (1 + 2) * lit_bufsize;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: _level = 6;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflateParams,The following statement contains a magic number: _level < 0 || _level > 9 || _strategy < 0 || _strategy > Z_HUFFMAN_ONLY
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: int header = (Z_DEFLATED + ((w_bits - 8) << 4)) << 8;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: level_flags = 3;
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: level_flags > 3
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: header |= (level_flags << 6);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: header += 31 - (header % 31);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,deflate,The following statement contains a magic number: putShortMSB((int)(SupportClass.URShift(strm.adler' 16)));
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table = new Config[10];
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[1] = new Config(4' 4' 8' 4' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[2] = new Config(4' 5' 16' 8' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[3] = new Config(4' 6' 32' 32' FAST);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[4] = new Config(4' 4' 16' 16' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[5] = new Config(8' 16' 32' 32' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[6] = new Config(8' 16' 128' 128' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[7] = new Config(8' 32' 128' 256' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[8] = new Config(32' 128' 258' 1024' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,Deflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Deflate.cs,Deflate,The following statement contains a magic number: config_table[9] = new Config(32' 258' 258' 4096' SLOW);
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,InfBlocks,The following statement contains a magic number: hufts = new int[MANY * 3];
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following statement contains a magic number: switch (mode)                  {                      case TYPE:                            while (k < (3))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                          t = (int)(b & 7);                          last = t & 1;                            switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }                          break;                        case LENS:                            while (k < (32))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            if (((SupportClass.URShift((~b)' 16)) & 0xffff) != (b & 0xffff))                          {                              mode = BAD;                              z.msg = "invalid stored block lengths";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          left = (b & 0xffff);                          b = k = 0; // dump bits                          mode = left != 0 ? STORED : (last != 0 ? DRY : TYPE);                          break;                        case STORED:                          if (n == 0)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            if (m == 0)                          {                              if (q == end && read != 0)                              {                                  q = 0; m = (int)(q < read ? read - q - 1 : end - q);                              }                              if (m == 0)                              {                                  write = q;                                  r = inflate_flush(z' r);                                  q = write; m = (int)(q < read ? read - q - 1 : end - q);                                  if (q == end && read != 0)                                  {                                      q = 0; m = (int)(q < read ? read - q - 1 : end - q);                                  }                                  if (m == 0)                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            t = left;                          if (t > n)                              t = n;                          if (t > m)                              t = m;                          Array.Copy(z.next_in' p' window' q' t);                          p += t; n -= t;                          q += t; m -= t;                          if ((left -= t) != 0)                              break;                          mode = last != 0 ? DRY : TYPE;                          break;                        case TABLE:                            while (k < (14))                          {                              if (n != 0)                              {                                  r = Z_OK;                              }                              else                              {                                  bitb = b; bitk = k;                                  z.avail_in = n;                                  z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                              ;                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            table = t = (b & 0x3fff);                          if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)                          {                              mode = BAD;                              z.msg = "too many length or distance symbols";                              r = Z_DATA_ERROR;                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);                          blens = new int[t];                          {                              b = SupportClass.URShift(b' (14)); k -= (14);                          }                            index = 0;                          mode = BTREE;                          goto case BTREE;                        case BTREE:                          while (index < 4 + (SupportClass.URShift(table' 10)))                          {                              while (k < (3))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                blens[border[index++]] = b & 7;                                {                                  b = SupportClass.URShift(b' (3)); k -= (3);                              }                          }                            while (index < 19)                          {                              blens[border[index++]] = 0;                          }                            bb[0] = 7;                          t = InfTree.inflate_trees_bits(blens' bb' tb' hufts' z);                          if (t != Z_OK)                          {                              r = t;                              if (r == Z_DATA_ERROR)                              {                                  blens = null;                                  mode = BAD;                              }                                bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                            index = 0;                          mode = DTREE;                          goto case DTREE;                        case DTREE:                          while (true)                          {                              t = table;                              if (!(index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f)))                              {                                  break;                              }                                int i' j' c;                                t = bb[0];                                while (k < (t))                              {                                  if (n != 0)                                  {                                      r = Z_OK;                                  }                                  else                                  {                                      bitb = b; bitk = k;                                      z.avail_in = n;                                      z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                  ;                                  n--;                                  b |= (z.next_in[p++] & 0xff) << k;                                  k += 8;                              }                                if (tb[0] == -1)                              {                                  //System.err.println("null...");                              }                                t = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];                              c = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];                                if (c < 16)                              {                                  b = SupportClass.URShift(b' (t)); k -= (t);                                  blens[index++] = c;                              }                              else                              {                                  // c == 16..18                                  i = c == 18 ? 7 : c - 14;                                  j = c == 18 ? 11 : 3;                                    while (k < (t + i))                                  {                                      if (n != 0)                                      {                                          r = Z_OK;                                      }                                      else                                      {                                          bitb = b; bitk = k;                                          z.avail_in = n;                                          z.total_in += p - z.next_in_index; z.next_in_index = p;                                          write = q;                                          return inflate_flush(z' r);                                      }                                      ;                                      n--;                                      b |= (z.next_in[p++] & 0xff) << k;                                      k += 8;                                  }                                    b = SupportClass.URShift(b' (t)); k -= (t);                                    j += (b & inflate_mask[i]);                                    b = SupportClass.URShift(b' (i)); k -= (i);                                    i = index;                                  t = table;                                  if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1))                                  {                                      blens = null;                                      mode = BAD;                                      z.msg = "invalid bit length repeat";                                      r = Z_DATA_ERROR;                                        bitb = b; bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      write = q;                                      return inflate_flush(z' r);                                  }                                    c = c == 16 ? blens[i - 1] : 0;                                  do                                  {                                      blens[i++] = c;                                  }                                  while (--j != 0);                                  index = i;                              }                          }                            tb[0] = -1;                          {                              int[] bl = new int[1];                              int[] bd = new int[1];                              int[] tl = new int[1];                              int[] td = new int[1];                                bl[0] = 9; // must be <= 9 for lookahead assumptions                              bd[0] = 6; // must be <= 9 for lookahead assumptions                              t = table;                              t = InfTree.inflate_trees_dynamic(257 + (t & 0x1f)' 1 + ((t >> 5) & 0x1f)' blens' bl' bd' tl' td' hufts' z);                              if (t != Z_OK)                              {                                  if (t == Z_DATA_ERROR)                                  {                                      blens = null;                                      mode = BAD;                                  }                                  r = t;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                              }                                codes = new InfCodes(bl[0]' bd[0]' hufts' tl[0]' hufts' td[0]' z);                          }                          blens = null;                          mode = CODES;                          goto case CODES;                        case CODES:                          bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                            if ((r = codes.proc(this' z' r)) != Z_STREAM_END)                          {                              return inflate_flush(z' r);                          }                          r = Z_OK;                          codes.free(z);                            p = z.next_in_index; n = z.avail_in; b = bitb; k = bitk;                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                            if (last == 0)                          {                              mode = TYPE;                              break;                          }                          mode = DRY;                          goto case DRY;                        case DRY:                          write = q;                          r = inflate_flush(z' r);                          q = write; m = (int)(q < read ? read - q - 1 : end - q);                          if (read != write)                          {                              bitb = b; bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              write = q;                              return inflate_flush(z' r);                          }                          mode = DONE;                          goto case DONE;                        case DONE:                          r = Z_STREAM_END;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        case BAD:                          r = Z_DATA_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            bitb = b; bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          write = q;                          return inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,proc,The following statement contains a magic number: switch (mode)                  {                      // waiting for "i:"=input' "o:"=output' "x:"=nothing                      case START:  // x: set up for LEN                          if (m >= 258 && n >= 10)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              r = inflate_fast(lbits' dbits' ltree' ltree_index' dtree' dtree_index' s' z);                                p = z.next_in_index; n = z.avail_in; b = s.bitb; k = s.bitk;                              q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                if (r != Z_OK)                              {                                  mode = r == Z_STREAM_END ? WASH : BADCODE;                                  break;                              }                          }                          need = lbits;                          tree = ltree;                          tree_index = ltree_index;                            mode = LEN;                          goto case LEN;                        case LEN:  // i: get length/literal/eob next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--;                              b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b = SupportClass.URShift(b' (tree[tindex + 1]));                          k -= (tree[tindex + 1]);                            e = tree[tindex];                            if (e == 0)                          {                              // literal                              lit = tree[tindex + 2];                              mode = LIT;                              break;                          }                          if ((e & 16) != 0)                          {                              // length                              get_Renamed = e & 15;                              len = tree[tindex + 2];                              mode = LENEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          if ((e & 32) != 0)                          {                              // end of block                              mode = WASH;                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid literal/length code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case LENEXT:  // i: getting length extra (have base)                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            len += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            need = dbits;                          tree = dtree;                          tree_index = dtree_index;                          mode = DIST;                          goto case DIST;                        case DIST:  // i: get distance next                          j = need;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            tindex = (tree_index + (b & inflate_mask[j])) * 3;                            b >>= tree[tindex + 1];                          k -= tree[tindex + 1];                            e = (tree[tindex]);                          if ((e & 16) != 0)                          {                              // distance                              get_Renamed = e & 15;                              dist = tree[tindex + 2];                              mode = DISTEXT;                              break;                          }                          if ((e & 64) == 0)                          {                              // next table                              need = e;                              tree_index = tindex / 3 + tree[tindex + 2];                              break;                          }                          mode = BADCODE; // invalid code                          z.msg = "invalid distance code";                          r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case DISTEXT:  // i: getting distance extra                          j = get_Renamed;                            while (k < (j))                          {                              if (n != 0)                                  r = Z_OK;                              else                              {                                  s.bitb = b; s.bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  s.write = q;                                  return s.inflate_flush(z' r);                              }                              n--; b |= (z.next_in[p++] & 0xff) << k;                              k += 8;                          }                            dist += (b & inflate_mask[j]);                            b >>= j;                          k -= j;                            mode = COPY;                          goto case COPY;                        case COPY:  // o: copying bytes in window' waiting for space                          f = q - dist;                          while (f < 0)                          {                              // modulo window size-"while" instead                              f += s.end; // of "if" handles invalid distances                          }                          while (len != 0)                          {                              if (m == 0)                              {                                  if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.write = q; r = s.inflate_flush(z' r);                                      q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                        if (q == s.end && s.read != 0)                                      {                                          q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                      }                                        if (m == 0)                                      {                                          s.bitb = b; s.bitk = k;                                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                          s.write = q;                                          return s.inflate_flush(z' r);                                      }                                  }                              }                                s.window[q++] = s.window[f++]; m--;                                if (f == s.end)                                  f = 0;                              len--;                          }                          mode = START;                          break;                        case LIT:  // o: got literal' waiting for output space                          if (m == 0)                          {                              if (q == s.end && s.read != 0)                              {                                  q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                              }                              if (m == 0)                              {                                  s.write = q; r = s.inflate_flush(z' r);                                  q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                                    if (q == s.end && s.read != 0)                                  {                                      q = 0; m = q < s.read ? s.read - q - 1 : s.end - q;                                  }                                  if (m == 0)                                  {                                      s.bitb = b; s.bitk = k;                                      z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                      s.write = q;                                      return s.inflate_flush(z' r);                                  }                              }                          }                          r = Z_OK;                            s.window[q++] = (byte)lit; m--;                            mode = START;                          break;                        case WASH:  // o: got eob' possibly more output                          if (k > 7)                          {                              // return unused byte' if any                              k -= 8;                              n++;                              p--; // can always return one                          }                            s.write = q; r = s.inflate_flush(z' r);                          q = s.write; m = q < s.read ? s.read - q - 1 : s.end - q;                            if (s.read != s.write)                          {                              s.bitb = b; s.bitk = k;                              z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                              s.write = q;                              return s.inflate_flush(z' r);                          }                          mode = END;                          goto case END;                        case END:                          r = Z_STREAM_END;                          s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        case BADCODE:  // x: got error                            r = Z_DATA_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                        default:                          r = Z_STREAM_ERROR;                            s.bitb = b; s.bitk = k;                          z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                          s.write = q;                          return s.inflate_flush(z' r);                  }
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k < (20)
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp[(tp_index + t) * 3 + 1]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp[(tp_index + t) * 3 + 1]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e = tp[(tp_index + t) * 3]) == 0
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp[(tp_index + t) * 3 + 1]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp[(tp_index + t) * 3 + 1]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = tp[(tp_index + t) * 3 + 2] + ((int)b & inflate_mask[e]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k < (15)
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e = tp[(tp_index + t) * 3];
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp[(tp_index + t) * 3 + 1]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp[(tp_index + t) * 3 + 1]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: e &= 15;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k += 8;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: d = tp[(tp_index + t) * 3 + 2] + (b & inflate_mask[e]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: q - r > 0 && 2 > (q - r)
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 16) != 0
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 16) != 0
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp[(tp_index + t) * 3 + 2];
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: t += tp[(tp_index + t) * 3 + 2];
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: b >>= (tp[(tp_index + t) * 3 + 1]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (tp[(tp_index + t) * 3 + 1]);
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: s.window[q++] = (byte)tp[(tp_index + t) * 3 + 2];
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e = tp[(tp_index + t) * 3]) == 0
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: (e & 64) == 0
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: c = (k >> 3) < c ? k >> 3 : c;
Magic Number,ComponentAce.Compression.Libs.zlib,InfCodes,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfCodes.cs,inflate_fast,The following statement contains a magic number: k -= (c << 3);
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: w < 8 || w > 15
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateInit,The following statement contains a magic number: w < 8 || w > 15
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflate,The following statement contains a magic number: switch (z.istate.mode)                  {                      case METHOD:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          if (((z.istate.method = z.next_in[z.next_in_index++]) & 0xf) != Z_DEFLATED)                          {                              z.istate.mode = BAD;                              z.msg = "unknown compression method";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          if ((z.istate.method >> 4) + 8 > z.istate.wbits)                          {                              z.istate.mode = BAD;                              z.msg = "invalid window size";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                          z.istate.mode = FLAG;                          goto case FLAG;                        case FLAG:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          b = (z.next_in[z.next_in_index++]) & 0xff;                            if ((((z.istate.method << 8) + b) % 31) != 0)                          {                              z.istate.mode = BAD;                              z.msg = "incorrect header check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            if ((b & PRESET_DICT) == 0)                          {                              z.istate.mode = BLOCKS;                              break;                          }                          z.istate.mode = DICT4;                          goto case DICT4;                        case DICT4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = DICT3;                          goto case DICT3;                        case DICT3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = DICT2;                          goto case DICT2;                        case DICT2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = DICT1;                          goto case DICT1;                        case DICT1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                          z.adler = z.istate.need;                          z.istate.mode = DICT0;                          return Z_NEED_DICT;                        case DICT0:                          z.istate.mode = BAD;                          z.msg = "need dictionary";                          z.istate.marker = 0; // can try inflateSync                          return Z_STREAM_ERROR;                        case BLOCKS:                            r = z.istate.blocks.proc(z' r);                          if (r == Z_DATA_ERROR)                          {                              z.istate.mode = BAD;                              z.istate.marker = 0; // can try inflateSync                              break;                          }                          if (r == Z_OK)                          {                              r = f;                          }                          if (r != Z_STREAM_END)                          {                              return r;                          }                          r = f;                          z.istate.blocks.reset(z' z.istate.was);                          if (z.istate.nowrap != 0)                          {                              z.istate.mode = DONE;                              break;                          }                          z.istate.mode = CHECK4;                          goto case CHECK4;                        case CHECK4:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need = ((z.next_in[z.next_in_index++] & 0xff) << 24) & unchecked((int)0xff000000L);                          z.istate.mode = CHECK3;                          goto case CHECK3;                        case CHECK3:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 16) & 0xff0000L);                          z.istate.mode = CHECK2;                          goto case CHECK2;                        case CHECK2:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (((z.next_in[z.next_in_index++] & 0xff) << 8) & 0xff00L);                          z.istate.mode = CHECK1;                          goto case CHECK1;                        case CHECK1:                            if (z.avail_in == 0)                              return r; r = f;                            z.avail_in--; z.total_in++;                          z.istate.need += (z.next_in[z.next_in_index++] & 0xffL);                            if (((int)(z.istate.was[0])) != ((int)(z.istate.need)))                          {                              z.istate.mode = BAD;                              z.msg = "incorrect data check";                              z.istate.marker = 5; // can't try inflateSync                              break;                          }                            z.istate.mode = DONE;                          goto case DONE;                        case DONE:                          return Z_STREAM_END;                        case BAD:                          return Z_DATA_ERROR;                        default:                          return Z_STREAM_ERROR;                  }
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: n != 0 && m < 4
Magic Number,ComponentAce.Compression.Libs.zlib,Inflate,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Inflate.cs,inflateSync,The following statement contains a magic number: m != 4
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: int[] r = new int[3];
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: xp = 2;
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[2] = (int)(q - u[h - 1] - j);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (u[h - 1] + j) * 3' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: r[0] = 128 + 64;
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,huft_build,The following statement contains a magic number: Array.Copy(r' 0' hp' (q + j) * 3' 3);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: int[] v = new int[19];
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_bits,The following statement contains a magic number: r = huft_build(c' 0' 19' 19' null' null' tb' bb' hp' hn' v);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: int[] v = new int[288];
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r = huft_build(c' 0' nl' 257' cplens' cplext' tl' bl' hp' hn' v);
Magic Number,ComponentAce.Compression.Libs.zlib,InfTree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfTree.cs,inflate_trees_dynamic,The following statement contains a magic number: r != Z_OK || (bd[0] == 0 && nl > 257)
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,d_code,The following statement contains a magic number: return ((dist) < 256 ? _dist_code[dist] : _dist_code[256 + (SupportClass.URShift((dist)' 7))]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[s.heap[s.heap_max] * 2 + 1] = 0;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[n * 2 + 1] = (short)bits;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: f = tree[n * 2];
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.static_len += f * (stree[n * 2 + 1] + xbits);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.bl_count[bits + 1] = (short)(s.bl_count[bits + 1] + 2);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: overflow -= 2;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: s.opt_len = (int)(s.opt_len + ((long)bits - (long)tree[m * 2 + 1]) * (long)tree[m * 2]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] = (short)bits;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_bitlen,The following statement contains a magic number: tree[m * 2 + 1] != bits
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2] != 0
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = 1;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: s.static_len -= stree[node * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: s.heap_len < 2
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[node * 2] = (short)(tree[n * 2] + tree[m * 2]);
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,build_tree,The following statement contains a magic number: tree[n * 2 + 1] = tree[m * 2 + 1] = (short)node;
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_codes,The following statement contains a magic number: int len = tree[n * 2 + 1];
Magic Number,ComponentAce.Compression.Libs.zlib,Tree,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\Tree.cs,gen_codes,The following statement contains a magic number: tree[n * 2] = (short)(bi_reverse(next_code[len]++' len));
Magic Number,ComponentAce.Compression.Libs.zlib,ZInputStream,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\ZInputStream.cs,skip,The following statement contains a magic number: int len = 512;
Missing Default,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaCluster,The following switch statement is missing a default case: switch ((flags & 6))  // 6 = 00000110                              {                                  case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                                      break;                                  case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                                  case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      for (int i = 1; i <= numberOfFrames; i++)                                          _f.ReadByte(); // frames                                      break;                                  case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                                      numberOfFrames = (byte)_f.ReadByte();                                      numberOfFrames++;                                      break;                              }
Missing Default,OpenSubtitlesUpload.VideoFormats,Mkv,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\VideoFormats\Mkv.cs,AnalyzeMatroskaBlock,The following switch statement is missing a default case: switch ((flags & 6))  // 6 = 00000110                  {                      case 0: System.Diagnostics.Debug.Print("No lacing");   // No lacing                          break;                      case 2: System.Diagnostics.Debug.Print("Xiph lacing"); // 2 = 00000010 = Xiph lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                      case 4: System.Diagnostics.Debug.Print("fixed-size");  // 4 = 00000100 = Fixed-size lacing                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          for (int i = 1; i <= numberOfFrames; i++)                              _f.ReadByte(); // frames                          break;                      case 6: System.Diagnostics.Debug.Print("EBML");        // 6 = 00000110 = EMBL                          numberOfFrames = (byte)_f.ReadByte();                          numberOfFrames++;                          break;                  }
Missing Default,ComponentAce.Compression.Libs.zlib,InfBlocks,D:\research\architectureSmells\repos1\SubtitleEdit_plugins\OpenSubtitlesUpload\DLL\zlib\InfBlocks.cs,proc,The following switch statement is missing a default case: switch (SupportClass.URShift(t' 1))                          {                              case 0:  // stored                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  t = k & 7; // go to byte boundary                                  {                                      b = SupportClass.URShift(b' (t)); k -= (t);                                  }                                  mode = LENS; // get length of stored block                                  break;                                case 1:  // fixed                                  {                                      int[] bl = new int[1];                                      int[] bd = new int[1];                                      int[][] tl = new int[1][];                                      int[][] td = new int[1][];                                        InfTree.inflate_trees_fixed(bl' bd' tl' td' z);                                      codes = new InfCodes(bl[0]' bd[0]' tl[0]' td[0]' z);                                  }                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = CODES;                                  break;                                case 2:  // dynamic                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                    mode = TABLE;                                  break;                                case 3:  // illegal                                  {                                      b = SupportClass.URShift(b' (3)); k -= (3);                                  }                                  mode = BAD;                                  z.msg = "invalid block type";                                  r = Z_DATA_ERROR;                                    bitb = b; bitk = k;                                  z.avail_in = n; z.total_in += p - z.next_in_index; z.next_in_index = p;                                  write = q;                                  return inflate_flush(z' r);                          }
